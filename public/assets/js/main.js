/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Top level file is just a mixin of submodules & constants


const { Deflate, deflate, deflateRaw, gzip } = __webpack_require__(/*! ./lib/deflate */ "./node_modules/pako/lib/deflate.js");

const { Inflate, inflate, inflateRaw, ungzip } = __webpack_require__(/*! ./lib/inflate */ "./node_modules/pako/lib/inflate.js");

const constants = __webpack_require__(/*! ./lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = ungzip;
module.exports.constants = constants;


/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {




const zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "./node_modules/pako/lib/zlib/deflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  let status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = zlib_deflate.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    this.result = utils.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  const deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {




const zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "./node_modules/pako/lib/zlib/inflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");
const GZheader     = __webpack_require__(/*! ./zlib/gzheader */ "./node_modules/pako/lib/zlib/gzheader.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  this.options = utils.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  let status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = zlib_inflate.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      zlib_inflate.inflateReset(strm);
      status = zlib_inflate.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  const inflator = new Inflate(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || msg[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = inflate;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/***/ ((module) => {




const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

module.exports.assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
module.exports.flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};


/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/***/ ((module) => {

// String encode/decode helpers



// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
module.exports.string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
module.exports.buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
module.exports.utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/***/ ((module) => {



// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


module.exports = adler32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/***/ ((module) => {



// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


module.exports = crc32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");
const adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32   = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const msg     = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,
  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY,
  Z_UNKNOWN,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */
//#ifdef GZIP
const GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */
//#endif
const EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */
const NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */
const COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */
const HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */
const BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */
const FINISH_STATE  = 666;    /* stream complete */

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = msg[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) * 2) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;

  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = (m >= wsize ? m - wsize : 0);
  } while (--n);
  n = wsize;
//#ifndef FASTEST
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = (m >= wsize ? m - wsize : 0);
    /* If n is not on any hash chain, prev[n] is garbage but
     * its value will never be used.
     */
  } while (--n);
//#endif
};

/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out  += len;
  s.pending_out  += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending      -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let n, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
const deflate_stored = (s, flush) => {

  /* Smallest worthy block size when not flushing or finishing. By default
   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
   * large input and output buffers, the stored block size will be larger.
   */
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

  /* Copy as many min_block or larger stored blocks directly to next_out as
   * possible. If flushing, copy the remaining available input to next_out as
   * stored blocks, if there is enough space.
   */
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    /* Set len to the maximum size block that we can copy directly with the
     * available input data and output space. Set left to how much of that
     * would be copied from what's left in the window.
     */
    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */
    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    if (s.strm.avail_out < have) {         /* need room for header */
      break;
    }
      /* maximum stored block length that will fit in avail_out: */
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;  /* bytes left in window */
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;   /* limit len to the input */
    }
    if (len > have) {
      len = have;             /* limit len to the output */
    }

    /* If the stored block would be less than min_block in length, or if
     * unable to copy all of the available input when flushing, then try
     * copying to the window and the pending buffer instead. Also don't
     * write an empty block when flushing -- deflate() does that.
     */
    if (len < min_block && ((len === 0 && flush !== Z_FINISH) ||
                        flush === Z_NO_FLUSH ||
                        len !== left + s.strm.avail_in)) {
      break;
    }

    /* Make a dummy stored block in pending to get the header bytes,
     * including any pending bits. This also updates the debugging counts.
     */
    last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);

    /* Replace the lengths in the dummy stored block with len. */
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;

    /* Write the stored block header bytes. */
    flush_pending(s.strm);

//#ifdef ZLIB_DEBUG
//    /* Update debugging counts for the data about to be copied. */
//    s->compressed_len += len << 3;
//    s->bits_sent += len << 3;
//#endif

    /* Copy uncompressed bytes from the window to next_out. */
    if (left) {
      if (left > len) {
        left = len;
      }
      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }

    /* Copy uncompressed bytes directly from next_in to next_out, updating
     * the check value.
     */
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);

  /* Update the sliding window with the last s->w_size bytes of the copied
   * data, or append all of the copied data to the existing window if less
   * than s->w_size bytes were copied. Also update the number of bytes to
   * insert in the hash tables, in the event that deflateParams() switches to
   * a non-zero compression level.
   */
  used -= s.strm.avail_in;    /* number of input bytes directly copied */
  if (used) {
    /* If any input was used, then no unused input remains in the window,
     * therefore s->block_start == s->strstart.
     */
    if (used >= s.w_size) {  /* supplant the previous history */
      s.matches = 2;     /* clear hash */
      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    }
    else {
      if (s.window_size - s.strstart <= used) {
        /* Slide the window down. */
        s.strstart -= s.w_size;
        //zmemcpy(s->window, s->window + s->w_size, s->strstart);
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;   /* add a pending slide_hash() */
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* If the last block was written to next_out, then done. */
  if (last) {
    return BS_FINISH_DONE;
  }

  /* If flushing and all input has been consumed, then done. */
  if (flush !== Z_NO_FLUSH && flush !== Z_FINISH &&
    s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }

  /* Fill the window with any remaining input. */
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    /* Slide the window down. */
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;       /* add a pending slide_hash() */
    }
    have += s.w_size;      /* more space now */
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* There was not enough avail_out to write a complete worthy or flushed
   * stored block to next_out. Write a stored block to pending instead, if we
   * have enough input for a worthy block, or if flushing and there is enough
   * room for the remaining input as a stored block in the pending buffer.
   */
  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    /* maximum stored block length that will fit in pending: */
  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block ||
     ((left || flush === Z_FINISH) && flush !== Z_NO_FLUSH &&
     s.strm.avail_in === 0 && left <= have)) {
    len = left > have ? have : left;
    last = flush === Z_FINISH && s.strm.avail_in === 0 &&
         len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }

  /* We've done all we can with the available input and output. */
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};


/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.sym_buf = 0;        /* buffer for distances and literals/lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.sym_next = 0;      /* running index in sym_buf */
  this.sym_end = 0;       /* symbol table full when sym_next reaches this */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
const deflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&
//#ifdef GZIP
                                s.status !== GZIP_STATE &&
//#endif
                                s.status !== EXTRA_STATE &&
                                s.status !== NAME_STATE &&
                                s.status !== COMMENT_STATE &&
                                s.status !== HCRC_STATE &&
                                s.status !== BUSY_STATE &&
                                s.status !== FINISH_STATE)) {
    return 1;
  }
  return 0;
};


const deflateResetKeep = (strm) => {

  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status =
//#ifdef GZIP
    s.wrap === 2 ? GZIP_STATE :
//#endif
    s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;     /* to pass state test in deflateReset() */

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  /* We overlay pending_buf and sym_buf. This works since the average size
   * for length/distance pairs over any compressed block is assured to be 31
   * bits or less.
   *
   * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   * possible fixed-codes length/distance pair is then 31 bits total.
   *
   * sym_buf starts one-fourth of the way into pending_buf. So there are
   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   * in sym_buf is three bytes -- two for the distance and one for the
   * literal/length. As each symbol is consumed, the pointer to the next
   * sym_buf value to read moves forward three bytes. From that symbol, up to
   * 31 bits are written to pending_buf. The closest the written pending_buf
   * bits gets to the next sym_buf symbol to read is just before the last
   * code is written. At that time, 31*(n-2) bits have been written, just
   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
   * symbols are written.) The closest the writing gets to what is unread is
   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
   * can range from 128 to 32768.
   *
   * Therefore, at a minimum, there are 142 bits of space between what is
   * written and what is read in the overlain buffers, so the symbols cannot
   * be overwritten by the compressed data. That space is actually 139 bits,
   * due to the three-bit fixed-code block header.
   *
   * That covers the case where either Z_FIXED is specified, forcing fixed
   * codes, or when the use of fixed codes is chosen, because that choice
   * results in a smaller compressed block than dynamic codes. That latter
   * condition then assures that the above analysis also covers all dynamic
   * blocks. A dynamic-code block will only be chosen to be emitted if it has
   * fewer bits than a fixed-code block would for the same set of symbols.
   * Therefore its average symbol length is assured to be less than 31. So
   * the compressed data for a dynamic block also cannot overwrite the
   * symbols from which it is being constructed.
   */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->sym_buf = s->pending_buf + s->lit_bufsize;
  s.sym_buf = s.lit_bufsize;

  //s->sym_end = (s->lit_bufsize - 1) * 3;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};


/* ========================================================================= */
const deflate = (strm, flush) => {

  if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  const s = strm.state;

  if (!strm.output ||
      (strm.avail_in !== 0 && !strm.input) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Write the header */
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    /* zlib header */
    let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
    let level_flags = -1;

    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= (level_flags << 6);
    if (s.strstart !== 0) { header |= PRESET_DICT; }
    header += 31 - (header % 31);

    putShortMSB(s, header);

    /* Save the adler32 of the preset dictionary: */
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }
    strm.adler = 1; // adler32(0L, Z_NULL, 0);
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK;
    }
  }
//#ifdef GZIP
  if (s.status === GZIP_STATE) {
    /* gzip header */
    strm.adler = 0;  //crc32(0L, Z_NULL, 0);
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) { // s->gzhead == Z_NULL
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    }
    else {
      put_byte(s, (s.gzhead.text ? 1 : 0) +
                  (s.gzhead.hcrc ? 2 : 0) +
                  (!s.gzhead.extra ? 0 : 4) +
                  (!s.gzhead.name ? 0 : 8) +
                  (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 0xff);
      put_byte(s, (s.gzhead.time >> 8) & 0xff);
      put_byte(s, (s.gzhead.time >> 16) & 0xff);
      put_byte(s, (s.gzhead.time >> 24) & 0xff);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, s.gzhead.os & 0xff);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 0xff);
        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        // zmemcpy(s.pending_buf + s.pending,
        //    s.gzhead.extra + s.gzindex, copy);
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
        beg = 0;
        left -= copy;
      }
      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      // zmemcpy(s->pending_buf + s->pending,
      //     s->gzhead->extra + s->gzindex, left);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      put_byte(s, strm.adler & 0xff);
      put_byte(s, (strm.adler >> 8) & 0xff);
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
    }
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK;
    }
  }
//#endif

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) :
                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                 s.strategy === Z_RLE ? deflate_rle(s, flush) :
                 configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
};


const deflateEnd = (strm) => {

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR;
  }

  const status = strm.state.status;

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
};


module.exports.deflateInit = deflateInit;
module.exports.deflateInit2 = deflateInit2;
module.exports.deflateReset = deflateReset;
module.exports.deflateResetKeep = deflateResetKeep;
module.exports.deflateSetHeader = deflateSetHeader;
module.exports.deflate = deflate;
module.exports.deflateEnd = deflateEnd;
module.exports.deflateSetDictionary = deflateSetDictionary;
module.exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateGetDictionary = deflateGetDictionary;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD = 16209;       /* got a data error -- remain here until reset */
const TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32       = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32         = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const inflate_fast  = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");
const inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH, Z_BLOCK, Z_TREES,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 16180;       /* i: waiting for magic header */
const    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
const    TIME = 16182;       /* i: waiting for modification time (gzip) */
const    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 16184;      /* i: waiting for extra length (gzip) */
const    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
const    NAME = 16186;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
const    HCRC = 16188;       /* i: waiting for header crc (gzip) */
const    DICTID = 16189;    /* i: waiting for dictionary check value */
const    DICT = 16190;      /* waiting for inflateSetDictionary() call */
const        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 16193;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 16196;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 16197;   /* i: waiting for code length code lengths */
const        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 16199;      /* i: same as LEN below, but only first time in */
const            LEN = 16200;       /* i: waiting for length/lit/eob code */
const            LENEXT = 16201;    /* i: waiting for length extra bits */
const            DIST = 16202;      /* i: waiting for distance code */
const            DISTEXT = 16203;   /* i: waiting for distance extra bits */
const            MATCH = 16204;     /* o: waiting for output space to copy string */
const            LIT = 16205;       /* o: waiting for output space to write literal */
const    CHECK = 16206;     /* i: waiting for 32-bit check value */
const    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 16208;      /* finished check, done -- remain here until reset */
const    BAD = 16209;       /* got a data error -- remain here until reset */
const    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.strm = null;           /* pointer back to this zlib stream */
  this.mode = 0;              /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                 bit 2 true to validate check value */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                 -1 if raw or no header yet */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm ||
    state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};


const inflateResetKeep = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
};


const inflateReset = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null/*Z_NULL*/;
  state.mode = HEAD;     /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (inflateStateCheck(strm) || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0;               /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if ((state.wrap & 4) && _out) {
            strm.adler = state.check =
                /*UPDATE_CHECK(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if ((state.wrap & 4) && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
};


module.exports.inflateReset = inflateReset;
module.exports.inflateReset2 = inflateReset2;
module.exports.inflateResetKeep = inflateResetKeep;
module.exports.inflateInit = inflateInit;
module.exports.inflateInit2 = inflateInit2;
module.exports.inflate = inflate;
module.exports.inflateEnd = inflateEnd;
module.exports.inflateGetHeader = inflateGetHeader;
module.exports.inflateSetDictionary = inflateSetDictionary;
module.exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES = 0;
const LENS = 1;
const DISTS = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
//  let shoextra;    /* extra bits table to use */
  let match;                  /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    match = 20;

  } else if (type === LENS) {
    base = lbase;
    extra = lext;
    match = 257;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


module.exports = inflate_table;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH    = 3;
const MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS      = 256;
/* number of literal bytes 0..255 */

const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES       = 30;
/* number of distance codes */

const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

const MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */

  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Tracev((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) => {
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */

  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    code = (code + bl_count[bits - 1]) << 1;
    next_code[bits] = code;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) => {
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */

  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) => {
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */

  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let sx = 0;         /* running index in sym_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and sym_buf is ok: */
      //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");

    } while (sx < s.sym_next);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */

  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */

  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "block list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* block_mask is the bit mask of block-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let block_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("block-listed") bytes. */
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("allow-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "block-listed" or "allow-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  bi_windup(s);        /* align on byte boundary */
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
const _tr_flush_block = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->sym_next / 3));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally = (s, dist, lc) => {
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

  return (s.sym_next === s.sym_end);
};

module.exports._tr_init  = _tr_init;
module.exports._tr_stored_block = _tr_stored_block;
module.exports._tr_flush_block  = _tr_flush_block;
module.exports._tr_tally = _tr_tally;
module.exports._tr_align = _tr_align;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ "./client/Config/Config.ts":
/*!*********************************!*\
  !*** ./client/Config/Config.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = {
    NAME: "NodeBall",
    SERVER_HOST: "127.0.0.1",
    SERVER_PORT: 8090,
    SERVER_UPDATE_INTERVAL: 60
};


/***/ }),

/***/ "./client/Config/Resources.ts":
/*!************************************!*\
  !*** ./client/Config/Resources.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resources = void 0;
exports.Resources = {
    // AUDIO
    KICK: "kick.wav",
    JOIN: "join.wav",
    LEAVE: "leave.wav",
    HIGHLIGHT: "highlight.wav",
    CROWD: "crowd.wav",
    CHAT: "chat.wav",
    GOAL: "goal.wav",
    NOTIF: "notif.mp3",
    // IMAGES
    TILE_GRASS: "grass.png",
    TILE_HOCKEY: "hockey.png",
    AVATAR_1: "avatars/1.svg",
    AVATAR_2: "avatars/2.svg",
    AVATAR_3: "avatars/3.svg",
    AVATAR_4: "avatars/4.svg",
    AVATAR_5: "avatars/5.svg",
    AVATAR_6: "avatars/6.svg",
    AVATAR_7: "avatars/7.svg",
    AVATAR_8: "avatars/8.svg",
    AVATAR_9: "avatars/9.svg",
    AVATAR_10: "avatars/10.svg",
    AVATAR_11: "avatars/11.svg",
    AVATAR_12: "avatars/12.svg",
    AVATAR_13: "avatars/13.svg",
    AVATAR_14: "avatars/14.svg",
    AVATAR_15: "avatars/15.svg",
    AVATAR_16: "avatars/16.svg",
    AVATAR_17: "avatars/17.svg",
    AVATAR_18: "avatars/18.svg",
    AVATAR_19: "avatars/19.svg",
    AVATAR_20: "avatars/20.svg",
    AVATAR_21: "avatars/21.svg",
    AVATAR_22: "avatars/22.svg",
    AVATAR_23: "avatars/23.svg",
    AVATAR_24: "avatars/24.svg",
    AVATAR_25: "avatars/25.svg",
    AVATAR_26: "avatars/26.svg",
    AVATAR_27: "avatars/27.svg",
    AVATAR_28: "avatars/28.svg",
    AVATAR_29: "avatars/29.svg",
    AVATAR_30: "avatars/30.svg",
    AVATAR_31: "avatars/31.svg",
    AVATAR_32: "avatars/32.svg",
    AVATAR_33: "avatars/33.svg",
    AVATAR_34: "avatars/34.svg",
    AVATAR_35: "avatars/35.svg",
    AVATAR_36: "avatars/36.svg",
    AVATAR_37: "avatars/37.svg",
    AVATAR_38: "avatars/38.svg",
    AVATAR_39: "avatars/39.svg",
    AVATAR_40: "avatars/40.svg",
    AVATAR_41: "avatars/41.svg",
    AVATAR_42: "avatars/42.svg",
    AVATAR_43: "avatars/43.svg",
    AVATAR_44: "avatars/44.svg",
    AVATAR_45: "avatars/45.svg",
    AVATAR_46: "avatars/46.svg",
    AVATAR_47: "avatars/47.svg",
    AVATAR_48: "avatars/48.svg",
    AVATAR_49: "avatars/49.svg",
    AVATAR_50: "avatars/50.svg",
    AVATAR_51: "avatars/51.svg",
    AVATAR_52: "avatars/52.svg",
    AVATAR_53: "avatars/53.svg",
    AVATAR_54: "avatars/54.svg",
    AVATAR_55: "avatars/55.svg",
    AVATAR_56: "avatars/56.svg",
    AVATAR_57: "avatars/57.svg",
    AVATAR_58: "avatars/58.svg",
    AVATAR_59: "avatars/59.svg",
    AVATAR_60: "avatars/60.svg",
    AVATAR_61: "avatars/61.svg",
    AVATAR_62: "avatars/62.svg",
    AVATAR_63: "avatars/63.svg",
    AVATAR_64: "avatars/64.svg",
    AVATAR_65: "avatars/65.svg",
    AVATAR_66: "avatars/66.svg",
    AVATAR_67: "avatars/67.svg",
    AVATAR_68: "avatars/68.svg",
    AVATAR_69: "avatars/69.svg",
    AVATAR_70: "avatars/70.svg",
    AVATAR_71: "avatars/71.svg",
    AVATAR_72: "avatars/72.svg",
    AVATAR_73: "avatars/73.svg",
    AVATAR_74: "avatars/74.svg",
    AVATAR_75: "avatars/75.svg",
    AVATAR_76: "avatars/76.svg",
    AVATAR_77: "avatars/77.svg",
    AVATAR_78: "avatars/78.svg",
    AVATAR_79: "avatars/79.svg",
    AVATAR_80: "avatars/80.svg",
    AVATAR_81: "avatars/81.svg",
    AVATAR_82: "avatars/82.svg",
    AVATAR_83: "avatars/83.svg",
    AVATAR_84: "avatars/84.svg",
    AVATAR_85: "avatars/85.svg",
    AVATAR_86: "avatars/86.svg",
    AVATAR_87: "avatars/87.svg",
    AVATAR_88: "avatars/88.svg",
    AVATAR_89: "avatars/89.svg",
    AVATAR_90: "avatars/90.svg",
    AVATAR_91: "avatars/91.svg",
    AVATAR_92: "avatars/92.svg",
    AVATAR_93: "avatars/93.svg",
    AVATAR_94: "avatars/94.svg",
    AVATAR_95: "avatars/95.svg",
    AVATAR_96: "avatars/96.svg",
    AVATAR_97: "avatars/97.svg",
    AVATAR_98: "avatars/98.svg",
    AVATAR_99: "avatars/99.svg",
    AVATAR_100: "avatars/100.svg",
    AVATAR_101: "avatars/101.svg",
    AVATAR_102: "avatars/102.svg",
    AVATAR_103: "avatars/103.svg",
    AVATAR_104: "avatars/104.svg",
    AVATAR_105: "avatars/105.svg",
    AVATAR_106: "avatars/106.svg",
    AVATAR_107: "avatars/107.svg",
    AVATAR_108: "avatars/108.svg",
    AVATAR_109: "avatars/109.svg",
    AVATAR_110: "avatars/110.svg",
    AVATAR_111: "avatars/111.svg",
    AVATAR_112: "avatars/112.svg",
    AVATAR_113: "avatars/113.svg",
    AVATAR_114: "avatars/114.svg",
    AVATAR_115: "avatars/115.svg",
    AVATAR_116: "avatars/116.svg",
    AVATAR_117: "avatars/117.svg",
    AVATAR_118: "avatars/118.svg",
    AVATAR_119: "avatars/119.svg",
    AVATAR_120: "avatars/120.svg",
    AVATAR_121: "avatars/121.svg",
    AVATAR_122: "avatars/122.svg",
    AVATAR_123: "avatars/123.svg",
    AVATAR_124: "avatars/124.svg",
    AVATAR_125: "avatars/125.svg",
    AVATAR_126: "avatars/126.svg",
    AVATAR_127: "avatars/127.svg",
    AVATAR_128: "avatars/128.svg",
    AVATAR_129: "avatars/129.svg",
    AVATAR_130: "avatars/130.svg",
    AVATAR_131: "avatars/131.svg",
    AVATAR_132: "avatars/132.svg",
    AVATAR_133: "avatars/133.svg",
    AVATAR_134: "avatars/134.svg",
    AVATAR_135: "avatars/135.svg",
    AVATAR_136: "avatars/136.svg",
    AVATAR_137: "avatars/137.svg",
    AVATAR_138: "avatars/138.svg",
    AVATAR_139: "avatars/139.svg",
    AVATAR_140: "avatars/140.svg",
    AVATAR_141: "avatars/141.svg",
    AVATAR_142: "avatars/142.svg",
    AVATAR_143: "avatars/143.svg",
    AVATAR_144: "avatars/144.svg",
    AVATAR_145: "avatars/145.svg",
    AVATAR_146: "avatars/146.svg",
    AVATAR_147: "avatars/147.svg",
    AVATAR_148: "avatars/148.svg",
    AVATAR_149: "avatars/149.svg",
    AVATAR_150: "avatars/150.svg",
    AVATAR_151: "avatars/151.svg",
    AVATAR_152: "avatars/152.svg",
    AVATAR_153: "avatars/153.svg",
    AVATAR_154: "avatars/154.svg",
    AVATAR_155: "avatars/155.svg",
    AVATAR_156: "avatars/156.svg",
    AVATAR_157: "avatars/157.svg",
    AVATAR_158: "avatars/158.svg",
    AVATAR_159: "avatars/159.svg",
    AVATAR_160: "avatars/160.svg",
    AVATAR_161: "avatars/161.svg",
    AVATAR_162: "avatars/162.svg",
    AVATAR_163: "avatars/163.svg",
    AVATAR_164: "avatars/164.svg",
    AVATAR_165: "avatars/165.svg",
    AVATAR_166: "avatars/166.svg",
    AVATAR_167: "avatars/167.svg",
    AVATAR_168: "avatars/168.svg",
    AVATAR_169: "avatars/169.svg",
    AVATAR_170: "avatars/170.svg",
    AVATAR_171: "avatars/171.svg",
    AVATAR_172: "avatars/172.svg",
    AVATAR_173: "avatars/173.svg",
    AVATAR_174: "avatars/174.svg",
    AVATAR_175: "avatars/175.svg",
    AVATAR_176: "avatars/176.svg",
    AVATAR_177: "avatars/177.svg",
    AVATAR_178: "avatars/178.svg",
    AVATAR_179: "avatars/179.svg",
    AVATAR_180: "avatars/180.svg",
    AVATAR_181: "avatars/181.svg",
    AVATAR_182: "avatars/182.svg",
    AVATAR_183: "avatars/183.svg",
    AVATAR_184: "avatars/184.svg",
    AVATAR_185: "avatars/185.svg",
    AVATAR_186: "avatars/186.svg",
    AVATAR_187: "avatars/187.svg",
    AVATAR_188: "avatars/188.svg",
    AVATAR_189: "avatars/189.svg",
    AVATAR_190: "avatars/190.svg",
    AVATAR_191: "avatars/191.svg",
    AVATAR_192: "avatars/192.svg",
    AVATAR_193: "avatars/193.svg",
    AVATAR_194: "avatars/194.svg",
    AVATAR_195: "avatars/195.svg",
    AVATAR_196: "avatars/196.svg",
    AVATAR_197: "avatars/197.svg",
    AVATAR_198: "avatars/198.svg",
    AVATAR_199: "avatars/199.svg",
    AVATAR_200: "avatars/200.svg",
    AVATAR_201: "avatars/201.svg",
    AVATAR_202: "avatars/202.svg",
    AVATAR_203: "avatars/203.svg",
    AVATAR_204: "avatars/204.svg",
    AVATAR_205: "avatars/205.svg",
    AVATAR_206: "avatars/206.svg",
    AVATAR_207: "avatars/207.svg",
    AVATAR_208: "avatars/208.svg",
    AVATAR_209: "avatars/209.svg",
    AVATAR_210: "avatars/210.svg",
    AVATAR_211: "avatars/211.svg",
    AVATAR_212: "avatars/212.svg",
    AVATAR_213: "avatars/213.svg",
    AVATAR_214: "avatars/214.svg",
    AVATAR_215: "avatars/215.svg",
    AVATAR_216: "avatars/216.svg",
    AVATAR_217: "avatars/217.svg",
    AVATAR_218: "avatars/218.svg",
    AVATAR_219: "avatars/219.svg",
    AVATAR_220: "avatars/220.svg",
    AVATAR_221: "avatars/221.svg",
    AVATAR_222: "avatars/222.svg",
    AVATAR_223: "avatars/223.svg",
    AVATAR_224: "avatars/224.svg",
    AVATAR_225: "avatars/225.svg",
    AVATAR_226: "avatars/226.svg",
    AVATAR_227: "avatars/227.svg",
    AVATAR_228: "avatars/228.svg",
    AVATAR_229: "avatars/229.svg",
    AVATAR_230: "avatars/230.svg",
    AVATAR_231: "avatars/231.svg",
    AVATAR_232: "avatars/232.svg",
    AVATAR_233: "avatars/233.svg",
    AVATAR_234: "avatars/234.svg",
    AVATAR_235: "avatars/235.svg",
    AVATAR_236: "avatars/236.svg",
    AVATAR_237: "avatars/237.svg",
    AVATAR_238: "avatars/238.svg",
    AVATAR_239: "avatars/239.svg",
    AVATAR_240: "avatars/240.svg",
    AVATAR_241: "avatars/241.svg",
    AVATAR_242: "avatars/242.svg",
    AVATAR_243: "avatars/243.svg",
    AVATAR_244: "avatars/244.svg",
    AVATAR_245: "avatars/245.svg",
    AVATAR_246: "avatars/246.svg",
    AVATAR_247: "avatars/247.svg",
    AVATAR_248: "avatars/248.svg",
    AVATAR_249: "avatars/249.svg",
    AVATAR_250: "avatars/250.svg",
    AVATAR_251: "avatars/251.svg",
    AVATAR_252: "avatars/252.svg",
    AVATAR_253: "avatars/253.svg",
    AVATAR_254: "avatars/254.svg",
    AVATAR_255: "avatars/255.svg",
    AVATAR_256: "avatars/256.svg",
    AVATAR_257: "avatars/257.svg",
    AVATAR_258: "avatars/258.svg",
    AVATAR_259: "avatars/259.svg",
    AVATAR_260: "avatars/260.svg",
    AVATAR_261: "avatars/261.svg",
    AVATAR_262: "avatars/262.svg",
    AVATAR_263: "avatars/263.svg",
    AVATAR_264: "avatars/264.svg",
    AVATAR_265: "avatars/265.svg",
    AVATAR_266: "avatars/266.svg",
    AVATAR_267: "avatars/267.svg",
    AVATAR_268: "avatars/268.svg",
    AVATAR_269: "avatars/269.svg",
    AVATAR_270: "avatars/270.svg",
};


/***/ }),

/***/ "./client/Language/LanguageList.ts":
/*!*****************************************!*\
  !*** ./client/Language/LanguageList.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const EN_1 = __webpack_require__(/*! ./List/EN */ "./client/Language/List/EN.ts");
const FR_1 = __webpack_require__(/*! ./List/FR */ "./client/Language/List/FR.ts");
exports["default"] = {
    EN: EN_1.EN,
    FR: FR_1.FR
};


/***/ }),

/***/ "./client/Language/LanguageManager.ts":
/*!********************************************!*\
  !*** ./client/Language/LanguageManager.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const main_1 = __importDefault(__webpack_require__(/*! ../main */ "./client/main.ts"));
const LanguageList_1 = __importDefault(__webpack_require__(/*! ./LanguageList */ "./client/Language/LanguageList.ts"));
class LanguageManager {
    constructor() {
        this.defaultLanguage = LanguageList_1.default.EN;
        this.activeLanguage = null;
    }
    init() {
        main_1.default.logger.sendLog("INFO", "Initiliazing languages...");
        const languageStored = localStorage.getItem("language");
        if (languageStored != null)
            return this.setLanguage(languageStored);
        const userLanguage = window.navigator.language || window.navigator.userLanguage;
        if (userLanguage != null)
            this.setLanguage(userLanguage.substring(0, 2));
        else
            this.activeLanguage = this.defaultLanguage;
    }
    setLanguage(code) {
        const languageValue = this.getLanguageByCode(code);
        if (languageValue != null) {
            localStorage.setItem("language", code.toUpperCase());
            this.activeLanguage = languageValue;
        }
        else
            this.activeLanguage = this.defaultLanguage;
    }
    getLanguageByCode(code) {
        for (let i in LanguageList_1.default) {
            if (code.toUpperCase() == i)
                return LanguageList_1.default[i];
        }
        return null;
    }
    getAvailableLanguages() {
        const availableLanguage = [];
        for (let i in LanguageList_1.default) {
            availableLanguage.push(i);
        }
        return availableLanguage;
    }
    getValueForKey(key, params = []) {
        if (this.activeLanguage != null && this.activeLanguage[key] != null) {
            params.forEach((param, index) => {
                if (param != null && param.toString().startsWith("%TRAD_"))
                    params[index] = this.getValueForKey(param.replace("%TRAD_", ""));
            });
            return this.activeLanguage[key].supplant(params);
        }
        else {
            if (this.defaultLanguage[key] != null) {
                params.forEach((param, index) => {
                    if (param != null && param.toString().startsWith("%TRAD_"))
                        params[index] = this.getValueForKey(param.replace("%TRAD_", ""));
                });
                return this.defaultLanguage[key].supplant(params);
            }
        }
        return "Missing key: " + key;
    }
}
exports["default"] = LanguageManager;


/***/ }),

/***/ "./client/Language/List/EN.ts":
/*!************************************!*\
  !*** ./client/Language/List/EN.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EN = void 0;
exports.EN = {
    CODE: "EN",
    // LOADING
    LOADING_MESSAGE: "Initializing {0}...",
    LOADING_RESOURCES: "Loading resources...",
    LOADING_CONNECTION_TO_MAIN_SERVER: "Connecting to main server...",
    LOADING_FETCHING_REGION_SERVERS: "Fetching region servers...",
    // GENERIC_ERROR
    GENERIC_ERROR_CONNECTION_LOST: "Connection to server lost.",
    GENERIC_ERROR_SERVERS: "An error occurred with servers.",
    GENERIC_ERROR_NO_SERVER_AVAILABLE: "There are no servers available.",
    // ACCOUNT
    ACCOUNT_LANGUAGE: "Language",
    ACCOUNT_LOGIN: "Login",
    ACCOUNT_REGISTER: "Register",
    ACCOUNT_USERNAME: "Username",
    ACCOUNT_PASSWORD: "Password",
    ACCOUNT_CONFIRM_PASSWORD: "Confirm your password",
    ACCOUNT_SERVER: "Server [{0}] - Ping: {1}ms",
    // ACCOUNT_ERROR
    ACCOUNT_ERROR_BANNED: "You are banned until the {0}.",
    ACCOUNT_ERROR_OCCURED: "An error occured, please reload the page.",
    ACCOUNT_ERROR_FIELDS: "Please complete all fields.",
    ACCOUNT_ERROR_ALREADY_LOGGED: "You are already logged.",
    ACCOUNT_ERROR_INVALID: "Invalid username or password.",
    ACCOUNT_ERROR_USERNAME_LENGTH: "Your nickname must be between 3 and 15 characters long.",
    ACCOUNT_ERROR_USERNAME_ALPHANUMERIC: "Your nickname must be alphanumeric.",
    ACCOUNT_ERROR_USERNAME_ALREADY_USED: "Your nickname is already used.",
    ACCOUNT_ERROR_USERNAME_START_NUMBER: "Your nickname cannot start with a number.",
    ACCOUNT_ERROR_PASSWORD_LENGTH: "Your password must be at least 6 characters long.",
    ACCOUNT_ERROR_PASSWORDS_DIFFERENT: "Your two passwords are different.",
    ACCOUNT_INVALID_SERVER: "The selected server is not available.",
    // GAME
    // GAME_GENERAL
    GAME_GENERAL_LOADING: "Loading...",
    GAME_GENERAL_CLOSE: "Close",
    GAME_GENERAL_OVERTIME: "Overtime!",
    GAME_GENERAL_PAUSE: "Pause",
    GAME_GENERAL_OWN_GOAL: "Own goal by <span class='{0}'>{1}</span>!",
    GAME_GENERAL_GOAL: "Goal by <span class='{0}'>{1}</span>!",
    GAME_GENERAL_NOT_AVAILABLE: "Not available yet...",
    GAME_GENERAL_TEAM: "Team",
    GAME_GENERAL_PLAYER: "Player",
    GAME_GENERAL_BY_PLAYER: "By player",
    GAME_GENERAL_ACTION: "Action",
    GAME_GENERAL_DATE: "Date",
    GAME_GENERAL_TYPE: "Type",
    GAME_GENERAL_EXPIRE: "Expire",
    GAME_GENERAL_VALIDATE: "Validate",
    // TEAM
    GAME_TEAM_SPECTATORS: "Spectators",
    GAME_TEAM_RED: "Red",
    GAME_TEAM_BLUE: "Blue",
    // GAME_CHAT
    GAME_CHAT_MESSAGE: "Message...",
    GAME_CHAT_OPTION_ROOM: "Room",
    GAME_CHAT_OPTION_TEAM: "Team",
    GAME_CHAT_ROOM_JOINED: "You just joined the room {0}, type /room <roomName> to change room.",
    GAME_CHAT_PM_FROM: "Whisper from {0}",
    GAME_CHAT_PM_TO: "Whisper to {0}",
    GAME_CHAT_PM_OFFLINE: "{0} is offline.",
    GAME_CHAT_FRIEND_ADDED: "{0} is now your friend.",
    GAME_CHAT_FRIEND_OTHER_ADDED: "{0} added you to their friends list. Type /friend {0} to add him back.",
    GAME_CHAT_FRIEND_OTHER_ADDED_BACK: "{0} added you back to their friend list.",
    GAME_CHAT_JOIN_ROOM: "{0} joined the room.",
    GAME_CHAT_LEFT_ROOM: "{0} left the room.",
    GAME_CHAT_FRIEND_LOGIN: "{0} just logged in.",
    GAME_CHAT_FRIEND_LOGOUT: "{0} just logged out.",
    GAME_CHAT_FRIEND_ERROR_MAX: "You have reached the limit of {0} friends.",
    GAME_CHAT_INVALID_COMMAND: "Invalid command.",
    GAME_CHAT_MUTED_MINUTES: "You are muted for {0} minute(s).",
    GAME_CHAT_MUTED_HOURS: "You are muted for {0} hours(s).",
    GAME_CHAT_NEW_REPORT: "New report by {0}.",
    GAME_CHAT_REPORTED: "{0} has been reported.",
    GAME_CHAT_ALREADY_REPORTED: "You have already reported {0}.",
    GAME_CHAT_REBOOT_CANCEL: "Server restart was canceled.",
    GAME_CHAT_REBOOT_MINUTES: "The server will restart in {0} minutes.",
    GAME_CHAT_REBOOT_SECONDS: "The server will restart in {0} seconds.",
    GAME_CHAT_LEVEL_UP: "You are now level {0}.",
    GAME_CHAT_RANK_UP: "You are now {0} {1}.",
    // GAME_USER_MENU
    GAME_USER_MENU_PROFILE: "Profile",
    GAME_USER_MENU_WHISPER: "Whisper",
    GAME_USER_MENU_FRIEND: "Add as friend",
    GAME_USER_MENU_REPORT: "Report",
    GAME_USER_MENU_MUTE: "Mute",
    GAME_USER_MENU_BAN: "Ban",
    // GAME_SETTINGS
    GAME_SETTINGS: "Settings",
    GAME_MENU_GRAPHICS: "Graphics",
    GAME_MENU_GRAPHICS_ZOOM: "Zoom",
    GAME_MENU_GRAPHICS_FPS: "FPS Limit",
    GAME_MENU_GRAPHICS_FPS_NO_LIMIT: "None",
    GAME_MENU_AUDIO: "Audio",
    GAME_MENU_AUDIO_GENERAL: "General",
    GAME_MENU_AUDIO_CHAT: "Chat",
    GAME_MENU_AUDIO_GAME: "Game",
    GAME_MENU_AUDIO_NOTIFICATION: "Notification",
    GAME_MENU_INPUTS: "Inputs",
    GAME_MENU_INPUTS_PRESS: "Press a key",
    GAME_MENU_INPUTS_UP: "Up",
    GAME_MENU_INPUTS_DOWN: "Down",
    GAME_MENU_INPUTS_LEFT: "Left",
    GAME_MENU_INPUTS_RIGHT: "Right",
    GAME_MENU_INPUTS_KICK: "Kick",
    GAME_MENU_INPUTS_TOGGLE_CHAT: "Toggle chat",
    // GAME_STATS
    GAME_STATS_REGISTERED: "Registered",
    GAME_STATS_LEVEL_XP: "Level",
    GAME_STATS_ELO: "Rank",
    GAME_STATS_GAMES: "Games",
    GAME_STATS_GAMES_PLAYED: "Games played",
    GAME_STATS_GAMES_WON: "Games won",
    GAME_STATS_GAMES_LOST: "Games lost",
    GAME_STATS_WIN_RATE: "Win rate",
    GAME_STATS_BEST_STREAK: "Best streak",
    GAME_STATS_GENERAL: "General stats",
    GAME_STATS_SHOTS: "Shots",
    GAME_STATS_SHOTS_PER_MATCH: "Shots per match",
    GAME_STATS_GOALS: "Goals",
    GAME_STATS_GOALS_PER_MATCH: "Goals per match",
    GAME_STATS_HAT_TRICKS: "Hat tricks",
    GAME_STATS_ASSISTS: "Assists",
    GAME_STATS_ASSISTS_PER_MATCH: "Assists per match",
    GAME_STATS_SAVES: "Saves",
    GAME_STATS_SAVES_PER_MATCH: "Saves per match",
    GAME_STATS_PASS_ACCURACY: "Pass accuracy",
    GAME_STATS_PASS_PER_MATCH: "Pass per match",
    GAME_STATS_GOALKEEPER: "Goalkeeper",
    GAME_STATS_PLAYED_GK: "Games played as goalkeeper",
    GAME_STATS_CS: "Clean sheets",
    GAME_STATS_CS_PERCENTAGE: "Clean sheets percentage",
    GAME_STATS_BADGES: "Badges unlocked",
    // GAME_LEADERBOARD
    GAME_LEADERBOARD: "Leaderboard",
    GAME_LEADERBOARD_FILTER: "Filter by",
    // GAME_FRIENDS
    GAME_FRIENDS: "Friends",
    GAME_FRIENDS_NONE: "Your friends list is empty.",
    // GAME_SHOP
    GAME_SHOP: "Shop",
    GAME_SHOP_CATEGORY_FLAGS: "Flags",
    GAME_SHOP_EQUIP: "Equip",
    GAME_SHOP_EQUIPED: "Equiped",
    // GAME_SANCTION
    GAME_SANCTION_MUTE: "{0} has been muted for {1} hour(s).",
    GAME_SANCTION_BAN: "{0} has been banned for {1} hour(s).",
    // GAME_ADMIN
    GAME_ADMIN: "Admin panel",
    GAME_ADMIN_TEAM: "Team",
    GAME_ADMIN_REPORTS: "Reports",
    GAME_ADMIN_SANCTION_MUTE: "Mute",
    GAME_ADMIN_SANCTION_BAN: "Ban",
    GAME_ADMIN_SANCTION_TIME: "Duration in hours",
    GAME_ADMIN_SANCTION_REASON: "Reason",
    GAME_ADMIN_SANCTIONS: "Sanctions",
    GAME_ADMIN_NEW_SANCTION: "New sanction",
    GAME_ADMIN_RANK: "Ranks",
    GAME_ADMIN_CHATLOGS: "Chat logs",
    GAME_ADMIN_ERROR_USERNAME: "This player does not exist.",
    GAME_ADMIN_ERROR_RANK: "{0} has already {1} rank.",
    GAME_ADMIN_SUCCESS_RANK: "{0} is now {1}.",
    GAME_ADMIN_ERROR_RANK_PERMS: "You can't change {0} rank.",
    GAME_ADMIN_ERROR_SANCTION_PERMS: "You can't sanctionate {0}.",
    GAME_ADMIN_ERROR_SANCTION_ALREADY_MUTED: "{0} is already muted.",
    GAME_ADMIN_ERROR_SANCTION_ALREADY_BAN: "{0} is already banned.",
    GAME_ADMIN_ERROR_SANCTION_DURATION: "The duration is invalid.",
    // GAME_RANK
    GAME_RANK_OWNER: "Owner",
    GAME_RANK_MANAGER: "Manager",
    GAME_RANK_ADMIN: "Admin",
    GAME_RANK_MOD: "Moderator",
    GAME_RANK_VIP: "VIP",
    GAME_RANK_USER: "User",
    // GAME_ELO
    GAME_ELO_IRON: "Iron",
    GAME_ELO_SILVER: "Silver",
    GAME_ELO_GOLD: "Gold",
    GAME_ELO_PLATINIUM: "Platinium",
    GAME_ELO_DIAMOND: "Diamond",
    GAME_ELO_CHAMPION: "Champion",
    GAME_ELO_CHALLENGER: "Challenger",
    // HISTORY
    HISTORY_MATCH_STARTED: "Match started",
    HISTORY_SHOT: "Shot by <span class='{0}'>{1}</span>",
    HISTORY_SAVE: "Save by <span class='{0}'>{1}</span>",
    HISTORY_GOAL: "Goal by <span class='{0}'>{1}</span>",
    HISTORY_GOAL_ASSISTED: "Goal by <span class='{0}'>{1}</span> assisted by <span class='{0}'>{2}</span>",
    HISTORY_OWN_GOAL: "Own goal by <span class='{0}'>{1}</span>",
    HISTORY_END_RED: "Red team won the game  {0} - {1} , possession  {2}% - {3}% ",
    HISTORY_END_BLUE: "Blue team won the game  {0} - {1} , possession  {2}% - {3}% ",
    // COPYRIGHT
    COPYRIGHT: " {0}, developed with  by OvB."
};


/***/ }),

/***/ "./client/Language/List/FR.ts":
/*!************************************!*\
  !*** ./client/Language/List/FR.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FR = void 0;
exports.FR = {
    CODE: "FR",
    // LOADING
    LOADING_MESSAGE: "Initialisation de {0}...",
    LOADING_RESOURCES: "Chargement des ressources...",
    LOADING_CONNECTION_TO_MAIN_SERVER: "Connexion au serveur principal...",
    LOADING_FETCHING_REGION_SERVERS: "Rcupration des serveurs de rgion...",
    // GENERIC_ERROR
    GENERIC_ERROR_CONNECTION_LOST: "Connexion au serveur perdue.",
    GENERIC_ERROR_SERVERS: "Une erreur s'est produite avec les serveurs.",
    GENERIC_ERROR_NO_SERVER_AVAILABLE: "Il n'y a aucun serveur disponible.",
    // ACCOUNT
    ACCOUNT_LANGUAGE: "Langage",
    ACCOUNT_LOGIN: "Connexion",
    ACCOUNT_REGISTER: "Inscription",
    ACCOUNT_USERNAME: "Pseudonyme",
    ACCOUNT_PASSWORD: "Mot de passe",
    ACCOUNT_CONFIRM_PASSWORD: "Confirmez votre mot de passe",
    ACCOUNT_SERVER: "Serveur [{0}] - Ping: {1}ms",
    // ACCOUNT_ERROR
    ACCOUNT_ERROR_OCCURED: "Une erreur est survenue, veuillez recharger la page.",
    ACCOUNT_ERROR_FIELDS: "Merci de complter tous les champs.",
    ACCOUNT_ERROR_ALREADY_LOGGED: "Vous tes dj connect.",
    ACCOUNT_ERROR_INVALID: "Pseuonyme ou mot de passe invalide.",
    ACCOUNT_ERROR_USERNAME_LENGTH: "Votre pseudonyme doit faire entre 3 et 15 caractres.",
    ACCOUNT_ERROR_USERNAME_ALPHANUMERIC: "Votre pseudonyme doit tre alphanumrique.",
    ACCOUNT_ERROR_PASSWORD_LENGTH: "Votre mot de passe doit faire 6 caractres minimum.",
    ACCOUNT_ERROR_PASSWORDS_DIFFERENT: "Vos deux mots de passe sont diffrents.",
    ACCOUNT_INVALID_SERVER: "Le serveur slectionn n'est pas disponible.",
    // COPYRIGHT
    COPYRIGHT: " {0}, dvelopp avec  par OvB."
};


/***/ }),

/***/ "./client/Ressource/ResourceManager.ts":
/*!*********************************************!*\
  !*** ./client/Ressource/ResourceManager.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Resources_1 = __webpack_require__(/*! ../Config/Resources */ "./client/Config/Resources.ts");
const main_1 = __importDefault(__webpack_require__(/*! ../main */ "./client/main.ts"));
class ResourceManager {
    constructor() {
        this.resources = {};
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                main_1.default.logger.sendLog("INFO", "Initiliazing resources...");
                main_1.default.sceneManager.initScene(0 /* SceneList.MessageScene */, {
                    message: main_1.default.languageManager.getValueForKey('LOADING_RESOURCES')
                });
                const listOfPromise = [];
                for (let i in Resources_1.Resources) {
                    listOfPromise.push(this.loadResource(i, Resources_1.Resources[i]));
                }
                Promise.all(listOfPromise).then(() => {
                    resolve("All resources have been loaded.");
                }).catch((e) => reject(e.toString()));
            });
        });
    }
    loadResource(key, fileName) {
        const instance = this;
        return new Promise((resolve, reject) => {
            if (fileName.endsWith(".png") || fileName.endsWith(".jpg") || fileName.endsWith(".svg")) {
                const image = new Image();
                image.onload = function () {
                    instance.resources[`IMAGE_${key}`] = image;
                    resolve(`Image ${key} loaded.`);
                };
                image.onerror = function () {
                    reject(`Impossible to load image ${key}.`);
                };
                image.src = `assets/images/resources/${fileName}`;
            }
            else if (fileName.endsWith(".mp3") || fileName.endsWith(".wav")) {
                const audio = new Audio(`assets/audio/${fileName}`);
                audio.onloadeddata = function () {
                    instance.resources[`AUDIO_${key}`] = audio;
                    resolve(`Audio ${key} loaded.`);
                };
                audio.onerror = function () {
                    reject(`Impossible to load audio ${key}.`);
                };
            }
        });
    }
}
exports["default"] = ResourceManager;


/***/ }),

/***/ "./client/Room/Room.ts":
/*!*****************************!*\
  !*** ./client/Room/Room.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ShareableData_1 = __importDefault(__webpack_require__(/*! ../../shared/ShareableData/ShareableData */ "./shared/ShareableData/ShareableData.ts"));
class Room {
    constructor(data) {
        this.id = data.id;
        this.currentPlayers = data.currentPlayers;
        this.state = data.state;
        this.score = data.score;
        this.stadium = data.stadium;
        this.pickMode = data.pickMode;
        this.history = data.history;
        this.discHistory = {};
    }
    reorderPlayer(playersArray) {
        this.currentPlayers = playersArray;
    }
    getPlayer(playerId) {
        const player = this.currentPlayers.filter((player) => player.id == playerId)[0];
        if (player != null)
            return player;
        else
            return null;
    }
    playerJoin(player) {
        const playerData = this.getPlayer(player.id);
        if (playerData != null)
            return;
        this.currentPlayers.push(player);
    }
    playerLeave(playerId) {
        const playerData = this.getPlayer(playerId);
        if (playerData == null)
            return;
        this.currentPlayers = this.currentPlayers.filter(function (player) {
            return player.id != playerId;
        });
    }
    update(data) {
        this.currentPlayers = data.currentPlayers;
        this.state = data.state;
        this.score = data.score;
        this.stadium.discs = data.discs;
        for (let i in this.stadium.discs) {
            if (this.discHistory[i] == null)
                this.discHistory[i] = [];
            this.discHistory[i].push(new ShareableData_1.default(performance.now(), { x: this.stadium.discs[i].x, y: this.stadium.discs[i].y }));
        }
    }
}
exports["default"] = Room;


/***/ }),

/***/ "./client/Scene/List/GameScene.ts":
/*!****************************************!*\
  !*** ./client/Scene/List/GameScene.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Base_1 = __webpack_require__(/*! ../../../shared/Base/Base */ "./shared/Base/Base.ts");
const Color_1 = __importDefault(__webpack_require__(/*! ../../../shared/Color/Color */ "./shared/Color/Color.ts"));
const Elo_1 = __webpack_require__(/*! ../../../shared/Elo/Elo */ "./shared/Elo/Elo.ts");
const Level_1 = __webpack_require__(/*! ../../../shared/Level/Level */ "./shared/Level/Level.ts");
const RoomState_1 = __webpack_require__(/*! ../../../shared/RoomState/RoomState */ "./shared/RoomState/RoomState.ts");
const Team_1 = __importDefault(__webpack_require__(/*! ../../../shared/Team/Team */ "./shared/Team/Team.ts"));
const main_1 = __importDefault(__webpack_require__(/*! ../../main */ "./client/main.ts"));
const Scene_1 = __importDefault(__webpack_require__(/*! ../Scene */ "./client/Scene/Scene.ts"));
class GameScene extends Scene_1.default {
    constructor(state) {
        super(state.name);
        this.state = {
            currentUser: state.params.currentUser,
            canvas: null,
            ctx: null,
            zIndex: 0,
            fps: 0,
            canvas_rect: [-150, -75, 150, 75],
            cameraFollow: { x: 0, y: 0 },
            unpauseInterval: 0,
            inputs: {
                left: false,
                right: false,
                up: false,
                down: false,
                kick: false
            },
            lastChangeFps: null,
            settings_category: "graphics",
            settings_record_input: null,
            focusUser: null
        };
    }
    setFps(val) {
        const fps = document.getElementById("fps");
        if (fps == null)
            return;
        const now = window.performance.now();
        this.state.fps = val;
        if (this.state.lastChangeFps != null && this.state.lastChangeFps + 1000 > now)
            return;
        this.state.lastChangeFps = now;
        fps.textContent = val.toString();
    }
    setState(params) {
        super.setState(params);
        for (let i in params) {
            this.state[i] = params[i];
        }
        this.render();
    }
    onWillInit() {
        super.onWillInit();
    }
    onInitialized() {
        super.onInitialized();
        this.state.canvas = document.getElementById("game");
        this.state.ctx = this.state.canvas.getContext("2d");
        Array.from(document.querySelectorAll('#settings .menu li')).forEach((element) => {
            element.addEventListener("click", this.setSettingsCategory.bind(this));
        });
        Array.from(document.querySelectorAll('#admin_menu li')).forEach((element) => {
            element.addEventListener("click", this.setAdminCategory.bind(this));
        });
        Array.from(document.querySelectorAll('#settings input, #settings select')).forEach((element) => {
            element.addEventListener("change", this.setSettings.bind(this));
        });
        const leaderboardFilter = document.getElementById("leaderboardFilter");
        if (leaderboardFilter != null)
            leaderboardFilter.addEventListener("change", this.requestLeaderboard.bind(this));
        const requestProfile = document.getElementById("request_profile");
        if (requestProfile != null)
            requestProfile.addEventListener("click", this.switchProfile.bind(this));
        Array.from(document.getElementsByClassName("general_menu")).forEach((el) => {
            Array.from(el.getElementsByTagName("div")).forEach((element) => {
                element.addEventListener("click", this.switchMenu.bind(this));
            });
        });
        Array.from(document.getElementsByClassName("pick_list_team")).forEach((el) => {
            el.addEventListener("dragover", (e) => e.preventDefault());
            el.addEventListener("drop", this.drop.bind(this));
        });
        const user_menu = document.getElementById("user_menu");
        if (user_menu != null) {
            const li = user_menu.getElementsByTagName("li");
            Array.from(li).forEach((element) => {
                element.addEventListener("click", this.userMenuItem.bind(this));
            });
        }
        Array.from(document.getElementsByClassName("close")).forEach((el) => {
            el.addEventListener("click", () => {
                if (el.parentNode != null && el.parentNode.parentNode != null && el.parentNode.parentNode.parentElement != null)
                    el.parentNode.parentNode.parentNode.style.display = "none";
            });
        });
        document.addEventListener('keydown', this.keyDownHandler.bind(this), false);
        document.addEventListener('keyup', this.KeyUpHandler.bind(this), false);
        const chatForm = document.getElementById("chatForm");
        chatForm === null || chatForm === void 0 ? void 0 : chatForm.addEventListener("submit", this.sendChat.bind(this));
        this.renderMenu();
    }
    renderMenu() {
        Array.from(document.getElementsByClassName("general_menu")).forEach((el) => {
            Array.from(el.getElementsByTagName("div")).forEach((element) => {
                if (element.getAttribute("type") == "admin" && ["user", "vip"].includes(main_1.default.currentUser.rank))
                    element.style.display = "none";
                else
                    element.style.display = "block";
            });
        });
    }
    profileData(data) {
        const profile = document.getElementById("profile");
        if (profile == null)
            return;
        Array.from(profile.querySelectorAll("img, span")).forEach((el) => {
            const profile_data = el.getAttribute("profile_data");
            if (profile_data == null)
                return;
            if (profile_data == "username") {
                el.removeAttribute("class");
                el.classList.add(data.rank);
            }
            if (profile_data == "avatar")
                el.setAttribute("src", main_1.default.resourceManager.resources["IMAGE_AVATAR_" + data.avatar].src);
            if (profile_data == "online") {
                if (data.online)
                    el.classList.add("online");
                else
                    el.classList.remove("online");
            }
            else if (data[profile_data] != null)
                el.textContent = data[profile_data];
            else if (data.stats[profile_data] != null) {
                if (profile_data == "elo")
                    el.textContent = `${main_1.default.languageManager.getValueForKey((0, Elo_1.getElo)(data.stats.elo).name)} ${(0, Elo_1.getElo)(data.stats.elo).value} (${data.stats.elo})`;
                else if (profile_data == "level_xp") {
                    el.textContent = (0, Level_1.getLevel)(data.stats.level_xp).toString();
                }
                else {
                    el.textContent = data.stats[profile_data];
                    ["win_rate", "pass_accuracy", "cs_percentage"].includes(profile_data) ? el.textContent += "%" : null;
                }
            }
        });
        this.state.zIndex++;
        profile.style.zIndex = this.state.zIndex;
        profile.style.display = "block";
    }
    switchMenu(e) {
        this.state.zIndex++;
        switch (e.srcElement.getAttribute("type")) {
            case "shop": {
                this.switchShop();
                break;
            }
            case "friends": {
                this.switchFriends();
                break;
            }
            case "settings": {
                this.switchSettings();
                break;
            }
            case "menu": {
                this.switcMenu();
                break;
            }
            case "leaderboard": {
                this.switchLeaderboard();
                break;
            }
            case "admin": {
                this.switchAdmin();
                break;
            }
            case "team": {
                this.newChat({ type: "announcement", message: "GAME_GENERAL_NOT_AVAILABLE", color: Color_1.default.ROOM_ANNOUNCEMENT, sound: 1, officialTrad: true });
                break;
            }
        }
    }
    setSettings(e) {
        if (e.srcElement.checked != null)
            return main_1.default.settingsManager.setSettings(e.srcElement.getAttribute("settings_category"), e.srcElement.getAttribute("settings_val"), e.srcElement.checked);
        main_1.default.settingsManager.setSettings(e.srcElement.getAttribute("settings_category"), e.srcElement.getAttribute("settings_val"), e.srcElement.value);
    }
    setSettingsCategory(e) {
        this.state.settings_category = e.srcElement.getAttribute("category");
        Array.from(document.querySelectorAll('#settings .menu li')).forEach((element) => {
            if (element.getAttribute("category") == this.state.settings_category && !element.classList.contains("selected"))
                element.classList.add("selected");
            else
                element.classList.remove("selected");
        });
        this.reloadSettings();
    }
    removeKey(type, key) {
        main_1.default.settingsManager.removeKey(type, key);
        this.reloadSettings();
    }
    addHistory(data) {
        const history = document.getElementById("history");
        if (history == null)
            return;
        const div = document.createElement("div");
        div.classList.add("row");
        const icon = document.createElement("img");
        div.appendChild(icon);
        const info = document.createElement("div");
        const time = document.createElement("span");
        time.classList.add("time");
        time.textContent = this.fmtMSS(Math.floor(data.value.time));
        info.appendChild(time);
        const message = document.createElement("div");
        info.appendChild(message);
        div.appendChild(info);
        switch (data.key) {
            case "matchStarted": {
                history.innerHTML = "";
                icon.src = "assets/images/icons/whistle.png";
                message.textContent = main_1.default.languageManager.getValueForKey("HISTORY_MATCH_STARTED");
                break;
            }
            case "shot": {
                icon.src = "assets/images/icons/shot.png";
                message.innerHTML = main_1.default.languageManager.getValueForKey("HISTORY_SHOT", [data.value.team.name, data.value.username]);
                break;
            }
            case "save": {
                icon.src = "assets/images/icons/save.png";
                message.innerHTML = main_1.default.languageManager.getValueForKey("HISTORY_SAVE", [data.value.team.name, data.value.username]);
                break;
            }
            case "goal": {
                icon.src = "assets/images/icons/ball.png";
                const notif = document.getElementById("notif");
                if (notif != null) {
                    if (data.value.team.id != data.value.score_team.id)
                        notif.innerHTML = `${main_1.default.languageManager.getValueForKey("GAME_GENERAL_OWN_GOAL", [data.value.team.name, data.value.username])}`;
                    else
                        notif.innerHTML = `${main_1.default.languageManager.getValueForKey("GAME_GENERAL_GOAL", [data.value.team.name, data.value.username])}`;
                }
                if (data.value.team.id != data.value.score_team.id)
                    message.innerHTML = main_1.default.languageManager.getValueForKey("HISTORY_OWN_GOAL", [data.value.team.name, data.value.username]);
                else if (data.value.assist_id != null)
                    message.innerHTML = main_1.default.languageManager.getValueForKey("HISTORY_GOAL_ASSISTED", [data.value.team.name, data.value.username, data.value.assist_username]);
                else
                    message.innerHTML = main_1.default.languageManager.getValueForKey("HISTORY_GOAL", [data.value.team.name, data.value.username]);
                break;
            }
            case "endGame": {
                icon.src = "assets/images/icons/whistle.png";
                if (data.value.score.red > data.value.score.blue)
                    message.innerHTML = main_1.default.languageManager.getValueForKey("HISTORY_END_RED", [data.value.score.red, data.value.score.blue, data.value.possession.red, data.value.possession.blue]);
                else
                    message.innerHTML = main_1.default.languageManager.getValueForKey("HISTORY_END_BLUE", [data.value.score.red, data.value.score.blue, data.value.possession.red, data.value.possession.blue]);
                break;
            }
        }
        history.prepend(div);
    }
    recordKey(type) {
        const recordKey = document.getElementById("recordKey");
        if (recordKey == null)
            return;
        this.state.settings_record_input = type;
        this.state.inputs.up = false;
        this.state.inputs.down = false;
        this.state.inputs.left = false;
        this.state.inputs.right = false;
        this.state.inputs.kick = false;
        recordKey.style.display = "flex";
    }
    reloadSettings() {
        const settings = document.getElementById("settings"), recordKey = document.getElementById("recordKey");
        if (settings == null)
            return;
        if (recordKey != null)
            recordKey.style.display = "none";
        Array.from(settings.getElementsByClassName("category")).forEach((category) => {
            const category_name = category.getAttribute("category_name");
            if (category_name != null) {
                if (category_name == this.state.settings_category)
                    category.style.display = "block";
                else
                    category.style.display = "none";
            }
            Array.from(category.querySelectorAll("input, select, .inputs_value")).forEach((element) => {
                const settings_category = element.getAttribute("settings_category"), settings_val = element.getAttribute("settings_val");
                if (settings_category != null && settings_val != null) {
                    switch (settings_category) {
                        case "graphics": {
                            if (main_1.default.settingsManager.graphics[settings_val] != null) {
                                if (element.checked != null)
                                    element.checked = main_1.default.settingsManager.graphics[settings_val];
                                else
                                    element.value = main_1.default.settingsManager.graphics[settings_val];
                            }
                            break;
                        }
                        case "audio": {
                            if (main_1.default.settingsManager.audio[settings_val] != null) {
                                if (element.checked != null)
                                    element.checked = main_1.default.settingsManager.audio[settings_val];
                                else
                                    element.value = main_1.default.settingsManager.audio[settings_val];
                            }
                            break;
                        }
                        case "inputs": {
                            element.innerHTML = "";
                            if (main_1.default.settingsManager.inputs[settings_val] == null)
                                return;
                            main_1.default.settingsManager.inputs[settings_val].forEach((key) => {
                                const inputElement = document.createElement("div");
                                inputElement.classList.add("gameInput");
                                inputElement.textContent = key.toString().replace("Key", "");
                                const deleteInput = document.createElement("img");
                                deleteInput.src = "assets/images/icons/cross.svg";
                                deleteInput.addEventListener("click", () => this.removeKey(settings_val, key));
                                inputElement.appendChild(deleteInput);
                                element.appendChild(inputElement);
                            });
                            const inputElement = document.createElement("div");
                            inputElement.classList.add("gameInput");
                            const addInput = document.createElement("img");
                            addInput.classList.add("add");
                            addInput.src = "assets/images/icons/add.svg";
                            addInput.addEventListener("click", () => this.recordKey(settings_val));
                            inputElement.appendChild(addInput);
                            element.appendChild(inputElement);
                            break;
                        }
                    }
                }
            });
        });
    }
    switchProfile() {
        if (main_1.default.currentUser == null)
            return;
        const profile = document.getElementById("profile");
        if (profile == null)
            return;
        if (profile.style.display == "block") {
            profile.style.display = "none";
            return;
        }
        main_1.default.webSocketsManager.sendMsg("requestProfile", main_1.default.currentUser.username);
    }
    requestLeaderboard(e) {
        this.fetchLeaderboard(e.srcElement.value);
    }
    fetchLeaderboard(key) {
        const leaderboardContent = document.getElementById("leaderboardContent");
        if (leaderboardContent == null)
            return;
        leaderboardContent.innerHTML = `<div class="loader"></div>`;
        main_1.default.webSocketsManager.sendMsg("fetchLeaderboard", key);
    }
    setLeaderboardData(data) {
        const leaderboardContent = document.getElementById("leaderboardContent");
        if (leaderboardContent == null)
            return;
        leaderboardContent.innerHTML = ``;
        data.players.forEach((player, index) => {
            const div = document.createElement("div");
            div.classList.add("row");
            const avatar = document.createElement("img");
            avatar.src = main_1.default.resourceManager.resources["IMAGE_AVATAR_" + player.avatar].src;
            div.appendChild(avatar);
            const username = document.createElement("div");
            username.classList.add("username");
            username.textContent = player.username;
            div.appendChild(username);
            const rank = document.createElement("div");
            rank.classList.add("rank");
            rank.textContent = "#" + (index + 1).toString();
            div.appendChild(rank);
            const value = document.createElement("div");
            value.classList.add("value");
            if (["win_rate", "pass_accuracy", "cs_percentage"].includes(data.key))
                value.textContent = player.value + "%";
            else if (data.key == "level_xp")
                value.textContent = (0, Level_1.getLevel)(player.value).toString();
            else if (data.key == "elo")
                value.textContent = `${main_1.default.languageManager.getValueForKey((0, Elo_1.getElo)(player.value).name)} ${(0, Elo_1.getElo)(player.value).value} (${player.value})`;
            else
                value.textContent = player.value;
            div.appendChild(value);
            leaderboardContent.appendChild(div);
        });
    }
    hideMenu() {
        if (main_1.default.currentUser.currentRoom.state != RoomState_1.RoomState.KICK_OFF_RESET) {
            setTimeout(this.hideMenu.bind(this), 10);
            return;
        }
        const pick_list = document.getElementById("pick_list");
        if (pick_list == null)
            return;
        if (pick_list.style.display == "none")
            return;
        pick_list.style.display = "none";
    }
    showMenu() {
        const pick_list = document.getElementById("pick_list");
        if (pick_list == null)
            return;
        if (pick_list.style.display == "block")
            return;
        pick_list.style.display = "block";
    }
    switcMenu() {
        const pick_list = document.getElementById("pick_list");
        if (main_1.default.currentUser.currentRoom.state == RoomState_1.RoomState.GAME_ENDED || pick_list == null)
            return;
        if (pick_list.style.display == "block") {
            pick_list.style.display = "none";
            return;
        }
        pick_list.style.zIndex = this.state.zIndex;
        pick_list.style.display = "block";
    }
    renderAdmin(data) {
        const adminContent = document.getElementById("admin_content");
        if (adminContent == null)
            return;
        switch (data.category) {
            case "team": {
                adminContent.innerHTML = "";
                data.team.forEach((user) => {
                    const element = document.createElement("div");
                    element.classList.add("row");
                    const avatar = document.createElement("img");
                    avatar.src = main_1.default.resourceManager.resources["IMAGE_AVATAR_" + user.avatar].src;
                    avatar.classList.add("avatar");
                    element.appendChild(avatar);
                    const username = document.createElement("div");
                    username.classList.add("username");
                    username.textContent = user.username;
                    element.appendChild(username);
                    const rank = document.createElement("div");
                    rank.classList.add("value");
                    rank.classList.add(user.rank);
                    rank.textContent = main_1.default.languageManager.getValueForKey(`GAME_RANK_${user.rank.toUpperCase()}`);
                    element.appendChild(rank);
                    adminContent.appendChild(element);
                });
                break;
            }
            case "reports": {
                adminContent.innerHTML = `<div class="row info"><div style="width: 30%">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_PLAYER")}</div><div style="width: 30%"">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_BY_PLAYER")}</div><div style="width: 30%">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_DATE")}</div><div class="value">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_ACTION")}</div></div>`;
                data.reports.forEach((report) => {
                    const element = document.createElement("div");
                    element.classList.add("row");
                    const username = document.createElement("div");
                    username.style.width = "30%";
                    username.textContent = report.username;
                    element.appendChild(username);
                    const reported_username = document.createElement("div");
                    reported_username.style.width = "30%";
                    reported_username.textContent = report.reported_username;
                    element.appendChild(reported_username);
                    const date = document.createElement("div");
                    date.style.width = "30%";
                    date.textContent = report.date;
                    element.appendChild(date);
                    const action = document.createElement("div");
                    action.classList.add("value");
                    const chatLog = document.createElement("img");
                    chatLog.classList.add("icon");
                    chatLog.src = "assets/images/icons/chat.svg";
                    action.appendChild(chatLog);
                    chatLog.addEventListener("click", () => {
                        this.fetchAdminCategory("chatlogs", report.reported_username);
                    });
                    const deleteCross = document.createElement("img");
                    deleteCross.classList.add("icon");
                    deleteCross.src = "assets/images/icons/cross.svg";
                    action.appendChild(deleteCross);
                    deleteCross.addEventListener("click", () => {
                        main_1.default.webSocketsManager.sendMsg("deleteReport", report.id);
                    });
                    element.appendChild(action);
                    adminContent.appendChild(element);
                });
                break;
            }
            case "sanctions": {
                adminContent.innerHTML = `<div class="row info"><div style="width: 25%">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_PLAYER")}</div><div style="width: 25%"">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_BY_PLAYER")}</div><div style="width: 10%">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_TYPE")}</div><div style="width: 30%">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_EXPIRE")}</div><div class="value">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_ACTION")}</div></div>`;
                data.sanctions.forEach((sanction) => {
                    const element = document.createElement("div");
                    element.classList.add("row");
                    const username = document.createElement("div");
                    username.style.width = "25%";
                    username.textContent = sanction.username;
                    element.appendChild(username);
                    const by_username = document.createElement("div");
                    by_username.style.width = "25%";
                    by_username.textContent = sanction.by_player;
                    element.appendChild(by_username);
                    const type = document.createElement("div");
                    type.style.width = "10%";
                    type.textContent = main_1.default.languageManager.getValueForKey(`GAME_ADMIN_SANCTION_${sanction.type.toUpperCase()}`);
                    element.appendChild(type);
                    const date = document.createElement("div");
                    date.style.width = "30%";
                    date.textContent = sanction.end_date;
                    element.appendChild(date);
                    const action = document.createElement("div");
                    action.classList.add("value");
                    const chatLog = document.createElement("img");
                    chatLog.classList.add("icon");
                    chatLog.src = "assets/images/icons/chat.svg";
                    action.appendChild(chatLog);
                    chatLog.addEventListener("click", () => {
                        this.fetchAdminCategory("chatlogs", sanction.username);
                    });
                    const deleteCross = document.createElement("img");
                    deleteCross.classList.add("icon");
                    deleteCross.src = "assets/images/icons/cross.svg";
                    action.appendChild(deleteCross);
                    deleteCross.addEventListener("click", () => {
                        main_1.default.webSocketsManager.sendMsg("deleteSanction", sanction.id);
                    });
                    element.appendChild(action);
                    adminContent.appendChild(element);
                });
                break;
            }
            case "chatlogs": {
                adminContent.innerHTML = ``;
                data.logs.forEach((log) => {
                    const element = document.createElement("div");
                    element.classList.add("row");
                    const message = document.createElement("div");
                    message.textContent = log;
                    element.appendChild(message);
                    adminContent.appendChild(element);
                });
                break;
            }
        }
    }
    renderAdminAlert(data) {
        const admin_alert = document.getElementById("admin_alert");
        if (admin_alert == null)
            return;
        if (data.error)
            admin_alert.classList.add("error");
        else
            admin_alert.classList.remove("error");
        admin_alert.textContent = main_1.default.languageManager.getValueForKey(data.message, data.args);
        admin_alert.style.display = "block";
    }
    setRank(e) {
        e.preventDefault();
        const username = document.getElementById("rankUsername"), rank = document.getElementById("rankValue");
        main_1.default.webSocketsManager.sendMsg("adminRank", { username: username.value, rank: rank.value });
    }
    newSanction(e) {
        e.preventDefault();
        const username = document.getElementById("sanctionUsername"), type = document.getElementById("sanctionType"), time = document.getElementById("sanctionTime"), reason = document.getElementById("sanctionReason");
        main_1.default.webSocketsManager.sendMsg("adminSanction", { username: username.value, type: type.value, time: time.value, reason: reason.value });
    }
    fetchAdminCategory(type, args) {
        const adminTitle = document.getElementById("admin_title"), adminContent = document.getElementById("admin_content");
        if (adminTitle == null || adminContent == null)
            return;
        adminTitle.innerText = main_1.default.languageManager.getValueForKey(`GAME_ADMIN_${type.toUpperCase()}`);
        adminContent.innerHTML = `<div class="loader"></div>`;
        switch (type) {
            case "team": {
                main_1.default.webSocketsManager.sendMsg("fetchAdmin", { key: "team" });
                break;
            }
            case "reports": {
                main_1.default.webSocketsManager.sendMsg("fetchAdmin", { key: "reports" });
                break;
            }
            case "chatlogs": {
                main_1.default.webSocketsManager.sendMsg("fetchAdmin", { key: "chatlogs", username: args });
                break;
            }
            case "sanctions": {
                main_1.default.webSocketsManager.sendMsg("fetchAdmin", { key: "sanctions" });
                break;
            }
            case "new_sanction": {
                adminContent.innerHTML = `<div id="admin_alert"></div><form id="adminSanctionForm"><input type="text" id="sanctionUsername" placeholder="${main_1.default.languageManager.getValueForKey("ACCOUNT_USERNAME")}"/><select id="sanctionType"><option value="mute">${main_1.default.languageManager.getValueForKey("GAME_ADMIN_SANCTION_MUTE")}</option><option value="ban">${main_1.default.languageManager.getValueForKey("GAME_ADMIN_SANCTION_BAN")}</option></select><input type="text" id="sanctionTime" placeholder="${main_1.default.languageManager.getValueForKey("GAME_ADMIN_SANCTION_TIME")}"/><input type="text" id="sanctionReason" placeholder="${main_1.default.languageManager.getValueForKey("GAME_ADMIN_SANCTION_REASON")}" maxlength="150"/><input type="submit" value="${main_1.default.languageManager.getValueForKey("GAME_GENERAL_VALIDATE")}"></form>`;
                if (args != null && args.username != null) {
                    const usernameInput = document.getElementById("sanctionUsername");
                    if (usernameInput != null)
                        usernameInput.value = args.username;
                }
                if (args != null && args.type != null) {
                    const typeSelect = document.getElementById("sanctionType");
                    if (typeSelect != null)
                        typeSelect.value = args.type;
                }
                const form = document.getElementById("adminSanctionForm");
                if (form != null)
                    form.addEventListener("submit", this.newSanction);
                break;
            }
            case "rank": {
                adminContent.innerHTML = `<div id="admin_alert"></div><form id="adminRankForm"><input type="text" id="rankUsername" placeholder="${main_1.default.languageManager.getValueForKey("ACCOUNT_USERNAME")}"/><select id="rankValue"></select><input type="submit" value="${main_1.default.languageManager.getValueForKey("GAME_GENERAL_VALIDATE")}"></form>`;
                const rankValue = document.getElementById("rankValue");
                ["owner", "manager", "admin", "mod", "vip", "user"].forEach((rank) => {
                    const option = document.createElement("option");
                    option.value = rank;
                    option.textContent = main_1.default.languageManager.getValueForKey(`GAME_RANK_${rank.toUpperCase()}`);
                    rankValue === null || rankValue === void 0 ? void 0 : rankValue.appendChild(option);
                });
                const form = document.getElementById("adminRankForm");
                if (form != null)
                    form.addEventListener("submit", this.setRank);
                break;
            }
        }
    }
    setAdminCategory(e) {
        this.switchAdmin(e.srcElement.getAttribute("type"));
    }
    switchAdmin(type = null, args = null) {
        if (main_1.default.currentUser == null || ["user", "vip"].includes(main_1.default.currentUser.rank))
            return;
        const admin = document.getElementById("admin"), admin_menu = document.getElementById("admin_menu");
        if (admin == null || admin_menu == null)
            return;
        if (!type && admin.style.display == "block") {
            admin.style.display = "none";
            return;
        }
        if (type == null)
            type = "team";
        Array.from(admin_menu.getElementsByTagName("li")).forEach((el) => {
            if (el.getAttribute("type") == "rank" && !["owner", "manager"].includes(main_1.default.currentUser.rank))
                el.style.display = "none";
            if (el.getAttribute("type") == type)
                el.classList.add("active");
            else
                el.classList.remove("active");
        });
        this.fetchAdminCategory(type, args);
        admin.style.zIndex = this.state.zIndex;
        admin.style.display = "block";
    }
    switchLeaderboard() {
        if (main_1.default.currentUser == null)
            return;
        const leaderboard = document.getElementById("leaderboard"), leaderboardFilter = document.getElementById("leaderboardFilter");
        if (leaderboard == null || leaderboardFilter == null)
            return;
        if (leaderboard.style.display == "block") {
            leaderboard.style.display = "none";
            return;
        }
        if (leaderboardFilter.value.length == 0) {
            const availablesStats = ["elo", "level_xp", "games_played", "games_won", "games_lost", "win_rate", "best_streak", "shots", "shots_per_match", "goals", "goals_per_match", "hat_tricks", "assists", "assists_per_match", "saves", "saves_per_match", "pass_accuracy", "pass_per_match", "played_gk", "cs", "cs_percentage"];
            availablesStats.forEach((stat) => {
                const option = document.createElement("option");
                option.value = stat;
                option.textContent = main_1.default.languageManager.getValueForKey(`GAME_STATS_${stat.toUpperCase()}`);
                leaderboardFilter.appendChild(option);
            });
            this.fetchLeaderboard(availablesStats[0]);
        }
        else
            this.fetchLeaderboard(leaderboardFilter.value);
        leaderboard.style.zIndex = this.state.zIndex;
        leaderboard.style.display = "block";
    }
    switchSettings() {
        if (main_1.default.currentUser == null)
            return;
        const settings = document.getElementById("settings");
        if (settings == null)
            return;
        if (settings.style.display == "block") {
            settings.style.display = "none";
            return;
        }
        this.reloadSettings();
        settings.style.zIndex = this.state.zIndex;
        settings.style.display = "block";
    }
    reloadFriends() {
        const friendsList = document.getElementById("friendsList");
        if (main_1.default.currentUser == null || main_1.default.currentUser.friends == null || friendsList == null)
            return;
        friendsList.innerHTML = "";
        let count = 0;
        main_1.default.currentUser.friends.forEach((friend) => {
            var _a;
            count++;
            const div = document.createElement("div");
            div.classList.add("row");
            if (friend.online)
                div.classList.add("online");
            const user = document.createElement("div");
            user.classList.add("user");
            user.innerText = friend.username;
            if (friend.serverRegion != null) {
                const image = document.createElement("img");
                image.src = `assets/images/flags/region/${this.getRegionFlag(friend.serverRegion.region)}.svg`;
                user.prepend(image);
            }
            div.appendChild(user);
            const action = document.createElement("div");
            action.classList.add("action");
            if (friend.online) {
                const whisper = document.createElement("img");
                whisper.src = "assets/images/icons/chat.svg";
                whisper.addEventListener("click", () => this.whisper(friend.username));
                action.appendChild(whisper);
            }
            if (friend.serverRegion != null && friend.serverRegion.region == ((_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.currentServer) && friend.serverRegion.currentRoom != null) {
                const join = document.createElement("img");
                join.setAttribute("room", friend.serverRegion.currentRoom);
                join.src = "assets/images/icons/chev_right.svg";
                action.appendChild(join);
            }
            const deleteFriend = document.createElement("img");
            deleteFriend.src = "assets/images/icons/cross.svg";
            deleteFriend.addEventListener("click", () => main_1.default.webSocketsManager.sendMsg("deleteFriend", friend.id));
            action.appendChild(deleteFriend);
            div.appendChild(action);
            friendsList.appendChild(div);
        });
        if (count == 0)
            friendsList.innerText = main_1.default.languageManager.getValueForKey("GAME_FRIENDS_NONE");
    }
    switchFriends() {
        if (main_1.default.currentUser == null)
            return;
        const friends = document.getElementById("friends");
        if (friends == null)
            return;
        if (friends.style.display == "block") {
            friends.style.display = "none";
            return;
        }
        this.reloadFriends();
        friends.style.zIndex = this.state.zIndex;
        friends.style.display = "block";
    }
    switchShop() {
        const shop = document.getElementById("shop");
        if (shop == null)
            return;
        if (shop.style.display == "block") {
            shop.style.display = "none";
            return;
        }
        shop.style.zIndex = this.state.zIndex;
        main_1.default.webSocketsManager.sendMsg("fetchShop");
    }
    fetchItemForCategory(e) {
        main_1.default.webSocketsManager.sendMsg("fetchItems", e.srcElement.value);
        const shopItems = document.getElementById("shopItems");
        if (shopItems == null)
            return;
        shopItems.innerHTML = "";
    }
    shopData(shopData) {
        const shop = document.getElementById("shop"), shopCoinVal = document.getElementById("shopCoinVal"), shopCategorys = document.getElementById("shopCategorys");
        if (shop == null || shopCoinVal == null || shopCategorys == null)
            return;
        if (main_1.default.currentUser != null)
            shopCoinVal.textContent = main_1.default.currentUser.coins.toString();
        shopCategorys.innerHTML = "";
        shopData.categorys.forEach((category, index) => {
            const div = document.createElement("div");
            const input = document.createElement("input");
            input.type = "radio";
            input.name = "SHOP_CATEGORY";
            input.id = category.name;
            input.value = category.name;
            input.addEventListener("click", this.fetchItemForCategory.bind(this));
            if (index == 0)
                input.checked = true;
            div.appendChild(input);
            const label = document.createElement("label");
            label.setAttribute("for", category.name);
            label.textContent = main_1.default.languageManager.getValueForKey("GAME_" + category.name);
            div.appendChild(label);
            shopCategorys.appendChild(div);
        });
        this.shopDataItems(shopData.items);
        shop.style.display = "block";
    }
    refreshShop() {
        const shop = document.getElementById("shop"), shopCoinVal = document.getElementById("shopCoinVal"), shopItems = document.getElementById("shopItems");
        if (shopCoinVal == null || shopItems == null || shop == null || shop.style.display == "none")
            return;
        if (main_1.default.currentUser != null)
            shopCoinVal.textContent = main_1.default.currentUser.coins.toString();
        Array.from(shopItems.getElementsByTagName("div")).filter((element) => element.classList.contains("row")).forEach((element, index) => {
            var _a, _b;
            element.className = 'row';
            const item_id = element.getAttribute("item_id"), price = element.getAttribute("price");
            const span = element.getElementsByTagName("span")[0];
            if (item_id == null || price == null || span == null)
                return;
            if (((_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.avatar) == parseInt(item_id)) {
                element.classList.add("equiped");
                span.textContent = main_1.default.languageManager.getValueForKey("GAME_SHOP_EQUIPED");
            }
            else if ((_b = main_1.default.currentUser) === null || _b === void 0 ? void 0 : _b.items.includes(parseInt(item_id))) {
                span.textContent = main_1.default.languageManager.getValueForKey("GAME_SHOP_EQUIP");
            }
            else {
                if (main_1.default.currentUser != null && main_1.default.currentUser.coins < parseInt(price))
                    element.classList.add("cant_buy");
            }
        });
    }
    shopDataItems(items) {
        const shopItems = document.getElementById("shopItems");
        if (shopItems == null)
            return;
        shopItems.innerHTML = "";
        items.forEach((item) => {
            var _a, _b;
            const div = document.createElement("div");
            div.classList.add("row");
            div.setAttribute("item_id", item.id);
            div.setAttribute("price", item.price);
            const image = main_1.default.resourceManager.resources["IMAGE_AVATAR_" + item.id];
            if (image == null)
                return;
            const imageElement = document.createElement("img");
            imageElement.classList.add("item");
            imageElement.src = image.src;
            div.appendChild(imageElement);
            const action = document.createElement("div");
            action.classList.add("action");
            action.addEventListener("click", () => main_1.default.webSocketsManager.sendMsg("toggleItem", item.id));
            const span = document.createElement("span");
            if (((_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.avatar) == item.id) {
                div.classList.add("equiped");
                span.textContent = main_1.default.languageManager.getValueForKey("GAME_SHOP_EQUIPED");
            }
            else if ((_b = main_1.default.currentUser) === null || _b === void 0 ? void 0 : _b.items.includes(item.id)) {
                span.textContent = main_1.default.languageManager.getValueForKey("GAME_SHOP_EQUIP");
            }
            else {
                if (main_1.default.currentUser != null && main_1.default.currentUser.coins < item.price)
                    div.classList.add("cant_buy");
                span.innerHTML = '<img src="assets/images/icons/coin.png"> ' + item.price;
            }
            action.appendChild(span);
            div.appendChild(action);
            shopItems.appendChild(div);
        });
    }
    sendChat(e) {
        e.preventDefault();
        const chatCategory = document.getElementById("msgType"), chatMsg = document.getElementById("chatMsg");
        if (chatCategory == null || chatCategory.value.length == 0 || chatMsg == null || chatMsg.value.length == 0)
            return;
        main_1.default.webSocketsManager.sendMsg("newChat", { type: chatCategory.value, message: chatMsg.value });
        chatMsg.value = "";
    }
    keyDownHandler(e) {
        if (this.state.canvas == null || this.state.ctx == null || main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null || main_1.default.currentUser.currentRoom.stadium == null)
            return;
        const inputChat = document.getElementById("chatMsg");
        if (inputChat == null)
            return;
        if (this.state.settings_record_input && inputChat != document.activeElement) {
            main_1.default.settingsManager.setSettings("inputs", this.state.settings_record_input, e.code);
            this.state.settings_record_input = null;
            this.reloadSettings();
            return;
        }
        if (e.code.startsWith("Digit") && inputChat != document.activeElement) {
            const zoom = [1, 1.25, 1.5, 1.75, 2, 2.25, 2.5];
            const zoomLevel = parseInt(e.code.replace("Digit", ""));
            if (zoom[zoomLevel - 1] != null) {
                main_1.default.settingsManager.setSettings("graphics", "zoom", zoom[zoomLevel - 1]);
                this.reloadSettings();
            }
            return;
        }
        if (e.code == "KeyP" && inputChat != document.activeElement) {
            const server = main_1.default.regionServerManager.getServerById(main_1.default.currentUser.currentServer);
            if (server != null)
                server.sendMsg("pause");
            return;
        }
        if (main_1.default.settingsManager.inputs.right.includes(e.code))
            this.state.inputs.right = true;
        if (main_1.default.settingsManager.inputs.left.includes(e.code))
            this.state.inputs.left = true;
        if (main_1.default.settingsManager.inputs.up.includes(e.code))
            this.state.inputs.up = true;
        if (main_1.default.settingsManager.inputs.down.includes(e.code))
            this.state.inputs.down = true;
        if (main_1.default.settingsManager.inputs.kick.includes(e.code))
            this.state.inputs.kick = true;
        if (inputChat === document.activeElement) {
            this.state.inputs.up = false;
            this.state.inputs.down = false;
            this.state.inputs.left = false;
            this.state.inputs.right = false;
            this.state.inputs.kick = false;
        }
        const server = main_1.default.regionServerManager.getServerById(main_1.default.currentUser.currentServer);
        if (server != null)
            server.sendMsg("inputs", this.state.inputs);
        if (main_1.default.settingsManager.inputs.toggle_chat.includes(e.code)) {
            if ((inputChat === document.activeElement))
                setTimeout(() => this.state.canvas.focus(), 1);
            else {
                setTimeout(() => inputChat.focus(), 1);
            }
        }
    }
    KeyUpHandler(e) {
        if (this.state.canvas == null || this.state.ctx == null || main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null || main_1.default.currentUser.currentRoom.stadium == null)
            return;
        if (main_1.default.settingsManager.inputs.right.includes(e.code))
            this.state.inputs.right = false;
        if (main_1.default.settingsManager.inputs.left.includes(e.code))
            this.state.inputs.left = false;
        if (main_1.default.settingsManager.inputs.up.includes(e.code))
            this.state.inputs.up = false;
        if (main_1.default.settingsManager.inputs.down.includes(e.code))
            this.state.inputs.down = false;
        if (main_1.default.settingsManager.inputs.kick.includes(e.code))
            this.state.inputs.kick = false;
        const server = main_1.default.regionServerManager.getServerById(main_1.default.currentUser.currentServer);
        if (server != null)
            server.sendMsg("inputs", this.state.inputs);
    }
    onDestroy() {
        super.onDestroy();
        const chatForm = document.getElementById("chatForm");
        chatForm === null || chatForm === void 0 ? void 0 : chatForm.removeEventListener("chatForm", this.sendChat.bind(this), false);
        document.removeEventListener('keydown', this.keyDownHandler.bind(this), false);
        document.removeEventListener('keyup', this.KeyUpHandler.bind(this), false);
    }
    fmtMSS(s) {
        return (s - (s %= 60)) / 60 + (9 < s ? ':' : ':0') + s;
    }
    updateAvatar() {
        var _a;
        this.refreshShop();
        const avatar = document.getElementById("avatar");
        if (avatar == null)
            return;
        avatar.src = main_1.default.resourceManager.resources["IMAGE_AVATAR_" + ((_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.avatar)].src;
    }
    initRoom(room) {
        const roomName = document.getElementById("roomName");
        if (roomName != null)
            roomName.textContent = room.id;
        const playersCount = document.getElementById("playersCount");
        if (playersCount != null)
            playersCount.textContent = room.currentPlayers.length.toString();
        this.updateScoreData(room.score);
        const list_users = document.getElementById("list_users");
        if (list_users != null)
            list_users.innerHTML = "";
        room.currentPlayers.forEach((player) => {
            const li = document.createElement("li");
            li.dataset.userId = player.id.toString();
            li.setAttribute("username", player.username);
            li.innerHTML = `${player.username} <span>${player.ping.toString()}</span>`;
            if (player.team.id == Team_1.default.RED.id)
                li.classList.add("red");
            else if (player.team.id == Team_1.default.BLUE.id)
                li.classList.add("blue");
            if (list_users != null)
                list_users.appendChild(li);
            li.addEventListener("click", this.showUserMenu.bind(this));
        });
        room.history.forEach((history) => this.addHistory(history));
        this.refreshPickList();
    }
    update(room) {
        this.updateScoreData(room.score);
        const list_users = document.getElementById("list_users");
        if (list_users != null) {
            room.currentPlayers.forEach((player) => {
                list_users.querySelectorAll("li").forEach(element => {
                    if (element.dataset.userId == player.id.toString()) {
                        if (player.team.id == Team_1.default.RED.id) {
                            if (element.classList.contains("blue"))
                                element.classList.remove("blue");
                            if (!element.classList.contains("red"))
                                element.classList.add("red");
                        }
                        else if (player.team.id == Team_1.default.BLUE.id) {
                            if (element.classList.contains("red"))
                                element.classList.remove("red");
                            if (!element.classList.contains("blue"))
                                element.classList.add("blue");
                        }
                        else if (element.classList.contains("red") || element.classList.contains("blue"))
                            element.classList.remove(...["red", "blue"]);
                        const ping = element.getElementsByTagName("span")[0];
                        if (ping != null && ping.textContent != player.ping.toString())
                            ping.textContent = player.ping.toString();
                    }
                });
            });
        }
    }
    setCameraFollow() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let centerX, centerY;
        const playerDisc = (_b = (_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.currentRoom) === null || _b === void 0 ? void 0 : _b.stadium.discs.filter((disc) => disc.player == main_1.default.currentUser.id)[0], ball = (_d = (_c = main_1.default.currentUser) === null || _c === void 0 ? void 0 : _c.currentRoom) === null || _d === void 0 ? void 0 : _d.stadium.discs[0];
        if (ball == null) {
            this.state.camera_follow = { x: 0, y: 0 };
            return;
        }
        const bottomContainerHeight = 160;
        centerX = (_f = (_e = main_1.default.currentUser) === null || _e === void 0 ? void 0 : _e.currentRoom) === null || _f === void 0 ? void 0 : _f.stadium.discs[0].x;
        centerY = (((_h = (_g = main_1.default.currentUser) === null || _g === void 0 ? void 0 : _g.currentRoom) === null || _h === void 0 ? void 0 : _h.stadium.discs[0].y) + bottomContainerHeight);
        if (playerDisc != null) {
            centerX = 0.5 * (centerX + playerDisc.x);
            centerY = 0.5 * (centerY + playerDisc.y);
            const midX = 0.5 * this.state.canvas.width, midY = 0.5 * this.state.canvas.height;
            const infX = playerDisc.x - midX + 50, infY = playerDisc.y - midY + 50, supX = playerDisc.x + midX - 50, supY = playerDisc.y + midY - 50;
            centerX = centerX > supX ? supX : centerX < infX ? infX : centerX;
            centerY = centerY > supY ? supY : centerY < infY ? infY : centerY;
        }
        let frames = 60 * (1 / this.state.fps);
        if (frames > 1)
            frames = 1;
        const smoothingRatio = 0.04;
        frames *= smoothingRatio;
        this.state.cameraFollow.x += (centerX - this.state.cameraFollow.x) * frames;
        this.state.cameraFollow.y += (centerY - this.state.cameraFollow.y) * frames;
        const room = main_1.default.currentUser.currentRoom;
        const margin = 125, canvasHeight = this.state.canvas.height - bottomContainerHeight, stadiumWidth = room.stadium.width + margin, stadiumHeight = room.stadium.height + margin;
        if (this.state.canvas.width > 2 * stadiumWidth) {
            this.state.cameraFollow.x = 0;
        }
        else if (this.state.cameraFollow.x + 0.5 * this.state.canvas.width > stadiumWidth) {
            this.state.cameraFollow.x = stadiumWidth - 0.5 * this.state.canvas.width;
        }
        else if (this.state.cameraFollow.x - 0.5 * this.state.canvas.width < -stadiumWidth) {
            this.state.cameraFollow.x = -stadiumWidth + 0.5 * this.state.canvas.width;
        }
        if (canvasHeight > 2 * stadiumHeight) {
            this.state.cameraFollow.y = 0;
        }
        else if (this.state.cameraFollow.y + 0.5 * canvasHeight > stadiumHeight) {
            this.state.cameraFollow.y = stadiumHeight - 0.5 * canvasHeight;
        }
        else if (this.state.cameraFollow.y - 0.5 * canvasHeight < -stadiumHeight) {
            this.state.cameraFollow.y = -stadiumHeight + 0.5 * canvasHeight;
        }
    }
    renderNotif(dt) {
        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
            return;
        const notif = document.getElementById("notif");
        if (notif == null)
            return;
        switch (main_1.default.currentUser.currentRoom.state) {
            case RoomState_1.RoomState.PAUSE: {
                this.state.canvas.classList.add("pause");
                notif.innerHTML = `${main_1.default.languageManager.getValueForKey("GAME_GENERAL_PAUSE")}`;
                if (notif.style.display == "none")
                    notif.style.display = "block";
                break;
            }
            case RoomState_1.RoomState.UNPAUSE: {
                // TODO PLAYER JOIN ON UNPAUSE
                this.state.unpauseInterval -= (dt * 1000);
                this.state.canvas.classList.add("pause");
                notif.innerHTML = `${main_1.default.languageManager.getValueForKey("GAME_GENERAL_PAUSE")} <div id='pause' style='width: ${this.state.unpauseInterval * 100 / 3000}%'></div>`;
                if (notif.style.display == "none")
                    notif.style.display = "block";
                break;
            }
            case RoomState_1.RoomState.GOAL_SCORE: {
                if (notif.style.display == "none")
                    notif.style.display = "block";
                break;
            }
            default: {
                if (this.state.canvas.classList.length > 0)
                    this.state.canvas.classList = "";
                if (notif.style.display == "block")
                    notif.style.display = "none";
                notif.innerHTML = "";
                break;
            }
        }
    }
    renderGame(dt) {
        var _a, _b, _c, _d;
        if (this.state.canvas == null || this.state.ctx == null || main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null || main_1.default.currentUser.currentRoom.stadium == null)
            return;
        if (main_1.default.currentUser.currentRoom.state == RoomState_1.RoomState.GAME_ENDED) {
            this.state.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.state.ctx.clearRect(0, 0, this.state.canvas_rect[2] - this.state.canvas_rect[0], this.state.canvas_rect[3] - this.state.canvas_rect[1]);
            this.renderNotif(dt);
            this.showMenu();
            return;
        }
        this.resize_canvas();
        this.renderNotif(dt);
        this.state.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.state.ctx.clearRect(0, 0, this.state.canvas_rect[2] - this.state.canvas_rect[0], this.state.canvas_rect[3] - this.state.canvas_rect[1]);
        this.setCameraFollow();
        this.state.ctx.translate(-this.state.canvas_rect[0], -this.state.canvas_rect[1]);
        this.state.ctx.scale(window.devicePixelRatio * main_1.default.settingsManager.graphics.zoom, window.devicePixelRatio * main_1.default.settingsManager.graphics.zoom);
        this.state.ctx.translate(-this.state.cameraFollow.x, -this.state.cameraFollow.y);
        this.renderbg(main_1.default.currentUser.currentRoom.stadium, this.state.ctx);
        main_1.default.currentUser.currentRoom.stadium.segments.forEach((segment) => {
            if (segment.vis) {
                this.state.ctx.beginPath();
                this.state.ctx.lineWidth = 3;
                this.state.ctx.strokeStyle = this.color_to_style(segment.color, Base_1.Base.segment_color);
                var segV0 = segment.v0;
                var segV1 = segment.v1;
                if (segment.curveF === undefined) {
                    this.state.ctx.moveTo(segV0[0], segV0[1]);
                    this.state.ctx.lineTo(segV1[0], segV1[1]);
                }
                else {
                    var segCC = segment.circleCenter;
                    var pos_x = segV0[0] - segCC[0];
                    var pos_y = segV0[1] - segCC[1];
                    this.state.ctx.arc(segCC[0], segCC[1], Math.sqrt(pos_x * pos_x + pos_y * pos_y), Math.atan2(pos_y, pos_x), Math.atan2(segV1[1] - segCC[1], segV1[0] - segCC[0]));
                }
                this.state.ctx.stroke();
            }
        });
        const now = performance.now();
        const renderTimestamp = now - (0.016666666666666666) + (((_d = (_b = (_a = main_1.default === null || main_1.default === void 0 ? void 0 : main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.currentRoom) === null || _b === void 0 ? void 0 : _b.getPlayer((_c = main_1.default === null || main_1.default === void 0 ? void 0 : main_1.default.currentUser) === null || _c === void 0 ? void 0 : _c.id)) === null || _d === void 0 ? void 0 : _d.ping) || 0);
        main_1.default.currentUser.currentRoom.stadium.discs.forEach((disc, i) => {
            var _a, _b;
            const buffer = (_b = (_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.currentRoom) === null || _b === void 0 ? void 0 : _b.discHistory[i];
            if (buffer != null) {
                while (buffer.length >= 2 && buffer[1].timestamp <= renderTimestamp)
                    buffer.shift();
                if (buffer.length >= 2 && buffer[0].timestamp <= renderTimestamp && renderTimestamp <= buffer[1].timestamp) {
                    disc.x = this.interpolate(buffer[0].shareableData.x, buffer[1].shareableData.x, buffer[0].timestamp, buffer[1].timestamp, renderTimestamp);
                    disc.y = this.interpolate(buffer[0].shareableData.y, buffer[1].shareableData.y, buffer[0].timestamp, buffer[1].timestamp, renderTimestamp);
                }
            }
        });
        const myDisc = main_1.default.currentUser.currentRoom.stadium.discs.filter((disc) => disc.player == main_1.default.currentUser.id);
        if (myDisc[0] != null)
            this.drawPlayerDiscExtLine(myDisc[0]);
        main_1.default.currentUser.currentRoom.stadium.discs.forEach((disc, i) => {
            this.state.ctx.beginPath();
            this.state.ctx.arc(disc.x, disc.y, disc.radius, 0, Math.PI * 2, true);
            if (disc.player != null && disc.player != 0 && disc.player != main_1.default.currentUser.id) {
                const player = main_1.default.currentUser.currentRoom.currentPlayers.filter((p) => p.id == disc.player)[0];
                if (player != null)
                    this.drawUsername(player.username, disc, player.team.id);
            }
            if (disc.kick)
                this.state.ctx.strokeStyle = 'rgb(255,255,255)';
            else
                this.state.ctx.strokeStyle = 'rgb(0,0,0)';
            this.state.ctx.lineWidth = 2;
            if (disc.avatar != null && disc.avatar != 0) {
                this.state.ctx.save();
                this.state.ctx.clip();
                this.state.ctx.drawImage(main_1.default.resourceManager.resources["IMAGE_AVATAR_" + disc.avatar], disc.x - disc.radius, disc.y - disc.radius, disc.radius * 2, disc.radius * 2);
                this.state.ctx.restore();
            }
            else {
                this.state.ctx.fillStyle = this.color_to_style(disc.color, Base_1.Base.discPhysics.color);
                this.state.ctx.fill();
            }
            this.state.ctx.stroke();
        });
    }
    drawUsername(username, disc, team) {
        this.state.ctx.font = '12px sans-serif';
        const text = this.state.ctx.measureText(username);
        this.state.ctx.fillStyle = 'black';
        this.state.ctx.strokeText(username, disc.x - (text.width / 2), disc.y + disc.radius + 15);
        if (team == Team_1.default.RED.id)
            this.state.ctx.fillStyle = '#bd3838';
        else if (team == Team_1.default.BLUE.id)
            this.state.ctx.fillStyle = '#bd3838';
        else
            this.state.ctx.fillStyle = "white";
        this.state.ctx.globalAlpha = 0.8;
        this.state.ctx.fillText(username, disc.x - (text.width / 2), disc.y + disc.radius + 15);
        this.state.ctx.globalAlpha = 1;
    }
    drawPlayerDiscExtLine(disc) {
        this.state.ctx.beginPath();
        this.state.ctx.lineWidth = 3;
        this.state.ctx.strokeStyle = 'white';
        this.state.ctx.globalAlpha = 0.3;
        this.state.ctx.arc(disc.x, disc.y, disc.radius + 10, 0, 2 * Math.PI, false);
        this.state.ctx.stroke();
        this.state.ctx.globalAlpha = 1;
    }
    interpolate(p0, p1, t0, t1, renderTimestamp) {
        const deltaMovement = (p1 - p0);
        return p0 + deltaMovement * (renderTimestamp - t0) / (t1 - t0);
    }
    resize_canvas() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var rect = [-((_b = (_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.currentRoom) === null || _b === void 0 ? void 0 : _b.stadium.width), -((_d = (_c = main_1.default.currentUser) === null || _c === void 0 ? void 0 : _c.currentRoom) === null || _d === void 0 ? void 0 : _d.stadium.height), (_f = (_e = main_1.default.currentUser) === null || _e === void 0 ? void 0 : _e.currentRoom) === null || _f === void 0 ? void 0 : _f.stadium.width, (_h = (_g = main_1.default.currentUser) === null || _g === void 0 ? void 0 : _g.currentRoom) === null || _h === void 0 ? void 0 : _h.stadium.height];
        var consider = function (pt, r) {
            var x = pt[0];
            var y = pt[1];
            if (x - r < rect[0])
                rect[0] = x - r;
            if (y - r < rect[1])
                rect[1] = y - r;
            if (x + r > rect[2])
                rect[2] = x + r;
            if (y + r > rect[3])
                rect[3] = y + r;
        };
        this.for_all_shapes((_k = (_j = main_1.default.currentUser) === null || _j === void 0 ? void 0 : _j.currentRoom) === null || _k === void 0 ? void 0 : _k.stadium, function (shape) {
            var o = shape.object;
            switch (shape.type) {
                case 'vertexes':
                    consider([o.x, o.y], 0);
                    break;
                case 'goals':
                    consider(o.p0, 0);
                    consider(o.p1, 0);
                    break;
                case 'discs':
                    consider([o.x, o.y], o.radius);
                    break;
            }
        });
        var canvas_div_size = [this.state.canvas.clientWidth, this.state.canvas.clientHeight];
        rect = [
            Math.round(Math.min(rect[0] - 0, -canvas_div_size[0] / 2)),
            Math.round(Math.min(rect[1] - 0, -canvas_div_size[1] / 2)),
            Math.round(Math.max(rect[2] + 0, canvas_div_size[0] / 2)),
            Math.round(Math.max(rect[3] + 0, canvas_div_size[1] / 2)),
        ];
        this.state.canvas_rect = rect;
        this.state.canvas.width = document.body.offsetWidth;
        this.state.canvas.height = document.body.offsetHeight;
    }
    for_all_shapes(st, types, f = null) {
        if (!f) {
            f = types;
            types = ['vertexes', 'segments', 'goals', 'discs', 'planes'];
        }
        types.forEach((name) => {
            var group = st[name];
            if (group) {
                group.forEach((obj, i) => {
                    return f(this.Shape(name, obj, i));
                });
            }
        });
    }
    Shape(type, object, i) {
        return { type: type, object: object, index: i };
    }
    renderbg(stadium, ctx) {
        var bg = stadium.bg;
        ctx.save();
        if (bg.type == 'grass' || bg.type == 'hockey') {
            if (bg.type == 'grass')
                this.state.canvas.style.backgroundColor = Base_1.Base["grass"].bg_color;
            else
                this.state.canvas.style.backgroundColor = Base_1.Base["hockey"].bg_color;
            ctx.beginPath();
            ctx.moveTo(-bg.width + bg.cornerRadius, -bg.height);
            // TODO: Left border is wrong
            ctx.arcTo(bg.width, -bg.height, bg.width, -bg.height + bg.cornerRadius, bg.cornerRadius);
            ctx.arcTo(bg.width, bg.height, bg.width - bg.cornerRadius, bg.height, bg.cornerRadius);
            ctx.arcTo(-bg.width, bg.height, -bg.width, bg.height - bg.cornerRadius, bg.cornerRadius);
            ctx.arcTo(-bg.width, -bg.height, -bg.width + bg.cornerRadius, -bg.height, bg.cornerRadius);
            ctx.save();
            ctx.clip();
            ctx.translate(40, 40);
            ctx.fillStyle = this.state.ctx.createPattern(main_1.default.resourceManager.resources[`IMAGE_TILE_${bg.type.toUpperCase()}`], null);
            ;
            ctx.fillRect(-stadium.width - 50, -stadium.height - 50, 2 * stadium.width - 40, 2 * stadium.height - 20);
            ctx.restore();
            ctx.moveTo(0, -bg.height);
            ctx.lineTo(0, bg.height);
            ctx.moveTo(bg.kickOffRadius, 0);
            ctx.arc(0, 0, bg.kickOffRadius, 0, Math.PI * 2, true);
            ctx.lineWidth = 3;
            ctx.strokeStyle = Base_1.Base["grass"].border_color;
            ctx.stroke();
        }
        else if (bg.type == '' && bg.color != undefined) {
            ctx.fillStyle = this.color_to_style(bg.color);
            ctx.fillRect(-stadium.width, -stadium.height, 2 * stadium.width, 2 * stadium.height);
            this.state.canvas.style.background = this.color_to_style(bg.color);
        }
        else
            this.state.canvas.style.backgroundColor = Base_1.Base["grass"].bg_color;
        ctx.restore();
    }
    color_to_style(color, def = null) {
        if (!color) {
            return def ? def : 'rgb(0,0,0)';
        }
        else if (color.substr) {
            return '#' + color;
        }
        else {
            return 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';
        }
    }
    updateScoreData(score) {
        const scoreRed = document.getElementById("scoreRed");
        if (scoreRed != null)
            scoreRed.textContent = score.red.toString();
        const scoreBlue = document.getElementById("scoreBlue");
        if (scoreBlue != null)
            scoreBlue.textContent = score.blue.toString();
        const time = document.getElementById("time"), overtime = document.getElementById("overtime");
        if (time != null && overtime != null) {
            const room = main_1.default.currentUser.currentRoom;
            if (room.score.timeLimit > 0 && Math.floor(score.time) + 30 > room.score.timeLimit * 60)
                time.classList.add("warning");
            else
                time.classList.remove("warning");
            if (room.score.timeLimit > 0 && Math.floor(score.time) > room.score.timeLimit * 60)
                overtime.style.display = "block";
            else
                overtime.style.display = "none";
            time.textContent = this.fmtMSS(Math.floor(score.time));
        }
    }
    drop(ev) {
        ev.preventDefault();
        const data = ev.dataTransfer.getData("text");
        const target = ev.target;
        const server = main_1.default.regionServerManager.getServerById(main_1.default.currentUser.currentServer);
        if (server == null)
            return;
        switch (ev.target.getAttribute("id")) {
            case "pick_list_red": {
                server.sendMsg("setTeamPlayer", { playerId: parseInt(data), team: Team_1.default.RED.id });
                break;
            }
            case "pick_list_blue": {
                server.sendMsg("setTeamPlayer", { playerId: parseInt(data), team: Team_1.default.BLUE.id });
                break;
            }
            default: {
                server.sendMsg("setTeamPlayer", { playerId: parseInt(data), team: Team_1.default.SPECTATORS.id });
                break;
            }
        }
    }
    startDrag(ev) {
        ev.dataTransfer.setData("text", ev.target.getAttribute("player_id"));
    }
    refreshPickList() {
        var _a, _b;
        const pick_list = document.getElementById("pick_list"), pick_list_red = document.getElementById("pick_list_red"), pick_list_blue = document.getElementById("pick_list_blue"), pick_list_spectators = document.getElementById("pick_list_spectators");
        if (pick_list == null || pick_list_red == null || pick_list_blue == null || pick_list_spectators == null)
            return;
        pick_list_red.innerHTML = "";
        pick_list_blue.innerHTML = "";
        pick_list_spectators.innerHTML = "";
        (_b = (_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.currentRoom) === null || _b === void 0 ? void 0 : _b.currentPlayers.forEach((player) => {
            var _a, _b;
            const div = document.createElement("div");
            div.setAttribute("player_id", player.id.toString());
            div.draggable = true;
            div.classList.add("row");
            const avatar = document.createElement("img");
            avatar.src = main_1.default.resourceManager.resources["IMAGE_AVATAR_" + player.avatar].src;
            div.appendChild(avatar);
            const username = document.createElement("div");
            username.classList.add("username");
            if (((_b = (_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.currentRoom) === null || _b === void 0 ? void 0 : _b.pickMode) == player.id)
                username.classList.add("picker");
            username.textContent = player.username;
            div.appendChild(username);
            const ping = document.createElement("div");
            ping.classList.add("ping");
            ping.textContent = player.ping.toString();
            div.appendChild(ping);
            div.addEventListener("dragstart", this.startDrag.bind(this));
            if (player.team.id == Team_1.default.RED.id)
                pick_list_red.appendChild(div);
            else if (player.team.id == Team_1.default.BLUE.id)
                pick_list_blue.appendChild(div);
            else
                pick_list_spectators.appendChild(div);
        });
    }
    playerJoin(player, playerLength) {
        const playersCount = document.getElementById("playersCount");
        if (playersCount != null)
            playersCount.textContent = playerLength.toString();
        const list_users = document.getElementById("list_users");
        const li = document.createElement("li");
        li.dataset.userId = player.id.toString();
        li.setAttribute("username", player.username);
        li.innerHTML = `${player.username} <span>${player.ping}</span>`;
        li.addEventListener("click", this.showUserMenu.bind(this));
        if (player.team == Team_1.default.RED)
            li.classList.add("red");
        else if (player.team == Team_1.default.BLUE)
            li.classList.add("blue");
        if (list_users != null)
            list_users.appendChild(li);
        this.refreshPickList();
    }
    playerLeave(playerId, playerLength) {
        const playersCount = document.getElementById("playersCount");
        if (playersCount != null)
            playersCount.textContent = playerLength.toString();
        const list_users = document.getElementById("list_users");
        if (list_users != null) {
            list_users.querySelectorAll("li").forEach(element => {
                if (element.dataset.userId == playerId.toString())
                    list_users.removeChild(element);
            });
        }
        this.refreshPickList();
    }
    newChat(data) {
        const chatContainer = document.getElementById("chatContent");
        let scrollToBottom = false;
        if (chatContainer != null && Math.abs(chatContainer.scrollHeight - chatContainer.scrollTop - chatContainer.clientHeight) < 1)
            scrollToBottom = true;
        switch (data.type) {
            case "announcement":
                {
                    const element = document.createElement("div");
                    element.classList.add("announcement");
                    element.textContent = data.officialTrad ? main_1.default.languageManager.getValueForKey(data.message, data.params ? data.params : []) : data.message;
                    if (data.color != null)
                        element.style.color = data.color;
                    if (data.bold)
                        element.style.fontWeight = "bold";
                    chatContainer === null || chatContainer === void 0 ? void 0 : chatContainer.appendChild(element);
                    switch (data.sound) {
                        case 1:
                            main_1.default.settingsManager.audio.general && main_1.default.settingsManager.audio.chat ? main_1.default.resourceManager.resources["AUDIO_HIGHLIGHT"].play() : null;
                            break;
                        default:
                            main_1.default.settingsManager.audio.general && main_1.default.settingsManager.audio.chat ? main_1.default.resourceManager.resources["AUDIO_CHAT"].play() : null;
                            break;
                    }
                    break;
                }
            case "pm_to":
            case "pm_from":
                {
                    const element = document.createElement("div");
                    element.textContent = data.message;
                    const span = document.createElement("span");
                    span.setAttribute("username", data.username);
                    span.classList.add(data.type);
                    if (data.type == "pm_to")
                        span.textContent = `[< ${main_1.default.languageManager.getValueForKey("GAME_CHAT_PM_TO", [data.username])}] `;
                    else
                        span.textContent = `[> ${main_1.default.languageManager.getValueForKey("GAME_CHAT_PM_FROM", [data.username])}] `;
                    span.addEventListener("click", this.showUserMenu.bind(this));
                    element.prepend(span);
                    chatContainer === null || chatContainer === void 0 ? void 0 : chatContainer.appendChild(element);
                    main_1.default.settingsManager.audio.general && main_1.default.settingsManager.audio.chat ? main_1.default.resourceManager.resources["AUDIO_HIGHLIGHT"].play() : null;
                    break;
                }
            default: {
                const element = document.createElement("div");
                element.textContent = data.message;
                const span = document.createElement("span");
                if (data.team != null) {
                    switch (data.team) {
                        case Team_1.default.RED.id:
                            span.style.color = Team_1.default.RED.color;
                            break;
                        case Team_1.default.BLUE.id:
                            span.style.color = Team_1.default.BLUE.color;
                            break;
                        case Team_1.default.SPECTATORS.id:
                            span.style.color = Team_1.default.SPECTATORS.color;
                            break;
                    }
                    span.textContent = `[${main_1.default.languageManager.getValueForKey("GAME_GENERAL_TEAM")}] ${data.username}: `;
                }
                else {
                    span.classList.add(data.rank);
                    span.textContent = data.username + ": ";
                }
                span.setAttribute("username", data.username);
                span.addEventListener("click", this.showUserMenu.bind(this));
                element.prepend(span);
                chatContainer === null || chatContainer === void 0 ? void 0 : chatContainer.appendChild(element);
                main_1.default.settingsManager.audio.general && main_1.default.settingsManager.audio.chat ? main_1.default.resourceManager.resources["AUDIO_CHAT"].play() : null;
                break;
            }
        }
        if (chatContainer != null) {
            if (scrollToBottom)
                chatContainer.scrollTop = chatContainer.scrollHeight;
            if (chatContainer.childElementCount > 20)
                chatContainer.removeChild(chatContainer.getElementsByTagName('div')[0]);
        }
    }
    whisper(username) {
        const chatCategory = document.getElementById("msgType"), chatMsg = document.getElementById("chatMsg");
        if (chatCategory == null || chatMsg == null)
            return;
        let optionVal = null;
        Array.from(chatCategory.getElementsByTagName("option")).forEach((element) => {
            if (element.value == username)
                optionVal = element;
        });
        if (optionVal == null) {
            const option = document.createElement("option");
            option.value = username;
            option.innerHTML = username;
            chatCategory.append(option);
        }
        chatCategory.value = username;
        chatMsg.focus();
    }
    userMenuItem(e) {
        switch (e.srcElement.getAttribute("type")) {
            case "whisper": {
                this.whisper(this.state.focusUser);
                break;
            }
            case "profile": {
                main_1.default.webSocketsManager.sendMsg("requestProfile", this.state.focusUser);
                break;
            }
            case "friend": {
                main_1.default.webSocketsManager.sendMsg("addFriend", this.state.focusUser);
                break;
            }
            case "report": {
                main_1.default.webSocketsManager.sendMsg("report", this.state.focusUser);
                break;
            }
            case "mute": {
                this.switchAdmin("new_sanction", { type: "mute", username: this.state.focusUser });
                break;
            }
            case "ban": {
                this.switchAdmin("new_sanction", { type: "ban", username: this.state.focusUser });
                break;
            }
        }
    }
    hideUserMenu() {
        document.removeEventListener('click', this.state.userMenuFunction);
        const user_menu = document.getElementById("user_menu");
        if (user_menu == null)
            return;
        user_menu.style.display = "none";
    }
    showUserMenu(e) {
        var _a;
        if (e.srcElement.getAttribute("username") == ((_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.username))
            return;
        this.state.focusUser = e.srcElement.getAttribute("username");
        const user_menu = document.getElementById("user_menu");
        if (user_menu == null)
            return;
        Array.from(user_menu.getElementsByTagName("li")).forEach((element) => {
            var _a;
            if (element.getAttribute("type") == "friend" && ((_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.getFriendbyUsername(this.state.focusUser)) != null)
                element.style.display = "none";
            else
                element.style.display = "block";
            if (["mute", "ban"].includes(element.getAttribute("type"))) {
                if (["user", "vip"].includes(main_1.default.currentUser.rank))
                    element.style.display = "none";
                else
                    element.style.display = "block";
            }
        });
        user_menu.style.display = "block";
        user_menu.style.left = (e.pageX - 75) + "px";
        user_menu.style.top = (e.pageY - user_menu.clientHeight - 20) + "px";
        this.state.userMenuFunction = this.hideUserMenu.bind(this);
        setTimeout(() => document.addEventListener('click', this.state.userMenuFunction, false), 10);
    }
    getRegionFlag(region) {
        switch (region.toLowerCase()) {
            case "eu":
                return "EU";
            default:
                return "UNDEFINED";
        }
    }
    render() {
        var _a;
        if (this.app == null)
            return;
        this.app.innerHTML =
            `<div class="gameScreen">
                <canvas id="game" tabindex="1"></canvas>

                <div class="header">
                    <div class="roomScore">
                        <div class="circle red"></div> <span id="scoreRed"></span> <span class="space">-</span> <span id="scoreBlue"></span> <div class="circle blue"></div>
                    </div>

                    <div class="time"><img src="assets/images/icons/clock.png"> <span id="time"></span> <span id="overtime">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_OVERTIME")}</span></div>
                    <div class="players"><img src="assets/images/icons/players.png"> <span id="playersCount"></span></div>
                    <div class="roomName"><img src="assets/images/flags/region/${this.getRegionFlag(this.state.currentUser.currentServer)}.svg"/><span id="roomName"></span></div>
                </div>

                <div class="stats">
                    <div class="row"><span id="fps">0</span> fps</div>
                </div>

                <div class="relative_container">
                    <div id="notif"></div>

                    <div class="modal" id="pick_list">
                        <div class="pick_list_flex">
                            <div class="container red">
                                <div class="title">
                                    <div class="title_content">${main_1.default.languageManager.getValueForKey("GAME_TEAM_RED")}</div>
                                </div>

                                <div class="content pick_list_team" id="pick_list_red"></div>
                            </div>

                            <div class="container spectators">
                                <div class="title">
                                    <div class="title_content">${main_1.default.languageManager.getValueForKey("GAME_TEAM_SPECTATORS")}</div>
                                </div>

                                <div class="content pick_list_team" id="pick_list_spectators"></div>
                            </div>

                            <div class="container blue">
                                <div class="title">
                                    <div class="title_content">${main_1.default.languageManager.getValueForKey("GAME_TEAM_BLUE")}</div>
                                </div>

                                <div class="content pick_list_team" id="pick_list_blue"></div>
                            </div>
                        </div>
                    </div>

                    <div class="modal" id="admin">
                        <div class="container">
                            <div class="title">
                                <div class="title_content"><img src="assets/images/icons/settings.svg"> ${main_1.default.languageManager.getValueForKey("GAME_ADMIN")}</div>
                            </div>

                            <ul id="admin_menu">
                                <li type="team">${main_1.default.languageManager.getValueForKey("GAME_ADMIN_TEAM")}</li>
                                <li type="reports">${main_1.default.languageManager.getValueForKey("GAME_ADMIN_REPORTS")}</li>
                                <li type="sanctions">${main_1.default.languageManager.getValueForKey("GAME_ADMIN_SANCTIONS")}</li>
                                <li type="new_sanction">${main_1.default.languageManager.getValueForKey("GAME_ADMIN_NEW_SANCTION")}</li>
                                <li type="rank">${main_1.default.languageManager.getValueForKey("GAME_ADMIN_RANK")}</li>
                            </ul>

                            <div class="content">
                                <div class="category_title"><span id="admin_title"></span></div>

                                <div id="admin_content"></div>
                            </div>

                            <div class="bottom"><button class="close">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_CLOSE")}</button></div>
                        </div>
                    </div>

                    <div class="modal" id="leaderboard">
                        <div class="container">
                            <div class="title">
                                <div class="title_content"><img src="assets/images/icons/settings.svg"> ${main_1.default.languageManager.getValueForKey("GAME_LEADERBOARD")}</div>
                            </div>

                            <div class="content">
                                <div class="filter">
                                    ${main_1.default.languageManager.getValueForKey("GAME_LEADERBOARD_FILTER")}

                                    <select id="leaderboardFilter"></select>
                                </div>

                                <div id="leaderboardContent"></div>
                            </div>

                            <div class="bottom"><button class="close">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_CLOSE")}</button></div>
                        </div>
                    </div>

                    <div class="modal" id="profile">
                        <div class="container">
                            <div class="title">
                                <div class="avatar"><img profile_data="avatar"></div>
                                <div class="title_content">
                                    <span class="state" profile_data="online"></span>
                                    <span profile_data="username"></span>
                                </div>
                            </div>

                            <div class="content">
                                <div class="category">
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_REGISTERED")}: <span profile_data="registered"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_LEVEL_XP")}: <span profile_data="level_xp"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_ELO")}: <span profile_data="elo"></span></div>
                                </div>

                                <div class="category">
                                    <div class="category_title">${main_1.default.languageManager.getValueForKey("GAME_STATS_GAMES")}</div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_GAMES_PLAYED")}: <span profile_data="games_played"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_GAMES_WON")}: <span profile_data="games_won"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_GAMES_LOST")}: <span profile_data="games_lost"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_WIN_RATE")}: <span profile_data="win_rate"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_BEST_STREAK")}: <span profile_data="best_streak"></span></div>
                                </div>

                                <div class="category">
                                    <div class="category_title">${main_1.default.languageManager.getValueForKey("GAME_STATS_GENERAL")}</div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_SHOTS")}: <span profile_data="shots"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_SHOTS_PER_MATCH")}: <span profile_data="shots_per_match"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_GOALS")}: <span profile_data="goals"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_GOALS_PER_MATCH")}: <span profile_data="goals_per_match"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_HAT_TRICKS")}: <span profile_data="hat_tricks"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_ASSISTS")}: <span profile_data="assists"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_ASSISTS_PER_MATCH")}: <span profile_data="assists_per_match"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_SAVES")}: <span profile_data="saves"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_SAVES_PER_MATCH")}: <span profile_data="saves_per_match"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_PASS_ACCURACY")}: <span profile_data="pass_accuracy"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_PASS_PER_MATCH")}: <span profile_data="pass_per_match"></span></div>
                                </div>

                                <div class="category">
                                    <div class="category_title">${main_1.default.languageManager.getValueForKey("GAME_STATS_GOALKEEPER")}</div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_PLAYED_GK")}: <span profile_data="played_gk"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_CS")}: <span profile_data="cs"></span></div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_STATS_CS_PERCENTAGE")}: <span profile_data="cs_percentage"></span></div>
                                </div>

                                <div class="category">
                                    <div class="category_title">${main_1.default.languageManager.getValueForKey("GAME_STATS_BADGES")}</div>
                                    <div>${main_1.default.languageManager.getValueForKey("GAME_GENERAL_NOT_AVAILABLE")}</div>
                                </div>
                            </div>

                            <div class="bottom"><button class="close">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_CLOSE")}</button></div>
                        </div>
                    </div>

                    <div class="modal" id="settings">
                        <div class="container">
                            <div class="title">
                                <div class="title_content"><img src="assets/images/icons/settings.svg"> ${main_1.default.languageManager.getValueForKey("GAME_SETTINGS")}</div>
                            </div>

                            <div class="content">
                                <ul class="menu">
                                    <li category="graphics" class="selected">${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS")}</li>
                                    <li category="audio">${main_1.default.languageManager.getValueForKey("GAME_MENU_AUDIO")}</li>
                                    <li category="inputs">${main_1.default.languageManager.getValueForKey("GAME_MENU_INPUTS")}</li>
                                </ul>

                                <div class="category" category_name="graphics">
                                    <div class="row">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_ZOOM")}</span>
                                        <select type="settings" settings_category="graphics" settings_val="zoom">
                                            <option value="1">${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_ZOOM")} 1x</option>
                                            <option value="1.25">${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_ZOOM")} 1.25x</option>
                                            <option value="1.5">${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_ZOOM")} 1.5x</option>
                                            <option value="1.75">${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_ZOOM")} 1.75x</option>
                                            <option value="2">${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_ZOOM")} 2x</option>
                                            <option value="2.25">${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_ZOOM")} 2.25x</option>
                                            <option value="2.5">${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_ZOOM")} 2.5x</option>
                                        </select>
                                    </div>

                                    <div class="row">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_FPS")}</span>
                                        <select type="settings" settings_category="graphics" settings_val="fps">
                                            <option value="0">${main_1.default.languageManager.getValueForKey("GAME_MENU_GRAPHICS_FPS_NO_LIMIT")}</option>
                                            <option value="60">60</option>
                                            <option value="30">30</option>
                                            <option value="20">20</option>
                                            <option value="10">10</option>
                                        </select>
                                    </div>
                                </div>

                                <div class="category" category_name="audio">
                                    <div class="row">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_AUDIO_GENERAL")}</span>
                                        
                                        <div class="toggle-rect">
                                            <input type="checkbox" id="settings_audio_general" settings_category="audio" settings_val="general">
                                            <label for="settings_audio_general"></label>
                                        </div>
                                    </div>

                                    <div class="row">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_AUDIO_CHAT")}</span>
                                        
                                        <div class="toggle-rect">
                                            <input type="checkbox" id="settings_audio_chat" settings_category="audio" settings_val="chat">
                                            <label for="settings_audio_chat"></label>
                                        </div>
                                    </div>

                                    <div class="row">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_AUDIO_GAME")}</span>
                                        
                                        <div class="toggle-rect">
                                            <input type="checkbox" id="settings_audio_game" settings_category="audio" settings_val="game">
                                            <label for="settings_audio_game"></label>
                                        </div>
                                    </div>

                                    <div class="row">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_AUDIO_NOTIFICATION")}</span>
                                        
                                        <div class="toggle-rect">
                                            <input type="checkbox" id="settings_audio_notif" settings_category="audio" settings_val="notif">
                                            <label for="settings_audio_notif"></label>
                                        </div>
                                    </div>
                                </div>

                                <div class="category" category_name="inputs">
                                    <div id="recordKey"><div>${main_1.default.languageManager.getValueForKey("GAME_MENU_INPUTS_PRESS")}</div></div>

                                    <div class="row inputs">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_INPUTS_UP")}</span>
                                        
                                        <div class="inputs_value" settings_category="inputs" settings_val="up"></div>
                                    </div>

                                    <div class="row inputs">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_INPUTS_DOWN")}</span>
                                        
                                        <div class="inputs_value" settings_category="inputs" settings_val="down"></div>
                                    </div>

                                    <div class="row inputs">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_INPUTS_LEFT")}</span>
                                        
                                        <div class="inputs_value" settings_category="inputs" settings_val="left"></div>
                                    </div>

                                    <div class="row inputs">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_INPUTS_RIGHT")}</span>
                                        
                                        <div class="inputs_value" settings_category="inputs" settings_val="right"></div>
                                    </div>

                                    <div class="row inputs">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_INPUTS_KICK")}</span>
                                        
                                        <div class="inputs_value" settings_category="inputs" settings_val="kick"></div>
                                    </div>

                                    <div class="row inputs">
                                        <span>${main_1.default.languageManager.getValueForKey("GAME_MENU_INPUTS_TOGGLE_CHAT")}</span>
                                        
                                        <div class="inputs_value" settings_category="inputs" settings_val="toggle_chat"></div>
                                    </div>
                                </div>
                            </div>

                            <div class="bottom"><button class="close">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_CLOSE")}</button></div>
                        </div>
                    </div>

                    <div class="modal" id="friends">
                        <div class="container">
                            <div class="title">
                                <div class="title_content"><img src="assets/images/icons/heart.svg"> ${main_1.default.languageManager.getValueForKey("GAME_FRIENDS")}</div>
                            </div>

                            <div class="content" id="friendsList"></div>

                            <div class="bottom"><button class="close">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_CLOSE")}</button></div>
                        </div>
                    </div>

                    <div class="modal" id="shop">
                        <div class="container">
                            <div class="title">
                                <div class="title_content"><img src="assets/images/icons/basket.svg"> ${main_1.default.languageManager.getValueForKey("GAME_SHOP")}</div>
                            </div>

                            <div class="flex">
                                <div class="categorys">
                                    <div class="coin"><img src="assets/images/icons/coin.png"> <span id="shopCoinVal"></span></div>

                                    <div id="shopCategorys"></div>
                                </div>

                                <div class="items" id="shopItems"></div>
                            </div>

                            <div class="bottom"><button class="close">${main_1.default.languageManager.getValueForKey("GAME_GENERAL_CLOSE")}</button></div>
                        </div>
                    </div>
                </div>

                <ul id="user_menu">
                    <li type="mute">${main_1.default.languageManager.getValueForKey("GAME_USER_MENU_MUTE")}</li>
                    <li type="ban">${main_1.default.languageManager.getValueForKey("GAME_USER_MENU_BAN")}</li>
                    <li type="profile">${main_1.default.languageManager.getValueForKey("GAME_USER_MENU_PROFILE")}</li>
                    <li type="friend">${main_1.default.languageManager.getValueForKey("GAME_USER_MENU_FRIEND")}</li>
                    <li type="report">${main_1.default.languageManager.getValueForKey("GAME_USER_MENU_REPORT")}</li>
                    <li type="whisper">${main_1.default.languageManager.getValueForKey("GAME_USER_MENU_WHISPER")}</li>
                </ul>

                <div class="bottom_container">
                    <div class="user">
                        <div class="left">
                            <div class="avatar" id="request_profile"><img src="${main_1.default.resourceManager.resources["IMAGE_AVATAR_" + ((_a = main_1.default.currentUser) === null || _a === void 0 ? void 0 : _a.avatar)].src}" id="avatar"></div>

                            <div class="general_menu">
                                <div type="friends"><img src="assets/images/icons/heart.svg"></div>
                                <div type="shop"><img src="assets/images/icons/basket.svg"></div>
                                <div type="settings"><img src="assets/images/icons/settings.svg"></div>
                            </div>
                        </div>

                        <div class="right">
                            <div class="general_menu">
                                <div type="menu"><img src="assets/images/icons/menu.svg"></div>
                                <div type="leaderboard"><img src="assets/images/icons/leaderboard.svg"></div>
                                <div type="team"><img src="assets/images/icons/team.svg"></div>
                                <div type="admin"><img src="assets/images/icons/star.svg"></div>
                            </div>
                        </div>
                    </div>

                    <div class="chat">
                        <div id="chatContent"></div>

                        <form method="post" id="chatForm">
                            <select id="msgType">
                                <option value="#room">${main_1.default.languageManager.getValueForKey("GAME_CHAT_OPTION_ROOM")}</option>
                                <option value="#team">${main_1.default.languageManager.getValueForKey("GAME_CHAT_OPTION_TEAM")}</option>
                            </select>

                            <input type="text" id="chatMsg" maxlength="150" placeholder="${main_1.default.languageManager.getValueForKey("GAME_CHAT_MESSAGE")}"/>
                        </form>
                    </div>

                    <ul id="list_users"></ul>

                    <div id="history"></div>
                </div>
            </div>`;
    }
}
exports["default"] = GameScene;


/***/ }),

/***/ "./client/Scene/List/LoginScene.ts":
/*!*****************************************!*\
  !*** ./client/Scene/List/LoginScene.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Config_1 = __importDefault(__webpack_require__(/*! ../../Config/Config */ "./client/Config/Config.ts"));
const main_1 = __importDefault(__webpack_require__(/*! ../../main */ "./client/main.ts"));
const Scene_1 = __importDefault(__webpack_require__(/*! ../Scene */ "./client/Scene/Scene.ts"));
class LoginScene extends Scene_1.default {
    constructor(state) {
        super(state.name);
        this.state = {
            error: null,
            args: null,
            fakeLoginId: 0,
            content: "login",
            username: "",
            password: "",
            password_confirm: "",
            server: null
        };
    }
    setState(params) {
        this.onDestroy();
        for (let i in params) {
            this.state[i] = params[i];
        }
        this.render();
        this.onInitialized();
    }
    onWillInit() {
        super.onWillInit();
    }
    onInitialized() {
        super.onInitialized();
        const username = document.getElementById("username");
        username === null || username === void 0 ? void 0 : username.addEventListener("input", this.setUsername.bind(this));
        const password = document.getElementById("password");
        password === null || password === void 0 ? void 0 : password.addEventListener("input", this.setPassword.bind(this));
        const password_confirm = document.getElementById("password_confirm");
        password_confirm === null || password_confirm === void 0 ? void 0 : password_confirm.addEventListener("input", this.setPasswordConfirm.bind(this));
        const server = document.getElementById("server");
        server === null || server === void 0 ? void 0 : server.addEventListener("change", this.setServer.bind(this));
        const registerButton = document.getElementById("register");
        registerButton === null || registerButton === void 0 ? void 0 : registerButton.addEventListener("click", () => this.setContent("register"));
        const loginButton = document.getElementById("login");
        loginButton === null || loginButton === void 0 ? void 0 : loginButton.addEventListener("click", () => this.setContent("login"));
        const flagButton = document.getElementById("flag");
        flagButton === null || flagButton === void 0 ? void 0 : flagButton.addEventListener("click", () => this.setContent("language"));
        const flags = document.getElementsByClassName("flag_row");
        Array.from(flags).forEach(flagRow => {
            flagRow === null || flagRow === void 0 ? void 0 : flagRow.addEventListener("click", this.setActiveLanguage.bind(this));
        });
        const loginForm = document.getElementById("loginForm");
        loginForm === null || loginForm === void 0 ? void 0 : loginForm.addEventListener("submit", this.login.bind(this));
        const registerForm = document.getElementById("registerForm");
        registerForm === null || registerForm === void 0 ? void 0 : registerForm.addEventListener("submit", this.register.bind(this));
        /*
        const serverse = Application.regionServerManager.getServerById(this.state.server);
        if(serverse == null)
            return this.setState({error: "ACCOUNT_ERROR_OCCURED"});
        
        if(this.state.fakeLoginId == 0)
            Application.webSocketsManager.sendMsg("tryLogin", {username: this.state.username, password: this.state.password, server: this.state.server, serverClientId: serverse.clientId})
    */
    }
    setUsername(e) {
        this.state.username = e.target.value;
    }
    setPassword(e) {
        this.state.password = e.target.value;
    }
    setPasswordConfirm(e) {
        this.state.password_confirm = e.target.value;
    }
    setServer(e) {
        this.state.server = e.target.value;
    }
    onDestroy() {
        super.onDestroy();
        const username = document.getElementById("username");
        username === null || username === void 0 ? void 0 : username.removeEventListener("change", this.setUsername.bind(this), false);
        const password = document.getElementById("password");
        password === null || password === void 0 ? void 0 : password.removeEventListener("change", this.setPassword.bind(this), false);
        const password_confirm = document.getElementById("password_confirm");
        password_confirm === null || password_confirm === void 0 ? void 0 : password_confirm.removeEventListener("change", this.setPasswordConfirm.bind(this), false);
        const server = document.getElementById("server");
        server === null || server === void 0 ? void 0 : server.removeEventListener("change", this.setServer.bind(this), false);
        const registerButton = document.getElementById("register");
        registerButton === null || registerButton === void 0 ? void 0 : registerButton.removeEventListener("click", () => this.setContent("register"), false);
        const loginButton = document.getElementById("register");
        loginButton === null || loginButton === void 0 ? void 0 : loginButton.removeEventListener("click", () => this.setContent("login"), false);
        const flagButton = document.getElementById("register");
        flagButton === null || flagButton === void 0 ? void 0 : flagButton.removeEventListener("click", () => this.setContent("language"), false);
        const flags = document.getElementsByClassName("flag_row");
        Array.from(flags).forEach(flagRow => {
            flagRow === null || flagRow === void 0 ? void 0 : flagRow.removeEventListener("click", this.setActiveLanguage.bind(this), false);
        });
        const loginForm = document.getElementById("loginForm");
        loginForm === null || loginForm === void 0 ? void 0 : loginForm.removeEventListener("submit", this.login.bind(this), false);
        const registerForm = document.getElementById("registerForm");
        registerForm === null || registerForm === void 0 ? void 0 : registerForm.removeEventListener("submit", this.register.bind(this), false);
    }
    setActiveLanguage(e) {
        if (e.target == null || e.target.id == null)
            return;
        main_1.default.languageManager.setLanguage(e.target.id);
        this.setContent("login");
    }
    setContent(value) {
        if (value == "login" || value == "register") {
            this.state.username = "";
            this.state.password = "";
            this.state.password_confirm = "";
            this.state.error = "";
        }
        this.setState({ content: value });
    }
    login(e) {
        e.preventDefault();
        const server = main_1.default.regionServerManager.getServerById(this.state.server);
        if (server == null)
            return this.setState({ error: "ACCOUNT_ERROR_OCCURED" });
        main_1.default.webSocketsManager.sendMsg("tryLogin", { username: this.state.username, password: this.state.password, server: this.state.server, serverClientId: server.clientId });
    }
    register(e) {
        e.preventDefault();
        const server = main_1.default.regionServerManager.getServerById(this.state.server);
        if (server == null)
            return this.setState({ error: "ACCOUNT_ERROR_OCCURED" });
        main_1.default.webSocketsManager.sendMsg("tryRegister", { username: this.state.username, password: this.state.password, password_confirm: this.state.password_confirm, server: this.state.server, serverClientId: server.clientId });
    }
    renderAvaiableLanguage() {
        let content = ``;
        main_1.default.languageManager.getAvailableLanguages().forEach((language) => {
            content += `<img src="assets/images/flags/${language}.svg" class="flag_row" id="${language}">`;
        });
        return content;
    }
    renderServers() {
        let content = ``;
        main_1.default.regionServerManager.getAllServers().forEach((server) => {
            if (this.state.server == null)
                this.state.server = server.id;
            content += `<option value="${server.id}" ${this.state.server == server.id ? "selected" : null}>${main_1.default.languageManager.getValueForKey("ACCOUNT_SERVER", [server.id, server.ping])}</option>`;
        });
        return content;
    }
    renderError() {
        let error = ``;
        if (this.state.error) {
            /*
            this.state.fakeLoginId++;

            const serverse = Application.regionServerManager.getServerById(this.state.server);
            if(serverse != null)
                Application.webSocketsManager.sendMsg("tryLogin", {username: `${this.state.username}${this.state.fakeLoginId}`, password: this.state.password, server: this.state.server, serverClientId: serverse.clientId})
            */
            error = `<div class="error">${main_1.default.languageManager.getValueForKey(this.state.error, this.state.args)}</div>`;
        }
        return error;
    }
    renderContent() {
        switch (this.state.content) {
            case "login":
                return `<div class="login">
                    <img src="assets/images/logo.png" class="logo">
                    <div class="title">${main_1.default.languageManager.getValueForKey("ACCOUNT_LOGIN")}</div>

                    <div class="container">
                        ${this.renderError()}

                        <form method="post" id="loginForm">
                            <input type="text" id="username" placeholder="${main_1.default.languageManager.getValueForKey("ACCOUNT_USERNAME")}" value="${this.state.username}" maxlength="15"></input>
                            <input type="password" id="password" placeholder="${main_1.default.languageManager.getValueForKey("ACCOUNT_PASSWORD")}" value="${this.state.password}"></input>
                            <select id="server">
                                ${this.renderServers()}
                            </select>
                            <input type="submit" value="${main_1.default.languageManager.getValueForKey("ACCOUNT_LOGIN")}">
                        </form>

                        <div class="line">
                            <button id="register">${main_1.default.languageManager.getValueForKey("ACCOUNT_REGISTER")}</button>
                            <img src="assets/images/flags/${main_1.default.languageManager.getValueForKey("CODE")}.svg" class="flag" id="flag"/>
                        </div>
                    </div>
                </div>`;
            case "register":
                return `<div class="register">
                    <img src="assets/images/logo.png" class="logo">
                    <div class="title">${main_1.default.languageManager.getValueForKey("ACCOUNT_REGISTER")}</div>

                    <div class="container">
                        ${this.renderError()}

                        <form method="post" id="registerForm">
                            <input type="text" id="username" placeholder="${main_1.default.languageManager.getValueForKey("ACCOUNT_USERNAME")}" value="${this.state.username}" maxlength="15"></input>
                            <input type="password" id="password" placeholder="${main_1.default.languageManager.getValueForKey("ACCOUNT_PASSWORD")}" value="${this.state.password}"></input>
                            <input type="password" id="password_confirm" placeholder="${main_1.default.languageManager.getValueForKey("ACCOUNT_CONFIRM_PASSWORD")}" value="${this.state.password_confirm}"></input>
                            <select id="server">
                                ${this.renderServers()}
                            </select>
                            <input type="submit" value="${main_1.default.languageManager.getValueForKey("ACCOUNT_REGISTER")}">
                        </form>

                        <div class="line">
                            <button id="login">${main_1.default.languageManager.getValueForKey("ACCOUNT_LOGIN")}</button>
                            <img src="assets/images/flags/${main_1.default.languageManager.getValueForKey("CODE")}.svg" class="flag" id="flag"/>
                        </div>
                    </div>
                </div>`;
            case "language":
                return `<div class="language">
                    <img src="assets/images/logo.png" class="logo">
                    <div class="title">${main_1.default.languageManager.getValueForKey("ACCOUNT_LANGUAGE")}</div>

                    <div class="container">
                        <div class="flags">
                            ${this.renderAvaiableLanguage()}
                        </div>
                    </div>
                </div>`;
            default:
                return null;
        }
    }
    render() {
        if (this.app == null)
            return;
        this.app.innerHTML =
            `<div class="account">

                ${this.renderContent()}

                <div class="footer">${main_1.default.languageManager.getValueForKey("COPYRIGHT", [Config_1.default.NAME])}</div>
            </div>`;
    }
}
exports["default"] = LoginScene;


/***/ }),

/***/ "./client/Scene/List/MessageScene.ts":
/*!*******************************************!*\
  !*** ./client/Scene/List/MessageScene.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Config_1 = __importDefault(__webpack_require__(/*! ../../Config/Config */ "./client/Config/Config.ts"));
const Scene_1 = __importDefault(__webpack_require__(/*! ../Scene */ "./client/Scene/Scene.ts"));
class MessageScene extends Scene_1.default {
    constructor(state) {
        super(state.name);
        this.state = {
            message: state.params.message
        };
    }
    setState(params) {
        super.setState(params);
        for (let i in params) {
            this.state[i] = params[i];
        }
        this.render();
    }
    onWillInit() {
        super.onWillInit();
        document.title = Config_1.default.NAME;
    }
    onInitialized() {
        super.onInitialized();
    }
    onDestroy() {
        super.onDestroy();
    }
    render() {
        if (this.app == null)
            return;
        this.app.innerHTML =
            `<div class="loadingScreen">
                <img src="assets/images/logo.png">
                <div class="message">${this.state["message"]}</div>
            </div>`;
    }
}
exports["default"] = MessageScene;


/***/ }),

/***/ "./client/Scene/Scene.ts":
/*!*******************************!*\
  !*** ./client/Scene/Scene.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const main_1 = __importDefault(__webpack_require__(/*! ../main */ "./client/main.ts"));
class Scene {
    constructor(name) {
        this.name = name;
        this.app = document.getElementById("app");
        main_1.default.logger.sendLog("VERBOSE", `Initiliazing scene ${this.name}.`);
    }
    setState(params) {
    }
    onWillInit() {
        if (this.app == null)
            main_1.default.logger.sendLog("ERROR", "Impossible to find #app HTML element.");
    }
    onInitialized() { }
    onDestroy() {
        if (this.app != null)
            this.app.innerHTML = "";
    }
    render() { }
}
exports["default"] = Scene;


/***/ }),

/***/ "./client/Scene/SceneList.ts":
/*!***********************************!*\
  !*** ./client/Scene/SceneList.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SceneType = void 0;
const GameScene_1 = __importDefault(__webpack_require__(/*! ./List/GameScene */ "./client/Scene/List/GameScene.ts"));
const LoginScene_1 = __importDefault(__webpack_require__(/*! ./List/LoginScene */ "./client/Scene/List/LoginScene.ts"));
const MessageScene_1 = __importDefault(__webpack_require__(/*! ./List/MessageScene */ "./client/Scene/List/MessageScene.ts"));
exports.SceneType = {
    0: MessageScene_1.default,
    1: LoginScene_1.default,
    2: GameScene_1.default
};


/***/ }),

/***/ "./client/Scene/SceneManager.ts":
/*!**************************************!*\
  !*** ./client/Scene/SceneManager.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const main_1 = __importDefault(__webpack_require__(/*! ../main */ "./client/main.ts"));
const GameScene_1 = __importDefault(__webpack_require__(/*! ./List/GameScene */ "./client/Scene/List/GameScene.ts"));
const LoginScene_1 = __importDefault(__webpack_require__(/*! ./List/LoginScene */ "./client/Scene/List/LoginScene.ts"));
const MessageScene_1 = __importDefault(__webpack_require__(/*! ./List/MessageScene */ "./client/Scene/List/MessageScene.ts"));
const SceneList_1 = __webpack_require__(/*! ./SceneList */ "./client/Scene/SceneList.ts");
class SceneManager {
    constructor() {
        this.scene = null;
    }
    initScene(scene, params = {}) {
        if (this.scene instanceof SceneList_1.SceneType[scene])
            return this.scene.setState(params);
        if (this.scene != null) {
            this.scene.onDestroy();
            this.scene = null;
        }
        switch (scene) {
            case 0 /* SceneList.MessageScene */:
                {
                    this.scene = new MessageScene_1.default({
                        name: "MessageScene",
                        params: params
                    });
                    break;
                }
            case 1 /* SceneList.LoginScene */:
                {
                    this.scene = new LoginScene_1.default({
                        name: "LoginScene",
                        params: params
                    });
                    break;
                }
            case 2 /* SceneList.GameScene */:
                {
                    this.scene = new GameScene_1.default({
                        name: "GameScene",
                        params: params
                    });
                    break;
                }
            default:
                main_1.default.logger.sendLog("ERROR", `Impossible to load scene ${scene}.`);
                break;
        }
        if (this.scene != null) {
            this.scene.onWillInit();
            this.scene.render();
            this.scene.onInitialized();
        }
    }
}
exports["default"] = SceneManager;


/***/ }),

/***/ "./client/Settings/SettingsManager.ts":
/*!********************************************!*\
  !*** ./client/Settings/SettingsManager.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
class SettingsManager {
    constructor() {
        this.graphics = {
            zoom: 1.25,
            fps: 0
        };
        this.audio = {
            general: true,
            chat: true,
            game: true,
            notif: true
        };
        this.inputs = {
            up: ["ArrowUp"],
            down: ["ArrowDown"],
            left: ["ArrowLeft"],
            right: ["ArrowRight"],
            kick: ["KeyX", "Space"],
            toggle_chat: ["Enter", "NumpadEnter", "Tab"],
        };
    }
    init() {
        const graphicsStorage = localStorage.getItem("settings_graphics");
        if (graphicsStorage != null && JSON.parse(graphicsStorage))
            this.graphics = JSON.parse(graphicsStorage);
        const audioStorage = localStorage.getItem("settings_audio");
        if (audioStorage != null && JSON.parse(audioStorage))
            this.audio = JSON.parse(audioStorage);
        const inputs = localStorage.getItem("settings_inputs");
        if (inputs != null && JSON.parse(inputs))
            this.inputs = JSON.parse(inputs);
    }
    saveSettings(type) {
        switch (type) {
            case "graphics": {
                localStorage.setItem("settings_graphics", JSON.stringify(this.graphics));
                break;
            }
            case "audio": {
                localStorage.setItem("settings_audio", JSON.stringify(this.audio));
                break;
            }
            case "inputs": {
                localStorage.setItem("settings_inputs", JSON.stringify(this.inputs));
                break;
            }
        }
    }
    removeKey(type, value) {
        if (this.inputs[type] == null || !this.inputs[type].includes(value))
            return;
        this.inputs[type] = this.inputs[type].filter(function (key) {
            return key != value;
        });
        this.saveSettings("inputs");
    }
    setSettings(type, value, val) {
        switch (type) {
            case "graphics": {
                if (this.graphics[value] == null || val instanceof Number)
                    return;
                this.graphics[value] = val;
                this.saveSettings(type);
                break;
            }
            case "audio": {
                if (this.audio[value] == null || val instanceof Boolean)
                    return;
                this.audio[value] = val;
                this.saveSettings(type);
                break;
            }
            case "inputs": {
                if (this.inputs[value] == null || val instanceof String)
                    return;
                let contains = (this.inputs.up.includes(val) ||
                    this.inputs.down.includes(val) ||
                    this.inputs.left.includes(val) ||
                    this.inputs.right.includes(val) ||
                    this.inputs.kick.includes(val) ||
                    this.inputs.toggle_chat.includes(val));
                if (contains || val.startsWith("Digit") || val == "KeyP")
                    return;
                this.inputs[value].push(val);
                this.saveSettings(type);
                break;
            }
        }
    }
}
exports["default"] = SettingsManager;


/***/ }),

/***/ "./client/User/User.ts":
/*!*****************************!*\
  !*** ./client/User/User.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
class User {
    constructor(data) {
        this.id = data.id;
        this.username = data.username;
        this.rank = data.rank;
        this.avatar = data.avatar;
        this.coins = data.coins;
        this.items = data.items;
        this.friends = data.friends;
        this.currentServer = data.currentServer;
        this.currentRoom = null;
    }
    getFriendbyUsername(username) {
        let friendReturned = null;
        this.friends.forEach((friend) => {
            if (friend.username == username)
                friendReturned = friend;
        });
        return friendReturned;
    }
}
exports["default"] = User;


/***/ }),

/***/ "./client/Utils/Utils.ts":
/*!*******************************!*\
  !*** ./client/Utils/Utils.ts ***!
  \*******************************/
/***/ (() => {


String.prototype.supplant = function (o) {
    return this.replace(/{([^{}]*)}/g, function (a, b) {
        var r = o[b];
        return typeof r === 'string' || typeof r === 'number' ? r : a;
    });
};


/***/ }),

/***/ "./client/WebSockets/RegionServer/RegionServer.ts":
/*!********************************************************!*\
  !*** ./client/WebSockets/RegionServer/RegionServer.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pako_1 = __importDefault(__webpack_require__(/*! pako */ "./node_modules/pako/index.js"));
const Room_1 = __importDefault(__webpack_require__(/*! ../../Room/Room */ "./client/Room/Room.ts"));
const GameScene_1 = __importDefault(__webpack_require__(/*! ../../Scene/List/GameScene */ "./client/Scene/List/GameScene.ts"));
const main_1 = __importDefault(__webpack_require__(/*! ../../main */ "./client/main.ts"));
class RegionServer {
    constructor(data) {
        this.ws = null;
        this.id = data.id;
        this.ip = data.ip;
        this.port = data.port;
        this.clientId = null;
        this.ping = 0;
        this.pingDate = 0;
        this.intervalPing = null;
        this.getPong = true;
    }
    connect() {
        return new Promise((resolve, reject) => {
            const instance = this;
            this.ws = new WebSocket(`ws://${this.ip}:${this.port}`);
            this.ws.onclose = () => {
                if (instance.intervalPing != null)
                    clearInterval(instance.intervalPing);
                main_1.default.regionServerManager.destroyServer(instance.id);
                resolve(`Impossible to connect to server region [${instance.id}].`);
            };
            this.ws.onopen = () => {
                instance.intervalPing = setInterval(instance.sendPing.bind(instance), 1000);
            };
            this.ws.onmessage = (msg) => {
                if (msg == null || msg.data == null)
                    return;
                if (msg.data instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        var _a;
                        const arrayBuffer = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.result;
                        // Decompress the ArrayBuffer using Pako
                        processMessage(pako_1.default.inflate(new Uint8Array(arrayBuffer), { to: 'string' }));
                    };
                    reader.readAsArrayBuffer(msg.data);
                }
                else {
                    processMessage(pako_1.default.inflate(msg.data, { to: "string" }));
                }
            };
            const processMessage = (msg) => {
                const message = JSON.parse(msg.toString());
                switch (message.key) {
                    case "pong": {
                        instance.clientId = message.value.clientId;
                        const now = Date.now();
                        instance.ping = Date.now() - instance.pingDate;
                        instance.getPong = true;
                        resolve(`Region server [${instance.id}] loaded.`);
                        break;
                    }
                    case "roomInit": {
                        if (main_1.default.currentUser == null)
                            return;
                        main_1.default.currentUser.currentRoom = new Room_1.default(message.value);
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.initRoom(main_1.default.currentUser.currentRoom);
                        break;
                    }
                    case "playerJoin": {
                        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
                            return;
                        main_1.default.currentUser.currentRoom.playerJoin(message.value);
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.playerJoin(message.value, main_1.default.currentUser.currentRoom.currentPlayers.length);
                        if (main_1.default.settingsManager.audio.general && main_1.default.settingsManager.audio.game) {
                            const audio = main_1.default.resourceManager.resources["AUDIO_JOIN"].cloneNode();
                            audio.play();
                        }
                        break;
                    }
                    case "playerLeave": {
                        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
                            return;
                        main_1.default.currentUser.currentRoom.playerLeave(message.value);
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.playerLeave(message.value, main_1.default.currentUser.currentRoom.currentPlayers.length);
                        if (main_1.default.settingsManager.audio.general && main_1.default.settingsManager.audio.game) {
                            const audio = main_1.default.resourceManager.resources["AUDIO_LEAVE"].cloneNode();
                            audio.play();
                        }
                        break;
                    }
                    case "mapData": {
                        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
                            return;
                        main_1.default.currentUser.currentRoom.stadium = message.value;
                        break;
                    }
                    case "worldState": {
                        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
                            return;
                        main_1.default.currentUser.currentRoom.update(message.value);
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.update(main_1.default.currentUser.currentRoom);
                        break;
                    }
                    case "addHistory": {
                        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
                            return;
                        main_1.default.currentUser.currentRoom.history.push(message.value);
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.addHistory(message.value);
                        break;
                    }
                    case "gamePause": {
                        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
                            return;
                        if (message.value == false) {
                            if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                                main_1.default.sceneManager.scene.state.unpauseInterval = (3000 - this.ping);
                        }
                        break;
                    }
                    case "sound": {
                        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
                            return;
                        if (!main_1.default.settingsManager.audio.general || !main_1.default.settingsManager.audio.game)
                            return;
                        switch (message.value) {
                            case "kick": {
                                const audio = main_1.default.resourceManager.resources["AUDIO_KICK"].cloneNode();
                                audio.play();
                                break;
                            }
                            case "goal": {
                                main_1.default.resourceManager.resources["AUDIO_GOAL"].play();
                                main_1.default.resourceManager.resources["AUDIO_CROWD"].volume = 1;
                                main_1.default.resourceManager.resources["AUDIO_CROWD"].play();
                                for (let i = 20; i < 40; i++) {
                                    setTimeout(() => {
                                        main_1.default.resourceManager.resources["AUDIO_CROWD"].volume = ((40 - i) / 40) * 2;
                                    }, i * 100);
                                }
                                setTimeout(() => {
                                    main_1.default.resourceManager.resources["AUDIO_CROWD"].pause();
                                    main_1.default.resourceManager.resources["AUDIO_CROWD"].currentTime = 0;
                                }, 4000);
                                break;
                            }
                        }
                        break;
                    }
                    case "reorderPlayer": {
                        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
                            return;
                        main_1.default.currentUser.currentRoom.reorderPlayer(message.value);
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.refreshPickList();
                        break;
                    }
                    case "pickMode": {
                        if (main_1.default.currentUser == null || main_1.default.currentUser.currentRoom == null)
                            return;
                        main_1.default.currentUser.currentRoom.pickMode = message.value;
                        if (main_1.default.currentUser.currentRoom.pickMode == main_1.default.currentUser.id && main_1.default.settingsManager.audio.general && main_1.default.settingsManager.audio.notif) {
                            const audio = main_1.default.resourceManager.resources["AUDIO_NOTIF"].cloneNode();
                            audio.play();
                            break;
                        }
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default) {
                            main_1.default.sceneManager.scene.refreshPickList();
                            if (message.value != null)
                                main_1.default.sceneManager.scene.showMenu();
                        }
                        break;
                    }
                    case "hideMenu": {
                        if (main_1.default.currentUser == null)
                            return;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.hideMenu();
                        break;
                    }
                    case "chatMessage": {
                        if (main_1.default.currentUser == null)
                            return;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.newChat(message.value);
                        break;
                    }
                }
            };
        });
    }
    sendPing() {
        if (this.getPong == false)
            return;
        this.getPong = false;
        this.pingDate = Date.now();
        this.sendMsg("ping", this.ping);
    }
    sendMsg(key, value = null) {
        if (this.ws == null || this.ws.readyState !== WebSocket.OPEN)
            return main_1.default.logger.sendLog("ERROR", "Impossible to send message to region server, websockets are disconnect.");
        const message = JSON.stringify({ key: key, value: value });
        const compressedMessage = pako_1.default.deflate(message);
        this.ws.send(compressedMessage);
    }
    destroy() { }
}
exports["default"] = RegionServer;


/***/ }),

/***/ "./client/WebSockets/RegionServer/RegionServerManager.ts":
/*!***************************************************************!*\
  !*** ./client/WebSockets/RegionServer/RegionServerManager.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const main_1 = __importDefault(__webpack_require__(/*! ../../main */ "./client/main.ts"));
const RegionServer_1 = __importDefault(__webpack_require__(/*! ./RegionServer */ "./client/WebSockets/RegionServer/RegionServer.ts"));
class RegionServerManager {
    constructor() {
        this.regionServers = {};
    }
    getServerById(id) {
        for (let i in this.regionServers) {
            const regionServer = this.regionServers[i];
            if (regionServer.id == id)
                return regionServer;
        }
        return null;
    }
    initServer(data) {
        if (data.ip == null || this.getServerById(data.id) != null)
            return;
        const regionServer = new RegionServer_1.default(data);
        this.regionServers[regionServer.id] = regionServer;
        main_1.default.logger.sendLog("INFO", `Region server [${data.id}] loaded.`);
    }
    initAllServers() {
        return new Promise((resolve, reject) => {
            const listOfPromise = [];
            for (let i in this.regionServers) {
                listOfPromise.push(this.regionServers[i].connect());
            }
            Promise.all(listOfPromise).then(() => {
                resolve("All region servers loaded.");
            }).catch((e) => reject(e.toString()));
        });
    }
    destroyServer(id) {
        const regionServer = this.getServerById(id);
        if (regionServer == null)
            return;
        regionServer.destroy();
        delete this.regionServers[id];
        main_1.default.logger.sendLog("INFO", `Region server [${id}] unloaded.`);
    }
    getAllServers() {
        const servers = [];
        for (let i in this.regionServers) {
            const server = this.regionServers[i];
            servers.push({ id: server.id, ip: server.ip, port: server.port, ping: server.ping });
        }
        return servers.sort((a, b) => Number(a.ping) - Number(b.ping));
    }
}
exports["default"] = RegionServerManager;


/***/ }),

/***/ "./client/WebSockets/WebSocketsManager.ts":
/*!************************************************!*\
  !*** ./client/WebSockets/WebSocketsManager.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pako_1 = __importDefault(__webpack_require__(/*! pako */ "./node_modules/pako/index.js"));
const Config_1 = __importDefault(__webpack_require__(/*! ../Config/Config */ "./client/Config/Config.ts"));
const GameScene_1 = __importDefault(__webpack_require__(/*! ../Scene/List/GameScene */ "./client/Scene/List/GameScene.ts"));
const User_1 = __importDefault(__webpack_require__(/*! ../User/User */ "./client/User/User.ts"));
const main_1 = __importDefault(__webpack_require__(/*! ../main */ "./client/main.ts"));
class WebsocketManager {
    constructor() {
        this.ws = null;
    }
    init() {
        return new Promise((resolve, reject) => {
            const instance = this;
            main_1.default.sceneManager.initScene(0 /* SceneList.MessageScene */, {
                message: main_1.default.languageManager.getValueForKey('LOADING_CONNECTION_TO_MAIN_SERVER')
            });
            this.ws = new WebSocket(`ws://${Config_1.default.SERVER_HOST}:${Config_1.default.SERVER_PORT}`);
            this.ws.onclose = () => {
                main_1.default.logger.sendLog("ERROR", "Connection to server lost.");
                main_1.default.sceneManager.initScene(0 /* SceneList.MessageScene */, {
                    message: main_1.default.languageManager.getValueForKey('GENERIC_ERROR_CONNECTION_LOST')
                });
            };
            this.ws.onopen = () => {
                main_1.default.logger.sendLog("SUCCESS", "Connected to server.");
                instance.sendMsg("fetchingServers");
                main_1.default.sceneManager.initScene(0 /* SceneList.MessageScene */, {
                    message: main_1.default.languageManager.getValueForKey('LOADING_FETCHING_REGION_SERVERS')
                });
            };
            this.ws.onmessage = (msg) => {
                if (msg == null || msg.data == null)
                    return;
                if (msg.data instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        var _a;
                        const arrayBuffer = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.result;
                        // Decompress the ArrayBuffer using Pako
                        processMessage(pako_1.default.inflate(new Uint8Array(arrayBuffer), { to: 'string' }));
                    };
                    reader.readAsArrayBuffer(msg.data);
                }
                else {
                    processMessage(pako_1.default.inflate(msg.data, { to: "string" }));
                }
            };
            const processMessage = (msg) => {
                const message = JSON.parse(msg.toString());
                switch (message.key) {
                    case "getAllServers": {
                        message.value.forEach((server) => main_1.default.regionServerManager.initServer(server));
                        main_1.default.regionServerManager.initAllServers()
                            .then((message) => {
                            main_1.default.logger.sendLog("SUCCESS", message);
                            if (main_1.default.regionServerManager.getAllServers().length == 0)
                                return main_1.default.sceneManager.initScene(0 /* SceneList.MessageScene */, {
                                    message: main_1.default.languageManager.getValueForKey('GENERIC_ERROR_NO_SERVER_AVAILABLE')
                                });
                            main_1.default.sceneManager.initScene(1 /* SceneList.LoginScene */);
                        })
                            .catch((e) => {
                            main_1.default.logger.sendLog("ERROR", e.toString());
                            main_1.default.sceneManager.initScene(0 /* SceneList.MessageScene */, {
                                message: main_1.default.languageManager.getValueForKey('GENERIC_ERROR_SERVERS')
                            });
                        });
                        break;
                    }
                    case "errorLogin": {
                        main_1.default.sceneManager.initScene(1 /* SceneList.LoginScene */, {
                            error: message.value.key != null ? message.value.key : message.value,
                            args: message.value.args != null ? message.value.args : []
                        });
                        break;
                    }
                    case "disconnect": {
                        main_1.default.currentUser = null;
                        main_1.default.sceneManager.initScene(0 /* SceneList.MessageScene */, {
                            message: main_1.default.languageManager.getValueForKey(message.value.key, message.value.params)
                        });
                        break;
                    }
                    case "logged": {
                        main_1.default.currentUser = new User_1.default(message.value);
                        main_1.default.sceneManager.initScene(2 /* SceneList.GameScene */, {
                            currentUser: main_1.default.currentUser
                        });
                        break;
                    }
                    case "chatMessage": {
                        if (main_1.default.currentUser == null)
                            return;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.newChat(message.value);
                        break;
                    }
                    case "profileData": {
                        if (main_1.default.currentUser == null)
                            return;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.profileData(message.value);
                        break;
                    }
                    case "friendsData": {
                        if (main_1.default.currentUser == null)
                            return;
                        main_1.default.currentUser.friends = message.value;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.reloadFriends();
                        break;
                    }
                    case "shopData": {
                        if (main_1.default.currentUser == null)
                            return;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.shopData(message.value);
                        break;
                    }
                    case "shopItems": {
                        if (main_1.default.currentUser == null)
                            return;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.shopDataItems(message.value);
                        break;
                    }
                    case "avatarUpdate": {
                        if (main_1.default.currentUser == null)
                            return;
                        main_1.default.currentUser.avatar = message.value;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.updateAvatar();
                        break;
                    }
                    case "rankUpdate": {
                        if (main_1.default.currentUser == null)
                            return;
                        main_1.default.currentUser.rank = message.value;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.renderMenu();
                        break;
                    }
                    case "coins": {
                        if (main_1.default.currentUser == null)
                            return;
                        main_1.default.currentUser.coins = message.value;
                        break;
                    }
                    case "addItem": {
                        if (main_1.default.currentUser == null)
                            return;
                        main_1.default.currentUser.items.push(message.value);
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.refreshShop();
                        break;
                    }
                    case "leaderboardData": {
                        if (main_1.default.currentUser == null)
                            return;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.setLeaderboardData(message.value);
                        break;
                    }
                    case "adminAlert": {
                        if (main_1.default.currentUser == null)
                            return;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.renderAdminAlert(message.value);
                        break;
                    }
                    case "adminData": {
                        if (main_1.default.currentUser == null)
                            return;
                        if (main_1.default.sceneManager.scene instanceof GameScene_1.default)
                            main_1.default.sceneManager.scene.renderAdmin(message.value);
                        break;
                    }
                }
            };
        });
    }
    sendMsg(key, value = null) {
        if (this.ws == null || this.ws.readyState !== WebSocket.OPEN)
            return main_1.default.logger.sendLog("ERROR", "Impossible to send message to server, websockets are disconnect.");
        const message = JSON.stringify({ key: key, value: value });
        const compressedMessage = pako_1.default.deflate(message);
        this.ws.send(compressedMessage);
    }
}
exports["default"] = WebsocketManager;


/***/ }),

/***/ "./client/main.ts":
/*!************************!*\
  !*** ./client/main.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(/*! ./Utils/Utils */ "./client/Utils/Utils.ts");
const Logger_1 = __importDefault(__webpack_require__(/*! ../shared/Logger/Logger */ "./shared/Logger/Logger.ts"));
const LanguageManager_1 = __importDefault(__webpack_require__(/*! ./Language/LanguageManager */ "./client/Language/LanguageManager.ts"));
const SceneManager_1 = __importDefault(__webpack_require__(/*! ./Scene/SceneManager */ "./client/Scene/SceneManager.ts"));
const Config_1 = __importDefault(__webpack_require__(/*! ./Config/Config */ "./client/Config/Config.ts"));
const ResourceManager_1 = __importDefault(__webpack_require__(/*! ./Ressource/ResourceManager */ "./client/Ressource/ResourceManager.ts"));
const SettingsManager_1 = __importDefault(__webpack_require__(/*! ./Settings/SettingsManager */ "./client/Settings/SettingsManager.ts"));
const WebSocketsManager_1 = __importDefault(__webpack_require__(/*! ./WebSockets/WebSocketsManager */ "./client/WebSockets/WebSocketsManager.ts"));
const RegionServerManager_1 = __importDefault(__webpack_require__(/*! ./WebSockets/RegionServer/RegionServerManager */ "./client/WebSockets/RegionServer/RegionServerManager.ts"));
const GameScene_1 = __importDefault(__webpack_require__(/*! ./Scene/List/GameScene */ "./client/Scene/List/GameScene.ts"));
let Application;
class App {
    constructor() {
        this.logger = new Logger_1.default();
        this.languageManager = new LanguageManager_1.default();
        this.sceneManager = new SceneManager_1.default();
        this.resourceManager = new ResourceManager_1.default();
        this.webSocketsManager = new WebSocketsManager_1.default();
        this.regionServerManager = new RegionServerManager_1.default();
        this.settingsManager = new SettingsManager_1.default();
        this.currentUser = null;
        this.lastCall = performance.now();
        this.elapsed = 0; // Initialize elapsed to 0
        this.elapsedThen = performance.now(); // Corrected variable name
        window.requestAnimationFrame(this.update.bind(this));
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.languageManager.init();
            this.settingsManager.init();
            this.sceneManager.initScene(0 /* SceneList.MessageScene */, {
                message: Application.languageManager.getValueForKey('LOADING_MESSAGE', [Config_1.default.NAME])
            });
            let messageLoading = yield this.resourceManager.init();
            Application.logger.sendLog("SUCCESS", messageLoading);
            yield this.webSocketsManager.init();
        });
    }
    update() {
        const now = performance.now();
        this.elapsed = now - this.elapsedThen;
        if (this.settingsManager.graphics.fps != 0 && this.elapsed < (1000 / this.settingsManager.graphics.fps)) {
            window.requestAnimationFrame(this.update.bind(this));
            return;
        }
        if (this.settingsManager.graphics.fps != 0)
            this.elapsedThen = now - (this.elapsed % (1000 / this.settingsManager.graphics.fps));
        const delta = (now - this.lastCall) / 1000;
        this.lastCall = now;
        if (this.sceneManager.scene instanceof GameScene_1.default) {
            this.sceneManager.scene.renderGame(delta);
            this.sceneManager.scene.setFps(Math.round(1 / delta));
        }
        window.requestAnimationFrame(this.update.bind(this));
    }
}
Application = new App();
exports["default"] = Application;
window.addEventListener("load", (event) => {
    Application.init().catch((e) => Application.logger.sendCriticalError(e.toString()));
});


/***/ }),

/***/ "./shared/Base/Base.ts":
/*!*****************************!*\
  !*** ./shared/Base/Base.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Base = void 0;
exports.Base = {
    hockey: {
        bg_color: 'rgb(85, 85, 85)',
        border_color: 'rgb(233,204,110)',
    },
    grass: {
        bg_color: 'rgb(113,140,90)',
        border_color: 'rgb(199,230,189)',
    },
    segment_color: 'rgb(0,0,0)',
    playerPhysics: {
        radius: 15,
        bCoef: 0.5,
        invMass: 0.5,
        damping: 0.96,
        acceleration: 0.1,
        kickingAcceleration: 0.07,
        kickingDamping: 0.96,
        kickStrength: 5,
        pos: [0, 0],
        cMask: ['all'],
        cGroup: [''],
    },
    ballPhysics: {
        radius: 10,
        bCoef: 0.5,
        invMass: 1,
        damping: 0.99,
        color: 'FFFFFF',
        pos: [0, 0],
        cMask: ['all'],
        cGroup: ['ball'],
    },
    discPhysics: {
        radius: 10,
        bCoef: 0.5,
        invMass: 0,
        damping: 0.99,
        color: 'rgb(255,255,255)',
        cMask: ['all'],
        cGroup: ['all'],
    },
    segmentPhysics: {
        curve: 0,
        bCoef: 1,
        cGroup: ['wall'],
        cMask: ['all'],
    },
    planePhysics: {
        bCoef: 1,
        cGroup: ['wall'],
        cMask: ['all'],
    },
    vertexPhysics: {
        bCoef: 1,
        cGroup: ['wall'],
        cMask: ['all'],
    },
    collisionFlags: {
        all: 63,
        ball: 1,
        blue: 4,
        blueKO: 16,
        c0: 268435456,
        c1: 536870912,
        c2: 1073741824,
        c3: -2147483648,
        kick: 64,
        red: 2,
        redKO: 8,
        score: 128,
        wall: 32,
    }
};


/***/ }),

/***/ "./shared/Color/Color.ts":
/*!*******************************!*\
  !*** ./shared/Color/Color.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = {
    ROOM_ANNOUNCEMENT: "#db8822",
    FRIEND: "#28b34d",
    ERROR: "#b92626"
};


/***/ }),

/***/ "./shared/Elo/Elo.ts":
/*!***************************!*\
  !*** ./shared/Elo/Elo.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getElo = void 0;
const getElo = function (elo) {
    switch (true) {
        case (elo > 2000):
            return { name: "GAME_ELO_CHALLENGER", value: 0 };
        case (elo > 1900):
            return { name: "GAME_ELO_CHAMPION", value: 5 };
        case (elo > 1800):
            return { name: "GAME_ELO_CHAMPION", value: 4 };
        case (elo > 1700):
            return { name: "GAME_ELO_CHAMPION", value: 3 };
        case (elo > 1600):
            return { name: "GAME_ELO_CHAMPION", value: 2 };
        case (elo > 1500):
            return { name: "GAME_ELO_CHAMPION", value: 1 };
        case (elo > 1400):
            return { name: "GAME_ELO_DIAMOND", value: 5 };
        case (elo > 1300):
            return { name: "GAME_ELO_DIAMOND", value: 4 };
        case (elo > 1200):
            return { name: "GAME_ELO_DIAMOND", value: 3 };
        case (elo > 1100):
            return { name: "GAME_ELO_DIAMOND", value: 2 };
        case (elo > 1000):
            return { name: "GAME_ELO_DIAMOND", value: 1 };
        case (elo > 900):
            return { name: "GAME_ELO_PLATINIUM", value: 5 };
        case (elo > 850):
            return { name: "GAME_ELO_PLATINIUM", value: 4 };
        case (elo > 800):
            return { name: "GAME_ELO_PLATINIUM", value: 3 };
        case (elo > 750):
            return { name: "GAME_ELO_PLATINIUM", value: 2 };
        case (elo > 700):
            return { name: "GAME_ELO_PLATINIUM", value: 1 };
        case (elo > 650):
            return { name: "GAME_ELO_GOLD", value: 5 };
        case (elo > 600):
            return { name: "GAME_ELO_GOLD", value: 4 };
        case (elo > 550):
            return { name: "GAME_ELO_GOLD", value: 3 };
        case (elo > 500):
            return { name: "GAME_ELO_GOLD", value: 2 };
        case (elo > 450):
            return { name: "GAME_ELO_GOLD", value: 1 };
        case (elo > 400):
            return { name: "GAME_ELO_BRONZE", value: 5 };
        case (elo > 350):
            return { name: "GAME_ELO_BRONZE", value: 4 };
        case (elo > 300):
            return { name: "GAME_ELO_BRONZE", value: 3 };
        case (elo > 250):
            return { name: "GAME_ELO_BRONZE", value: 2 };
        case (elo > 200):
            return { name: "GAME_ELO_BRONZE", value: 1 };
        case (elo > 150):
            return { name: "GAME_ELO_IRON", value: 5 };
        case (elo > 100):
            return { name: "GAME_ELO_IRON", value: 4 };
        case (elo > 50):
            return { name: "GAME_ELO_IRON", value: 3 };
        case (elo > 25):
            return { name: "GAME_ELO_IRON", value: 2 };
        default:
            return { name: "GAME_ELO_IRON", value: 1 };
    }
};
exports.getElo = getElo;


/***/ }),

/***/ "./shared/Level/Level.ts":
/*!*******************************!*\
  !*** ./shared/Level/Level.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLevel = void 0;
const getLevel = function (xp) {
    return Math.floor((Math.sqrt(100 * (2 * xp + 25)) + 50) / 100);
};
exports.getLevel = getLevel;


/***/ }),

/***/ "./shared/Logger/LogLevel.ts":
/*!***********************************!*\
  !*** ./shared/Logger/LogLevel.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const LogLevel = {
    INFO: {
        level: 0,
        name: "INFO",
        bgColor: "\x1b[44m",
        bgWebColor: "#19689B"
    },
    WARNING: {
        level: 0,
        name: "WARNING",
        bgColor: "\x1b[43m",
        bgWebColor: "#CF7E0F"
    },
    ERROR: {
        level: 0,
        name: "ERROR",
        bgColor: "\x1b[41m",
        bgWebColor: "#AF1B1B"
    },
    CRITICAL_ERROR: {
        level: 0,
        name: "CRITICAL ERROR",
        bgColor: "\x1b[41m",
        bgWebColor: "#AF1B1B"
    },
    SUCCESS: {
        level: 0,
        name: "SUCCESS",
        bgColor: "\x1b[42m",
        bgWebColor: "#167C43"
    },
    DEBUG: {
        level: 1,
        name: "DEBUG",
        bgColor: "\x1b[46m",
        bgWebColor: "#951D8A"
    },
    VERBOSE: {
        level: 2,
        name: "VERBOSE",
        bgColor: "\x1b[45m",
        bgWebColor: "#918D12"
    }
};
exports["default"] = LogLevel;


/***/ }),

/***/ "./shared/Logger/Logger.ts":
/*!*********************************!*\
  !*** ./shared/Logger/Logger.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LogLevel_1 = __importDefault(__webpack_require__(/*! ./LogLevel */ "./shared/Logger/LogLevel.ts"));
class Logger {
    sendLog(logKey, message) {
        if (typeof window === 'undefined')
            console.log(LogLevel_1.default[logKey].bgColor, LogLevel_1.default[logKey].name, "\x1b[0m", message);
        else
            console.log(`%c ${LogLevel_1.default[logKey].name} %c ${message}`, `background-color: ${LogLevel_1.default[logKey].bgWebColor}; color: #FFF; font-weight: bold`, `background-color: inherit; color: inherit`);
    }
    sendCriticalError(message) {
        this.sendLog("CRITICAL_ERROR", message);
        if (typeof window === 'undefined')
            process.exit;
    }
}
exports["default"] = Logger;


/***/ }),

/***/ "./shared/RoomState/RoomState.ts":
/*!***************************************!*\
  !*** ./shared/RoomState/RoomState.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoomState = void 0;
var RoomState;
(function (RoomState) {
    RoomState[RoomState["KICK_OFF_RESET"] = 0] = "KICK_OFF_RESET";
    RoomState[RoomState["PAUSE"] = 1] = "PAUSE";
    RoomState[RoomState["UNPAUSE"] = 2] = "UNPAUSE";
    RoomState[RoomState["PLAY"] = 3] = "PLAY";
    RoomState[RoomState["GOAL_SCORE"] = 4] = "GOAL_SCORE";
    RoomState[RoomState["GAME_ENDED"] = 5] = "GAME_ENDED";
})(RoomState || (exports.RoomState = RoomState = {}));


/***/ }),

/***/ "./shared/ShareableData/ShareableData.ts":
/*!***********************************************!*\
  !*** ./shared/ShareableData/ShareableData.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
class ShareableData {
    constructor(ts, p) {
        this.timestamp = ts;
        this.shareableData = p;
    }
}
exports["default"] = ShareableData;


/***/ }),

/***/ "./shared/Team/Team.ts":
/*!*****************************!*\
  !*** ./shared/Team/Team.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const Team = {
    SPECTATORS: {
        id: 0,
        name: "spectators",
        color: '#FFF',
        cGroup: 0,
    },
    RED: {
        id: 1,
        name: "red",
        color: '#bd3838',
        cGroup: 2,
    },
    BLUE: {
        id: 2,
        name: "blue",
        color: '#136eac',
        cGroup: 4,
    }
};
exports["default"] = Team;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./client/main.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDYTs7QUFFYixRQUFRLHFDQUFxQyxFQUFFLG1CQUFPLENBQUMseURBQWU7O0FBRXRFLFFBQVEsdUNBQXVDLEVBQUUsbUJBQU8sQ0FBQyx5REFBZTs7QUFFeEUsa0JBQWtCLG1CQUFPLENBQUMsdUVBQXNCOztBQUVoRCxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHdCQUF3Qjs7Ozs7Ozs7Ozs7QUNqQlg7OztBQUdiLHFCQUFxQixtQkFBTyxDQUFDLCtEQUFnQjtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQywrREFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsaUVBQWlCO0FBQzlDLHFCQUFxQixtQkFBTyxDQUFDLGlFQUFpQjtBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQywrREFBZ0I7O0FBRTdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsbUVBQWtCOztBQUU5Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWU7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsbUJBQW1CO0FBQ25CLG1IQUFzRDs7Ozs7Ozs7Ozs7QUMzWHpDOzs7QUFHYixxQkFBcUIsbUJBQU8sQ0FBQywrREFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsK0RBQWdCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLGlFQUFpQjtBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyxpRUFBaUI7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsK0RBQWdCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLGlFQUFpQjs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxtRUFBa0I7O0FBRTlCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIs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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2Qix1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QiwwQ0FBMEM7QUFDMUM7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFGQUFxRixFQUFFLHVDQUF1QyxHQUFHLGFBQWE7QUFDckw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrQ0FBK0M7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0RBQWtEO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCLFFBQVEsdUJBQXVCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9FQUFvRTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFFQUFxRSxnQ0FBZ0Msd0NBQXdDO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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VUFDQTtVQUNBOzs7O1VFdEJBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwid2VicGFjazovL25vZGViYWxsLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwid2VicGFjazovL25vZGViYWxsLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwid2VicGFjazovL25vZGViYWxsLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovL25vZGViYWxsLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwid2VicGFjazovL25vZGViYWxsLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwid2VicGFjazovL25vZGViYWxsLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwid2VicGFjazovL25vZGViYWxsLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9jbGllbnQvQ29uZmlnL0NvbmZpZy50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL2NsaWVudC9Db25maWcvUmVzb3VyY2VzLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vY2xpZW50L0xhbmd1YWdlL0xhbmd1YWdlTGlzdC50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL2NsaWVudC9MYW5ndWFnZS9MYW5ndWFnZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9jbGllbnQvTGFuZ3VhZ2UvTGlzdC9FTi50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL2NsaWVudC9MYW5ndWFnZS9MaXN0L0ZSLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vY2xpZW50L1Jlc3NvdXJjZS9SZXNvdXJjZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9jbGllbnQvUm9vbS9Sb29tLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vY2xpZW50L1NjZW5lL0xpc3QvR2FtZVNjZW5lLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vY2xpZW50L1NjZW5lL0xpc3QvTG9naW5TY2VuZS50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL2NsaWVudC9TY2VuZS9MaXN0L01lc3NhZ2VTY2VuZS50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL2NsaWVudC9TY2VuZS9TY2VuZS50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL2NsaWVudC9TY2VuZS9TY2VuZUxpc3QudHMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9jbGllbnQvU2NlbmUvU2NlbmVNYW5hZ2VyLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vY2xpZW50L1NldHRpbmdzL1NldHRpbmdzTWFuYWdlci50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL2NsaWVudC9Vc2VyL1VzZXIudHMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9jbGllbnQvVXRpbHMvVXRpbHMudHMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9jbGllbnQvV2ViU29ja2V0cy9SZWdpb25TZXJ2ZXIvUmVnaW9uU2VydmVyLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vY2xpZW50L1dlYlNvY2tldHMvUmVnaW9uU2VydmVyL1JlZ2lvblNlcnZlck1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9jbGllbnQvV2ViU29ja2V0cy9XZWJTb2NrZXRzTWFuYWdlci50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL2NsaWVudC9tYWluLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vc2hhcmVkL0Jhc2UvQmFzZS50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL3NoYXJlZC9Db2xvci9Db2xvci50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL3NoYXJlZC9FbG8vRWxvLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vc2hhcmVkL0xldmVsL0xldmVsLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vc2hhcmVkL0xvZ2dlci9Mb2dMZXZlbC50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC8uL3NoYXJlZC9Mb2dnZXIvTG9nZ2VyLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vc2hhcmVkL1Jvb21TdGF0ZS9Sb29tU3RhdGUudHMiLCJ3ZWJwYWNrOi8vbm9kZWJhbGwvLi9zaGFyZWQvU2hhcmVhYmxlRGF0YS9TaGFyZWFibGVEYXRhLnRzIiwid2VicGFjazovL25vZGViYWxsLy4vc2hhcmVkL1RlYW0vVGVhbS50cyIsIndlYnBhY2s6Ly9ub2RlYmFsbC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9ub2RlYmFsbC93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL25vZGViYWxsL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9ub2RlYmFsbC93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVG9wIGxldmVsIGZpbGUgaXMganVzdCBhIG1peGluIG9mIHN1Ym1vZHVsZXMgJiBjb25zdGFudHNcbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEZWZsYXRlLCBkZWZsYXRlLCBkZWZsYXRlUmF3LCBnemlwIH0gPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG5cbmNvbnN0IHsgSW5mbGF0ZSwgaW5mbGF0ZSwgaW5mbGF0ZVJhdywgdW5nemlwIH0gPSByZXF1aXJlKCcuL2xpYi9pbmZsYXRlJyk7XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbm1vZHVsZS5leHBvcnRzLmd6aXAgPSBnemlwO1xubW9kdWxlLmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xubW9kdWxlLmV4cG9ydHMudW5nemlwID0gdW5nemlwO1xubW9kdWxlLmV4cG9ydHMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmNvbnN0IHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG5jb25zdCB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xuY29uc3Qgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG5jb25zdCBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbmNvbnN0IFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSCwgWl9TWU5DX0ZMVVNILCBaX0ZVTExfRkxVU0gsIFpfRklOSVNILFxuICBaX09LLCBaX1NUUkVBTV9FTkQsXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgWl9ERUZBVUxUX1NUUkFURUdZLFxuICBaX0RFRkxBVEVEXG59ID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiBjb25zdCBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGxldCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIGxldCBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBmbHVzaF9tb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdFxuICogaGF2ZSBgZmx1c2hfbW9kZWAgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nXG4gKiBidWZmZXJzIGFuZCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIIDogWl9OT19GTFVTSDtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhdmFpbF9vdXQgPiA2IHRvIGF2b2lkIHJlcGVhdGluZyBtYXJrZXJzXG4gICAgaWYgKChfZmx1c2hfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIIHx8IF9mbHVzaF9tb2RlID09PSBaX0ZVTExfRkxVU0gpICYmIHN0cm0uYXZhaWxfb3V0IDw9IDYpIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcblxuICAgIC8vIEVuZGVkID0+IGZsdXNoIGFuZCBmaW5pc2hcbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQpIHtcbiAgICAgIGlmIChzdHJtLm5leHRfb3V0ID4gMCkge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gc3RhdHVzID09PSBaX09LO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGlmIG91dCBidWZmZXIgZnVsbFxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggaWYgcmVxdWVzdGVkIGFuZCBoYXMgZGF0YVxuICAgIGlmIChfZmx1c2hfbW9kZSA+IDAgJiYgc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5KTogb3V0cHV0IGRhdGEuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xubW9kdWxlLmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG5tb2R1bGUuZXhwb3J0cy5jb25zdGFudHMgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuY29uc3QgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbmNvbnN0IHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG5jb25zdCBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbmNvbnN0IG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xuY29uc3QgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbmNvbnN0IEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0gsIFpfRklOSVNILFxuICBaX09LLCBaX1NUUkVBTV9FTkQsIFpfTkVFRF9ESUNULCBaX1NUUkVBTV9FUlJPUiwgWl9EQVRBX0VSUk9SLCBaX01FTV9FUlJPUlxufSA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqIGNvbnN0IGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDEwMjQgKiA2NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgY29uc3Qgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyKTogaW5wdXQgZGF0YVxuICogLSBmbHVzaF9tb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFXG4gKiAgIGZsdXNoIG1vZGVzLiBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCxcbiAqICAgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gSWYgZW5kIG9mIHN0cmVhbSBkZXRlY3RlZCxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dIHdpbGwgYmUgY2FsbGVkLlxuICpcbiAqIGBmbHVzaF9tb2RlYCBpcyBub3QgbmVlZGVkIGZvciBub3JtYWwgb3BlcmF0aW9uLCBiZWNhdXNlIGVuZCBvZiBzdHJlYW1cbiAqIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkuIFlvdSBtYXkgdHJ5IHRvIHVzZSBpdCBmb3IgYWR2YW5jZWQgdGhpbmdzLCBidXRcbiAqIHRoaXMgZnVuY3Rpb25hbGl0eSB3YXMgbm90IHRlc3RlZC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmbHVzaF9tb2RlKSB7XG4gIGNvbnN0IHN0cm0gPSB0aGlzLnN0cm07XG4gIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIGNvbnN0IGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGUsIGxhc3RfYXZhaWxfb3V0O1xuXG4gIGlmICh0aGlzLmVuZGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIIDogWl9OT19GTFVTSDtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGZvciAoOzspIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpO1xuXG4gICAgICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBaX0RBVEFfRVJST1IpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBjb2RlIHdpdGggbW9yZSB2ZXJib3NlXG4gICAgICAgIHN0YXR1cyA9IFpfTkVFRF9ESUNUO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNraXAgc255YyBtYXJrZXJzIGlmIG1vcmUgZGF0YSBmb2xsb3dzIGFuZCBub3QgcmF3IG1vZGVcbiAgICB3aGlsZSAoc3RybS5hdmFpbF9pbiA+IDAgJiZcbiAgICAgICAgICAgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQgJiZcbiAgICAgICAgICAgc3RybS5zdGF0ZS53cmFwID4gMCAmJlxuICAgICAgICAgICBkYXRhW3N0cm0ubmV4dF9pbl0gIT09IDApXG4gICAge1xuICAgICAgemxpYl9pbmZsYXRlLmluZmxhdGVSZXNldChzdHJtKTtcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBaX1NUUkVBTV9FUlJPUjpcbiAgICAgIGNhc2UgWl9EQVRBX0VSUk9SOlxuICAgICAgY2FzZSBaX05FRURfRElDVDpcbiAgICAgIGNhc2UgWl9NRU1fRVJST1I6XG4gICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZW1lbWJlciByZWFsIGBhdmFpbF9vdXRgIHZhbHVlLCBiZWNhdXNlIHdlIG1heSBwYXRjaCBvdXQgYnVmZmVyIGNvbnRlbnRcbiAgICAvLyB0byBhbGlnbiB1dGY4IHN0cmluZ3MgYm91bmRhcmllcy5cbiAgICBsYXN0X2F2YWlsX291dCA9IHN0cm0uYXZhaWxfb3V0O1xuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBsZXQgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICBsZXQgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIGxldCB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbCAmIHJlYWxpZ24gY291bnRlcnNcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHN0cm0ub3V0cHV0LnNldChzdHJtLm91dHB1dC5zdWJhcnJheShuZXh0X291dF91dGY4LCBuZXh0X291dF91dGY4ICsgdGFpbCksIDApO1xuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5sZW5ndGggPT09IHN0cm0ubmV4dF9vdXQgPyBzdHJtLm91dHB1dCA6IHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE11c3QgcmVwZWF0IGl0ZXJhdGlvbiBpZiBvdXQgYnVmZmVyIGlzIGZ1bGxcbiAgICBpZiAoc3RhdHVzID09PSBaX09LICYmIGxhc3RfYXZhaWxfb3V0ID09PSAwKSBjb250aW51ZTtcblxuICAgIC8vIEZpbmFsaXplIGlmIGVuZCBvZiBzdHJlYW0gcmVhY2hlZC5cbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQpIHtcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBlYWNoIGNodW5rIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXIpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpO1xuICogY29uc3QgaW5wdXQgPSBwYWtvLmRlZmxhdGUobmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSkpO1xuICogbGV0IG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKSB7XG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0KTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbm1vZHVsZS5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbm1vZHVsZS5leHBvcnRzLnVuZ3ppcCA9IGluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5jb25zdGFudHMgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuY29uc3QgX2hhcyA9IChvYmosIGtleSkgPT4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICBjb25zdCBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbm1vZHVsZS5leHBvcnRzLmZsYXR0ZW5DaHVua3MgPSAoY2h1bmtzKSA9PiB7XG4gIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICBsZXQgbGVuID0gMDtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGpvaW4gY2h1bmtzXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IGNodW5rID0gY2h1bmtzW2ldO1xuICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbmxldCBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxuY29uc3QgX3V0ZjhsZW4gPSBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbm1vZHVsZS5leHBvcnRzLnN0cmluZzJidWYgPSAoc3RyKSA9PiB7XG4gIGlmICh0eXBlb2YgVGV4dEVuY29kZXIgPT09ICdmdW5jdGlvbicgJiYgVGV4dEVuY29kZXIucHJvdG90eXBlLmVuY29kZSkge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbiAgfVxuXG4gIGxldCBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyXG5jb25zdCBidWYyYmluc3RyaW5nID0gKGJ1ZiwgbGVuKSA9PiB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWYubGVuZ3RoID09PSBsZW4gPyBidWYgOiBidWYuc3ViYXJyYXkoMCwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMuYnVmMnN0cmluZyA9IChidWYsIG1heCkgPT4ge1xuICBjb25zdCBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICBpZiAodHlwZW9mIFRleHREZWNvZGVyID09PSAnZnVuY3Rpb24nICYmIFRleHREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1Zi5zdWJhcnJheSgwLCBtYXgpKTtcbiAgfVxuXG4gIGxldCBpLCBvdXQ7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgY29uc3QgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBsZXQgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGxldCBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5tb2R1bGUuZXhwb3J0cy51dGY4Ym9yZGVyID0gKGJ1ZiwgbWF4KSA9PiB7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgbGV0IHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IGFkbGVyMzIgPSAoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgbGV0IHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIFpfTUVNX0VSUk9SOiAgICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5jb25zdCBtYWtlVGFibGUgPSAoKSA9PiB7XG4gIGxldCBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufTtcblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbmNvbnN0IGNyY1RhYmxlID0gbmV3IFVpbnQzMkFycmF5KG1ha2VUYWJsZSgpKTtcblxuXG5jb25zdCBjcmMzMiA9IChjcmMsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgY29uc3QgdCA9IGNyY1RhYmxlO1xuICBjb25zdCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAobGV0IGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgeyBfdHJfaW5pdCwgX3RyX3N0b3JlZF9ibG9jaywgX3RyX2ZsdXNoX2Jsb2NrLCBfdHJfdGFsbHksIF90cl9hbGlnbiB9ID0gcmVxdWlyZSgnLi90cmVlcycpO1xuY29uc3QgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuY29uc3QgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbmNvbnN0IG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0gsIFpfUEFSVElBTF9GTFVTSCwgWl9GVUxMX0ZMVVNILCBaX0ZJTklTSCwgWl9CTE9DSyxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELCBaX1NUUkVBTV9FUlJPUiwgWl9EQVRBX0VSUk9SLCBaX0JVRl9FUlJPUixcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICBaX0ZJTFRFUkVELCBaX0hVRkZNQU5fT05MWSwgWl9STEUsIFpfRklYRUQsIFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgWl9VTktOT1dOLFxuICBaX0RFRkxBVEVEXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xuY29uc3QgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbmNvbnN0IERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbmNvbnN0IExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuY29uc3QgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5jb25zdCBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbmNvbnN0IEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuY29uc3QgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgTUlOX01BVENIID0gMztcbmNvbnN0IE1BWF9NQVRDSCA9IDI1ODtcbmNvbnN0IE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbmNvbnN0IFBSRVNFVF9ESUNUID0gMHgyMDtcblxuY29uc3QgSU5JVF9TVEFURSAgICA9ICA0MjsgICAgLyogemxpYiBoZWFkZXIgLT4gQlVTWV9TVEFURSAqL1xuLy8jaWZkZWYgR1pJUFxuY29uc3QgR1pJUF9TVEFURSAgICA9ICA1NzsgICAgLyogZ3ppcCBoZWFkZXIgLT4gQlVTWV9TVEFURSB8IEVYVFJBX1NUQVRFICovXG4vLyNlbmRpZlxuY29uc3QgRVhUUkFfU1RBVEUgICA9ICA2OTsgICAgLyogZ3ppcCBleHRyYSBibG9jayAtPiBOQU1FX1NUQVRFICovXG5jb25zdCBOQU1FX1NUQVRFICAgID0gIDczOyAgICAvKiBnemlwIGZpbGUgbmFtZSAtPiBDT01NRU5UX1NUQVRFICovXG5jb25zdCBDT01NRU5UX1NUQVRFID0gIDkxOyAgICAvKiBnemlwIGNvbW1lbnQgLT4gSENSQ19TVEFURSAqL1xuY29uc3QgSENSQ19TVEFURSAgICA9IDEwMzsgICAgLyogZ3ppcCBoZWFkZXIgQ1JDIC0+IEJVU1lfU1RBVEUgKi9cbmNvbnN0IEJVU1lfU1RBVEUgICAgPSAxMTM7ICAgIC8qIGRlZmxhdGUgLT4gRklOSVNIX1NUQVRFICovXG5jb25zdCBGSU5JU0hfU1RBVEUgID0gNjY2OyAgICAvKiBzdHJlYW0gY29tcGxldGUgKi9cblxuY29uc3QgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbmNvbnN0IEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG5jb25zdCBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG5jb25zdCBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxuY29uc3QgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmNvbnN0IGVyciA9IChzdHJtLCBlcnJvckNvZGUpID0+IHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn07XG5cbmNvbnN0IHJhbmsgPSAoZikgPT4ge1xuICByZXR1cm4gKChmKSAqIDIpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59O1xuXG5jb25zdCB6ZXJvID0gKGJ1ZikgPT4ge1xuICBsZXQgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNsaWRlIHRoZSBoYXNoIHRhYmxlIHdoZW4gc2xpZGluZyB0aGUgd2luZG93IGRvd24gKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMlxuICogYml0IHZhbHVlcyBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMCB0b1xuICoga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMCBsYXRlci5cbiAqL1xuY29uc3Qgc2xpZGVfaGFzaCA9IChzKSA9PiB7XG4gIGxldCBuLCBtO1xuICBsZXQgcDtcbiAgbGV0IHdzaXplID0gcy53X3NpemU7XG5cbiAgbiA9IHMuaGFzaF9zaXplO1xuICBwID0gbjtcbiAgZG8ge1xuICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICBzLmhlYWRbcF0gPSAobSA+PSB3c2l6ZSA/IG0gLSB3c2l6ZSA6IDApO1xuICB9IHdoaWxlICgtLW4pO1xuICBuID0gd3NpemU7XG4vLyNpZm5kZWYgRkFTVEVTVFxuICBwID0gbjtcbiAgZG8ge1xuICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICBzLnByZXZbcF0gPSAobSA+PSB3c2l6ZSA/IG0gLSB3c2l6ZSA6IDApO1xuICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgKi9cbiAgfSB3aGlsZSAoLS1uKTtcbi8vI2VuZGlmXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5sZXQgSEFTSF9aTElCID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCBzLmhhc2hfc2hpZnQpIF4gZGF0YSkgJiBzLmhhc2hfbWFzaztcbi8vIFRoaXMgaGFzaCBjYXVzZXMgbGVzcyBjb2xsaXNpb25zLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vaXNzdWVzLzEzNVxuLy8gQnV0IGJyZWFrcyBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy9sZXQgSEFTSF9GQVNUID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCA4KSArIChwcmV2ID4+IDgpICsgKGRhdGEgPDwgNCkpICYgcy5oYXNoX21hc2s7XG5sZXQgSEFTSCA9IEhBU0hfWkxJQjtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCwgZXhjZXB0IGZvclxuICogc29tZSBkZWZsYXRlX3N0b3JlZCgpIG91dHB1dCwgZ29lcyB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZVxuICogYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2VcbiAqIHN0cm0tPm5leHRfb3V0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmNvbnN0IGZsdXNoX3BlbmRpbmcgPSAoc3RybSkgPT4ge1xuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICBsZXQgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHN0cm0ub3V0cHV0LnNldChzLnBlbmRpbmdfYnVmLnN1YmFycmF5KHMucGVuZGluZ19vdXQsIHMucGVuZGluZ19vdXQgKyBsZW4pLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCAgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgICAgICAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufTtcblxuXG5jb25zdCBmbHVzaF9ibG9ja19vbmx5ID0gKHMsIGxhc3QpID0+IHtcbiAgX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59O1xuXG5cbmNvbnN0IHB1dF9ieXRlID0gKHMsIGIpID0+IHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmNvbnN0IHB1dFNob3J0TVNCID0gKHMsIGIpID0+IHtcblxuICAvLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuY29uc3QgcmVhZF9idWYgPSAoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkgPT4ge1xuXG4gIGxldCBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICBidWYuc2V0KHN0cm0uaW5wdXQuc3ViYXJyYXkoc3RybS5uZXh0X2luLCBzdHJtLm5leHRfaW4gKyBsZW4pLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmNvbnN0IGxvbmdlc3RfbWF0Y2ggPSAocywgY3VyX21hdGNoKSA9PiB7XG5cbiAgbGV0IGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgbGV0IHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICBsZXQgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIGxldCBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgbGV0IG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgY29uc3QgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgY29uc3Qgd21hc2sgPSBzLndfbWFzaztcbiAgY29uc3QgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgY29uc3Qgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgbGV0IHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICBsZXQgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuY29uc3QgZmlsbF93aW5kb3cgPSAocykgPT4ge1xuXG4gIGNvbnN0IF93X3NpemUgPSBzLndfc2l6ZTtcbiAgbGV0IG4sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KF93X3NpemUsIF93X3NpemUgKyBfd19zaXplIC0gbW9yZSksIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIGlmIChzLmluc2VydCA+IHMuc3Ryc3RhcnQpIHtcbiAgICAgICAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0O1xuICAgICAgfVxuICAgICAgc2xpZGVfaGFzaChzKTtcbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIDFdKTtcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSk7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICBjb25zdCBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgbGV0IGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqXG4gKiBJbiBjYXNlIGRlZmxhdGVQYXJhbXMoKSBpcyB1c2VkIHRvIGxhdGVyIHN3aXRjaCB0byBhIG5vbi16ZXJvIGNvbXByZXNzaW9uXG4gKiBsZXZlbCwgcy0+bWF0Y2hlcyAob3RoZXJ3aXNlIHVudXNlZCB3aGVuIHN0b3JpbmcpIGtlZXBzIHRyYWNrIG9mIHRoZSBudW1iZXJcbiAqIG9mIGhhc2ggdGFibGUgc2xpZGVzIHRvIHBlcmZvcm0uIElmIHMtPm1hdGNoZXMgaXMgMSwgdGhlbiBvbmUgaGFzaCB0YWJsZVxuICogc2xpZGUgd2lsbCBiZSBkb25lIHdoZW4gc3dpdGNoaW5nLiBJZiBzLT5tYXRjaGVzIGlzIDIsIHRoZSBtYXhpbXVtIHZhbHVlXG4gKiBhbGxvd2VkIGhlcmUsIHRoZW4gdGhlIGhhc2ggdGFibGUgd2lsbCBiZSBjbGVhcmVkLCBzaW5jZSB0d28gb3IgbW9yZSBzbGlkZXNcbiAqIGlzIHRoZSBzYW1lIGFzIGEgY2xlYXIuXG4gKlxuICogZGVmbGF0ZV9zdG9yZWQoKSBpcyB3cml0dGVuIHRvIG1pbmltaXplIHRoZSBudW1iZXIgb2YgdGltZXMgYW4gaW5wdXQgYnl0ZSBpc1xuICogY29waWVkLiBJdCBpcyBtb3N0IGVmZmljaWVudCB3aXRoIGxhcmdlIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycywgd2hpY2hcbiAqIG1heGltaXplcyB0aGUgb3Bwb3J0dW5pdGVzIHRvIGhhdmUgYSBzaW5nbGUgY29weSBmcm9tIG5leHRfaW4gdG8gbmV4dF9vdXQuXG4gKi9cbmNvbnN0IGRlZmxhdGVfc3RvcmVkID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgLyogU21hbGxlc3Qgd29ydGh5IGJsb2NrIHNpemUgd2hlbiBub3QgZmx1c2hpbmcgb3IgZmluaXNoaW5nLiBCeSBkZWZhdWx0XG4gICAqIHRoaXMgaXMgMzJLLiBUaGlzIGNhbiBiZSBhcyBzbWFsbCBhcyA1MDcgYnl0ZXMgZm9yIG1lbUxldmVsID09IDEuIEZvclxuICAgKiBsYXJnZSBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMsIHRoZSBzdG9yZWQgYmxvY2sgc2l6ZSB3aWxsIGJlIGxhcmdlci5cbiAgICovXG4gIGxldCBtaW5fYmxvY2sgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1ID4gcy53X3NpemUgPyBzLndfc2l6ZSA6IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG5cbiAgLyogQ29weSBhcyBtYW55IG1pbl9ibG9jayBvciBsYXJnZXIgc3RvcmVkIGJsb2NrcyBkaXJlY3RseSB0byBuZXh0X291dCBhc1xuICAgKiBwb3NzaWJsZS4gSWYgZmx1c2hpbmcsIGNvcHkgdGhlIHJlbWFpbmluZyBhdmFpbGFibGUgaW5wdXQgdG8gbmV4dF9vdXQgYXNcbiAgICogc3RvcmVkIGJsb2NrcywgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlLlxuICAgKi9cbiAgbGV0IGxlbiwgbGVmdCwgaGF2ZSwgbGFzdCA9IDA7XG4gIGxldCB1c2VkID0gcy5zdHJtLmF2YWlsX2luO1xuICBkbyB7XG4gICAgLyogU2V0IGxlbiB0byB0aGUgbWF4aW11bSBzaXplIGJsb2NrIHRoYXQgd2UgY2FuIGNvcHkgZGlyZWN0bHkgd2l0aCB0aGVcbiAgICAgKiBhdmFpbGFibGUgaW5wdXQgZGF0YSBhbmQgb3V0cHV0IHNwYWNlLiBTZXQgbGVmdCB0byBob3cgbXVjaCBvZiB0aGF0XG4gICAgICogd291bGQgYmUgY29waWVkIGZyb20gd2hhdCdzIGxlZnQgaW4gdGhlIHdpbmRvdy5cbiAgICAgKi9cbiAgICBsZW4gPSA2NTUzNS8qIE1BWF9TVE9SRUQgKi87ICAgICAvKiBtYXhpbXVtIGRlZmxhdGUgc3RvcmVkIGJsb2NrIGxlbmd0aCAqL1xuICAgIGhhdmUgPSAocy5iaV92YWxpZCArIDQyKSA+PiAzOyAgICAgLyogbnVtYmVyIG9mIGhlYWRlciBieXRlcyAqL1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0IDwgaGF2ZSkgeyAgICAgICAgIC8qIG5lZWQgcm9vbSBmb3IgaGVhZGVyICovXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgICAvKiBtYXhpbXVtIHN0b3JlZCBibG9jayBsZW5ndGggdGhhdCB3aWxsIGZpdCBpbiBhdmFpbF9vdXQ6ICovXG4gICAgaGF2ZSA9IHMuc3RybS5hdmFpbF9vdXQgLSBoYXZlO1xuICAgIGxlZnQgPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDsgIC8qIGJ5dGVzIGxlZnQgaW4gd2luZG93ICovXG4gICAgaWYgKGxlbiA+IGxlZnQgKyBzLnN0cm0uYXZhaWxfaW4pIHtcbiAgICAgIGxlbiA9IGxlZnQgKyBzLnN0cm0uYXZhaWxfaW47ICAgLyogbGltaXQgbGVuIHRvIHRoZSBpbnB1dCAqL1xuICAgIH1cbiAgICBpZiAobGVuID4gaGF2ZSkge1xuICAgICAgbGVuID0gaGF2ZTsgICAgICAgICAgICAgLyogbGltaXQgbGVuIHRvIHRoZSBvdXRwdXQgKi9cbiAgICB9XG5cbiAgICAvKiBJZiB0aGUgc3RvcmVkIGJsb2NrIHdvdWxkIGJlIGxlc3MgdGhhbiBtaW5fYmxvY2sgaW4gbGVuZ3RoLCBvciBpZlxuICAgICAqIHVuYWJsZSB0byBjb3B5IGFsbCBvZiB0aGUgYXZhaWxhYmxlIGlucHV0IHdoZW4gZmx1c2hpbmcsIHRoZW4gdHJ5XG4gICAgICogY29weWluZyB0byB0aGUgd2luZG93IGFuZCB0aGUgcGVuZGluZyBidWZmZXIgaW5zdGVhZC4gQWxzbyBkb24ndFxuICAgICAqIHdyaXRlIGFuIGVtcHR5IGJsb2NrIHdoZW4gZmx1c2hpbmcgLS0gZGVmbGF0ZSgpIGRvZXMgdGhhdC5cbiAgICAgKi9cbiAgICBpZiAobGVuIDwgbWluX2Jsb2NrICYmICgobGVuID09PSAwICYmIGZsdXNoICE9PSBaX0ZJTklTSCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoID09PSBaX05PX0ZMVVNIIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gIT09IGxlZnQgKyBzLnN0cm0uYXZhaWxfaW4pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBNYWtlIGEgZHVtbXkgc3RvcmVkIGJsb2NrIGluIHBlbmRpbmcgdG8gZ2V0IHRoZSBoZWFkZXIgYnl0ZXMsXG4gICAgICogaW5jbHVkaW5nIGFueSBwZW5kaW5nIGJpdHMuIFRoaXMgYWxzbyB1cGRhdGVzIHRoZSBkZWJ1Z2dpbmcgY291bnRzLlxuICAgICAqL1xuICAgIGxhc3QgPSBmbHVzaCA9PT0gWl9GSU5JU0ggJiYgbGVuID09PSBsZWZ0ICsgcy5zdHJtLmF2YWlsX2luID8gMSA6IDA7XG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBsYXN0KTtcblxuICAgIC8qIFJlcGxhY2UgdGhlIGxlbmd0aHMgaW4gdGhlIGR1bW15IHN0b3JlZCBibG9jayB3aXRoIGxlbi4gKi9cbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZyAtIDRdID0gbGVuO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nIC0gM10gPSBsZW4gPj4gODtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZyAtIDJdID0gfmxlbjtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZyAtIDFdID0gfmxlbiA+PiA4O1xuXG4gICAgLyogV3JpdGUgdGhlIHN0b3JlZCBibG9jayBoZWFkZXIgYnl0ZXMuICovXG4gICAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xuXG4vLyNpZmRlZiBaTElCX0RFQlVHXG4vLyAgICAvKiBVcGRhdGUgZGVidWdnaW5nIGNvdW50cyBmb3IgdGhlIGRhdGEgYWJvdXQgdG8gYmUgY29waWVkLiAqL1xuLy8gICAgcy0+Y29tcHJlc3NlZF9sZW4gKz0gbGVuIDw8IDM7XG4vLyAgICBzLT5iaXRzX3NlbnQgKz0gbGVuIDw8IDM7XG4vLyNlbmRpZlxuXG4gICAgLyogQ29weSB1bmNvbXByZXNzZWQgYnl0ZXMgZnJvbSB0aGUgd2luZG93IHRvIG5leHRfb3V0LiAqL1xuICAgIGlmIChsZWZ0KSB7XG4gICAgICBpZiAobGVmdCA+IGxlbikge1xuICAgICAgICBsZWZ0ID0gbGVuO1xuICAgICAgfVxuICAgICAgLy96bWVtY3B5KHMtPnN0cm0tPm5leHRfb3V0LCBzLT53aW5kb3cgKyBzLT5ibG9ja19zdGFydCwgbGVmdCk7XG4gICAgICBzLnN0cm0ub3V0cHV0LnNldChzLndpbmRvdy5zdWJhcnJheShzLmJsb2NrX3N0YXJ0LCBzLmJsb2NrX3N0YXJ0ICsgbGVmdCksIHMuc3RybS5uZXh0X291dCk7XG4gICAgICBzLnN0cm0ubmV4dF9vdXQgKz0gbGVmdDtcbiAgICAgIHMuc3RybS5hdmFpbF9vdXQgLT0gbGVmdDtcbiAgICAgIHMuc3RybS50b3RhbF9vdXQgKz0gbGVmdDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgKz0gbGVmdDtcbiAgICAgIGxlbiAtPSBsZWZ0O1xuICAgIH1cblxuICAgIC8qIENvcHkgdW5jb21wcmVzc2VkIGJ5dGVzIGRpcmVjdGx5IGZyb20gbmV4dF9pbiB0byBuZXh0X291dCwgdXBkYXRpbmdcbiAgICAgKiB0aGUgY2hlY2sgdmFsdWUuXG4gICAgICovXG4gICAgaWYgKGxlbikge1xuICAgICAgcmVhZF9idWYocy5zdHJtLCBzLnN0cm0ub3V0cHV0LCBzLnN0cm0ubmV4dF9vdXQsIGxlbik7XG4gICAgICBzLnN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICAgICAgcy5zdHJtLmF2YWlsX291dCAtPSBsZW47XG4gICAgICBzLnN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgICB9XG4gIH0gd2hpbGUgKGxhc3QgPT09IDApO1xuXG4gIC8qIFVwZGF0ZSB0aGUgc2xpZGluZyB3aW5kb3cgd2l0aCB0aGUgbGFzdCBzLT53X3NpemUgYnl0ZXMgb2YgdGhlIGNvcGllZFxuICAgKiBkYXRhLCBvciBhcHBlbmQgYWxsIG9mIHRoZSBjb3BpZWQgZGF0YSB0byB0aGUgZXhpc3Rpbmcgd2luZG93IGlmIGxlc3NcbiAgICogdGhhbiBzLT53X3NpemUgYnl0ZXMgd2VyZSBjb3BpZWQuIEFsc28gdXBkYXRlIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG9cbiAgICogaW5zZXJ0IGluIHRoZSBoYXNoIHRhYmxlcywgaW4gdGhlIGV2ZW50IHRoYXQgZGVmbGF0ZVBhcmFtcygpIHN3aXRjaGVzIHRvXG4gICAqIGEgbm9uLXplcm8gY29tcHJlc3Npb24gbGV2ZWwuXG4gICAqL1xuICB1c2VkIC09IHMuc3RybS5hdmFpbF9pbjsgICAgLyogbnVtYmVyIG9mIGlucHV0IGJ5dGVzIGRpcmVjdGx5IGNvcGllZCAqL1xuICBpZiAodXNlZCkge1xuICAgIC8qIElmIGFueSBpbnB1dCB3YXMgdXNlZCwgdGhlbiBubyB1bnVzZWQgaW5wdXQgcmVtYWlucyBpbiB0aGUgd2luZG93LFxuICAgICAqIHRoZXJlZm9yZSBzLT5ibG9ja19zdGFydCA9PSBzLT5zdHJzdGFydC5cbiAgICAgKi9cbiAgICBpZiAodXNlZCA+PSBzLndfc2l6ZSkgeyAgLyogc3VwcGxhbnQgdGhlIHByZXZpb3VzIGhpc3RvcnkgKi9cbiAgICAgIHMubWF0Y2hlcyA9IDI7ICAgICAvKiBjbGVhciBoYXNoICovXG4gICAgICAvL3ptZW1jcHkocy0+d2luZG93LCBzLT5zdHJtLT5uZXh0X2luIC0gcy0+d19zaXplLCBzLT53X3NpemUpO1xuICAgICAgcy53aW5kb3cuc2V0KHMuc3RybS5pbnB1dC5zdWJhcnJheShzLnN0cm0ubmV4dF9pbiAtIHMud19zaXplLCBzLnN0cm0ubmV4dF9pbiksIDApO1xuICAgICAgcy5zdHJzdGFydCA9IHMud19zaXplO1xuICAgICAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChzLndpbmRvd19zaXplIC0gcy5zdHJzdGFydCA8PSB1c2VkKSB7XG4gICAgICAgIC8qIFNsaWRlIHRoZSB3aW5kb3cgZG93bi4gKi9cbiAgICAgICAgcy5zdHJzdGFydCAtPSBzLndfc2l6ZTtcbiAgICAgICAgLy96bWVtY3B5KHMtPndpbmRvdywgcy0+d2luZG93ICsgcy0+d19zaXplLCBzLT5zdHJzdGFydCk7XG4gICAgICAgIHMud2luZG93LnNldChzLndpbmRvdy5zdWJhcnJheShzLndfc2l6ZSwgcy53X3NpemUgKyBzLnN0cnN0YXJ0KSwgMCk7XG4gICAgICAgIGlmIChzLm1hdGNoZXMgPCAyKSB7XG4gICAgICAgICAgcy5tYXRjaGVzKys7ICAgLyogYWRkIGEgcGVuZGluZyBzbGlkZV9oYXNoKCkgKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAocy5pbnNlcnQgPiBzLnN0cnN0YXJ0KSB7XG4gICAgICAgICAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL3ptZW1jcHkocy0+d2luZG93ICsgcy0+c3Ryc3RhcnQsIHMtPnN0cm0tPm5leHRfaW4gLSB1c2VkLCB1c2VkKTtcbiAgICAgIHMud2luZG93LnNldChzLnN0cm0uaW5wdXQuc3ViYXJyYXkocy5zdHJtLm5leHRfaW4gLSB1c2VkLCBzLnN0cm0ubmV4dF9pbiksIHMuc3Ryc3RhcnQpO1xuICAgICAgcy5zdHJzdGFydCArPSB1c2VkO1xuICAgICAgcy5pbnNlcnQgKz0gdXNlZCA+IHMud19zaXplIC0gcy5pbnNlcnQgPyBzLndfc2l6ZSAtIHMuaW5zZXJ0IDogdXNlZDtcbiAgICB9XG4gICAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIH1cbiAgaWYgKHMuaGlnaF93YXRlciA8IHMuc3Ryc3RhcnQpIHtcbiAgICBzLmhpZ2hfd2F0ZXIgPSBzLnN0cnN0YXJ0O1xuICB9XG5cbiAgLyogSWYgdGhlIGxhc3QgYmxvY2sgd2FzIHdyaXR0ZW4gdG8gbmV4dF9vdXQsIHRoZW4gZG9uZS4gKi9cbiAgaWYgKGxhc3QpIHtcbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICAvKiBJZiBmbHVzaGluZyBhbmQgYWxsIGlucHV0IGhhcyBiZWVuIGNvbnN1bWVkLCB0aGVuIGRvbmUuICovXG4gIGlmIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBmbHVzaCAhPT0gWl9GSU5JU0ggJiZcbiAgICBzLnN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcy5zdHJzdGFydCA9PT0gcy5ibG9ja19zdGFydCkge1xuICAgIHJldHVybiBCU19CTE9DS19ET05FO1xuICB9XG5cbiAgLyogRmlsbCB0aGUgd2luZG93IHdpdGggYW55IHJlbWFpbmluZyBpbnB1dC4gKi9cbiAgaGF2ZSA9IHMud2luZG93X3NpemUgLSBzLnN0cnN0YXJ0O1xuICBpZiAocy5zdHJtLmF2YWlsX2luID4gaGF2ZSAmJiBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSB7XG4gICAgLyogU2xpZGUgdGhlIHdpbmRvdyBkb3duLiAqL1xuICAgIHMuYmxvY2tfc3RhcnQgLT0gcy53X3NpemU7XG4gICAgcy5zdHJzdGFydCAtPSBzLndfc2l6ZTtcbiAgICAvL3ptZW1jcHkocy0+d2luZG93LCBzLT53aW5kb3cgKyBzLT53X3NpemUsIHMtPnN0cnN0YXJ0KTtcbiAgICBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkocy53X3NpemUsIHMud19zaXplICsgcy5zdHJzdGFydCksIDApO1xuICAgIGlmIChzLm1hdGNoZXMgPCAyKSB7XG4gICAgICBzLm1hdGNoZXMrKzsgICAgICAgLyogYWRkIGEgcGVuZGluZyBzbGlkZV9oYXNoKCkgKi9cbiAgICB9XG4gICAgaGF2ZSArPSBzLndfc2l6ZTsgICAgICAvKiBtb3JlIHNwYWNlIG5vdyAqL1xuICAgIGlmIChzLmluc2VydCA+IHMuc3Ryc3RhcnQpIHtcbiAgICAgIHMuaW5zZXJ0ID0gcy5zdHJzdGFydDtcbiAgICB9XG4gIH1cbiAgaWYgKGhhdmUgPiBzLnN0cm0uYXZhaWxfaW4pIHtcbiAgICBoYXZlID0gcy5zdHJtLmF2YWlsX2luO1xuICB9XG4gIGlmIChoYXZlKSB7XG4gICAgcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCwgaGF2ZSk7XG4gICAgcy5zdHJzdGFydCArPSBoYXZlO1xuICAgIHMuaW5zZXJ0ICs9IGhhdmUgPiBzLndfc2l6ZSAtIHMuaW5zZXJ0ID8gcy53X3NpemUgLSBzLmluc2VydCA6IGhhdmU7XG4gIH1cbiAgaWYgKHMuaGlnaF93YXRlciA8IHMuc3Ryc3RhcnQpIHtcbiAgICBzLmhpZ2hfd2F0ZXIgPSBzLnN0cnN0YXJ0O1xuICB9XG5cbiAgLyogVGhlcmUgd2FzIG5vdCBlbm91Z2ggYXZhaWxfb3V0IHRvIHdyaXRlIGEgY29tcGxldGUgd29ydGh5IG9yIGZsdXNoZWRcbiAgICogc3RvcmVkIGJsb2NrIHRvIG5leHRfb3V0LiBXcml0ZSBhIHN0b3JlZCBibG9jayB0byBwZW5kaW5nIGluc3RlYWQsIGlmIHdlXG4gICAqIGhhdmUgZW5vdWdoIGlucHV0IGZvciBhIHdvcnRoeSBibG9jaywgb3IgaWYgZmx1c2hpbmcgYW5kIHRoZXJlIGlzIGVub3VnaFxuICAgKiByb29tIGZvciB0aGUgcmVtYWluaW5nIGlucHV0IGFzIGEgc3RvcmVkIGJsb2NrIGluIHRoZSBwZW5kaW5nIGJ1ZmZlci5cbiAgICovXG4gIGhhdmUgPSAocy5iaV92YWxpZCArIDQyKSA+PiAzOyAgICAgLyogbnVtYmVyIG9mIGhlYWRlciBieXRlcyAqL1xuICAgIC8qIG1heGltdW0gc3RvcmVkIGJsb2NrIGxlbmd0aCB0aGF0IHdpbGwgZml0IGluIHBlbmRpbmc6ICovXG4gIGhhdmUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSBoYXZlID4gNjU1MzUvKiBNQVhfU1RPUkVEICovID8gNjU1MzUvKiBNQVhfU1RPUkVEICovIDogcy5wZW5kaW5nX2J1Zl9zaXplIC0gaGF2ZTtcbiAgbWluX2Jsb2NrID0gaGF2ZSA+IHMud19zaXplID8gcy53X3NpemUgOiBoYXZlO1xuICBsZWZ0ID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4gIGlmIChsZWZ0ID49IG1pbl9ibG9jayB8fFxuICAgICAoKGxlZnQgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiBmbHVzaCAhPT0gWl9OT19GTFVTSCAmJlxuICAgICBzLnN0cm0uYXZhaWxfaW4gPT09IDAgJiYgbGVmdCA8PSBoYXZlKSkge1xuICAgIGxlbiA9IGxlZnQgPiBoYXZlID8gaGF2ZSA6IGxlZnQ7XG4gICAgbGFzdCA9IGZsdXNoID09PSBaX0ZJTklTSCAmJiBzLnN0cm0uYXZhaWxfaW4gPT09IDAgJiZcbiAgICAgICAgIGxlbiA9PT0gbGVmdCA/IDEgOiAwO1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgcy5ibG9ja19zdGFydCwgbGVuLCBsYXN0KTtcbiAgICBzLmJsb2NrX3N0YXJ0ICs9IGxlbjtcbiAgICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG4gIH1cblxuICAvKiBXZSd2ZSBkb25lIGFsbCB3ZSBjYW4gd2l0aCB0aGUgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQuICovXG4gIHJldHVybiBsYXN0ID8gQlNfRklOSVNIX1NUQVJURUQgOiBCU19ORUVEX01PUkU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5jb25zdCBkZWZsYXRlX2Zhc3QgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLnN5bV9uZXh0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5jb25zdCBkZWZsYXRlX3Nsb3cgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGxldCBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMuc3ltX25leHQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5jb25zdCBkZWZsYXRlX3JsZSA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIGxldCBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgbGV0IHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5zeW1fbmV4dCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuY29uc3QgZGVmbGF0ZV9odWZmID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLnN5bV9uZXh0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG5cbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbmNvbnN0IGNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuY29uc3QgbG1faW5pdCA9IChzKSA9PiB7XG5cbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn07XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyBVaW50MTZBcnJheSgoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgVWludDE2QXJyYXkoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5zeW1fYnVmID0gMDsgICAgICAgIC8qIGJ1ZmZlciBmb3IgZGlzdGFuY2VzIGFuZCBsaXRlcmFscy9sZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMuc3ltX25leHQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gc3ltX2J1ZiAqL1xuICB0aGlzLnN5bV9lbmQgPSAwOyAgICAgICAvKiBzeW1ib2wgdGFibGUgZnVsbCB3aGVuIHN5bV9uZXh0IHJlYWNoZXMgdGhpcyAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBmb3IgYSB2YWxpZCBkZWZsYXRlIHN0cmVhbSBzdGF0ZS4gUmV0dXJuIDAgaWYgb2ssIDEgaWYgbm90LlxuICovXG5jb25zdCBkZWZsYXRlU3RhdGVDaGVjayA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIGlmICghcyB8fCBzLnN0cm0gIT09IHN0cm0gfHwgKHMuc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4vLyNpZmRlZiBHWklQXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuc3RhdHVzICE9PSBHWklQX1NUQVRFICYmXG4vLyNlbmRpZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKGRlZmxhdGVTdGF0ZUNoZWNrKHN0cm0pKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPVxuLy8jaWZkZWYgR1pJUFxuICAgIHMud3JhcCA9PT0gMiA/IEdaSVBfU1RBVEUgOlxuLy8jZW5kaWZcbiAgICBzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gLTI7XG4gIF90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBjb25zdCByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBkZWZsYXRlU2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICBpZiAoZGVmbGF0ZVN0YXRlQ2hlY2soc3RybSkgfHwgc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVJbml0MiA9IChzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBsZXQgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCB8fCAod2luZG93Qml0cyA9PT0gOCAmJiB3cmFwICE9PSAxKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICBjb25zdCBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuICBzLnN0YXR1cyA9IElOSVRfU1RBVEU7ICAgICAvKiB0byBwYXNzIHN0YXRlIHRlc3QgaW4gZGVmbGF0ZVJlc2V0KCkgKi9cblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IFVpbnQxNkFycmF5KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IFVpbnQxNkFycmF5KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICAvKiBXZSBvdmVybGF5IHBlbmRpbmdfYnVmIGFuZCBzeW1fYnVmLiBUaGlzIHdvcmtzIHNpbmNlIHRoZSBhdmVyYWdlIHNpemVcbiAgICogZm9yIGxlbmd0aC9kaXN0YW5jZSBwYWlycyBvdmVyIGFueSBjb21wcmVzc2VkIGJsb2NrIGlzIGFzc3VyZWQgdG8gYmUgMzFcbiAgICogYml0cyBvciBsZXNzLlxuICAgKlxuICAgKiBBbmFseXNpczogVGhlIGxvbmdlc3QgZml4ZWQgY29kZXMgYXJlIGEgbGVuZ3RoIGNvZGUgb2YgOCBiaXRzIHBsdXMgNVxuICAgKiBleHRyYSBiaXRzLCBmb3IgbGVuZ3RocyAxMzEgdG8gMjU3LiBUaGUgbG9uZ2VzdCBmaXhlZCBkaXN0YW5jZSBjb2RlcyBhcmVcbiAgICogNSBiaXRzIHBsdXMgMTMgZXh0cmEgYml0cywgZm9yIGRpc3RhbmNlcyAxNjM4NSB0byAzMjc2OC4gVGhlIGxvbmdlc3RcbiAgICogcG9zc2libGUgZml4ZWQtY29kZXMgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgdGhlbiAzMSBiaXRzIHRvdGFsLlxuICAgKlxuICAgKiBzeW1fYnVmIHN0YXJ0cyBvbmUtZm91cnRoIG9mIHRoZSB3YXkgaW50byBwZW5kaW5nX2J1Zi4gU28gdGhlcmUgYXJlXG4gICAqIHRocmVlIGJ5dGVzIGluIHN5bV9idWYgZm9yIGV2ZXJ5IGZvdXIgYnl0ZXMgaW4gcGVuZGluZ19idWYuIEVhY2ggc3ltYm9sXG4gICAqIGluIHN5bV9idWYgaXMgdGhyZWUgYnl0ZXMgLS0gdHdvIGZvciB0aGUgZGlzdGFuY2UgYW5kIG9uZSBmb3IgdGhlXG4gICAqIGxpdGVyYWwvbGVuZ3RoLiBBcyBlYWNoIHN5bWJvbCBpcyBjb25zdW1lZCwgdGhlIHBvaW50ZXIgdG8gdGhlIG5leHRcbiAgICogc3ltX2J1ZiB2YWx1ZSB0byByZWFkIG1vdmVzIGZvcndhcmQgdGhyZWUgYnl0ZXMuIEZyb20gdGhhdCBzeW1ib2wsIHVwIHRvXG4gICAqIDMxIGJpdHMgYXJlIHdyaXR0ZW4gdG8gcGVuZGluZ19idWYuIFRoZSBjbG9zZXN0IHRoZSB3cml0dGVuIHBlbmRpbmdfYnVmXG4gICAqIGJpdHMgZ2V0cyB0byB0aGUgbmV4dCBzeW1fYnVmIHN5bWJvbCB0byByZWFkIGlzIGp1c3QgYmVmb3JlIHRoZSBsYXN0XG4gICAqIGNvZGUgaXMgd3JpdHRlbi4gQXQgdGhhdCB0aW1lLCAzMSoobi0yKSBiaXRzIGhhdmUgYmVlbiB3cml0dGVuLCBqdXN0XG4gICAqIGFmdGVyIDI0KihuLTIpIGJpdHMgaGF2ZSBiZWVuIGNvbnN1bWVkIGZyb20gc3ltX2J1Zi4gc3ltX2J1ZiBzdGFydHMgYXRcbiAgICogOCpuIGJpdHMgaW50byBwZW5kaW5nX2J1Zi4gKE5vdGUgdGhhdCB0aGUgc3ltYm9sIGJ1ZmZlciBmaWxscyB3aGVuIG4tMVxuICAgKiBzeW1ib2xzIGFyZSB3cml0dGVuLikgVGhlIGNsb3Nlc3QgdGhlIHdyaXRpbmcgZ2V0cyB0byB3aGF0IGlzIHVucmVhZCBpc1xuICAgKiB0aGVuIG4rMTQgYml0cy4gSGVyZSBuIGlzIGxpdF9idWZzaXplLCB3aGljaCBpcyAxNjM4NCBieSBkZWZhdWx0LCBhbmRcbiAgICogY2FuIHJhbmdlIGZyb20gMTI4IHRvIDMyNzY4LlxuICAgKlxuICAgKiBUaGVyZWZvcmUsIGF0IGEgbWluaW11bSwgdGhlcmUgYXJlIDE0MiBiaXRzIG9mIHNwYWNlIGJldHdlZW4gd2hhdCBpc1xuICAgKiB3cml0dGVuIGFuZCB3aGF0IGlzIHJlYWQgaW4gdGhlIG92ZXJsYWluIGJ1ZmZlcnMsIHNvIHRoZSBzeW1ib2xzIGNhbm5vdFxuICAgKiBiZSBvdmVyd3JpdHRlbiBieSB0aGUgY29tcHJlc3NlZCBkYXRhLiBUaGF0IHNwYWNlIGlzIGFjdHVhbGx5IDEzOSBiaXRzLFxuICAgKiBkdWUgdG8gdGhlIHRocmVlLWJpdCBmaXhlZC1jb2RlIGJsb2NrIGhlYWRlci5cbiAgICpcbiAgICogVGhhdCBjb3ZlcnMgdGhlIGNhc2Ugd2hlcmUgZWl0aGVyIFpfRklYRUQgaXMgc3BlY2lmaWVkLCBmb3JjaW5nIGZpeGVkXG4gICAqIGNvZGVzLCBvciB3aGVuIHRoZSB1c2Ugb2YgZml4ZWQgY29kZXMgaXMgY2hvc2VuLCBiZWNhdXNlIHRoYXQgY2hvaWNlXG4gICAqIHJlc3VsdHMgaW4gYSBzbWFsbGVyIGNvbXByZXNzZWQgYmxvY2sgdGhhbiBkeW5hbWljIGNvZGVzLiBUaGF0IGxhdHRlclxuICAgKiBjb25kaXRpb24gdGhlbiBhc3N1cmVzIHRoYXQgdGhlIGFib3ZlIGFuYWx5c2lzIGFsc28gY292ZXJzIGFsbCBkeW5hbWljXG4gICAqIGJsb2Nrcy4gQSBkeW5hbWljLWNvZGUgYmxvY2sgd2lsbCBvbmx5IGJlIGNob3NlbiB0byBiZSBlbWl0dGVkIGlmIGl0IGhhc1xuICAgKiBmZXdlciBiaXRzIHRoYW4gYSBmaXhlZC1jb2RlIGJsb2NrIHdvdWxkIGZvciB0aGUgc2FtZSBzZXQgb2Ygc3ltYm9scy5cbiAgICogVGhlcmVmb3JlIGl0cyBhdmVyYWdlIHN5bWJvbCBsZW5ndGggaXMgYXNzdXJlZCB0byBiZSBsZXNzIHRoYW4gMzEuIFNvXG4gICAqIHRoZSBjb21wcmVzc2VkIGRhdGEgZm9yIGEgZHluYW1pYyBibG9jayBhbHNvIGNhbm5vdCBvdmVyd3JpdGUgdGhlXG4gICAqIHN5bWJvbHMgZnJvbSB3aGljaCBpdCBpcyBiZWluZyBjb25zdHJ1Y3RlZC5cbiAgICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgVWludDhBcnJheShzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPnN5bV9idWYgPSBzLT5wZW5kaW5nX2J1ZiArIHMtPmxpdF9idWZzaXplO1xuICBzLnN5bV9idWYgPSBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+c3ltX2VuZCA9IChzLT5saXRfYnVmc2l6ZSAtIDEpICogMztcbiAgcy5zeW1fZW5kID0gKHMubGl0X2J1ZnNpemUgLSAxKSAqIDM7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUqMyBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn07XG5cbmNvbnN0IGRlZmxhdGVJbml0ID0gKHN0cm0sIGxldmVsKSA9PiB7XG5cbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5jb25zdCBkZWZsYXRlID0gKHN0cm0sIGZsdXNoKSA9PiB7XG5cbiAgaWYgKGRlZmxhdGVTdGF0ZUNoZWNrKHN0cm0pIHx8IGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgIChzdHJtLmF2YWlsX2luICE9PSAwICYmICFzdHJtLmlucHV0KSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgY29uc3Qgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUgJiYgcy53cmFwID09PSAwKSB7XG4gICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuICAgIC8qIHpsaWIgaGVhZGVyICovXG4gICAgbGV0IGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgIGxldCBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICB9XG4gICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICB9XG4gICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuXG4gICAgLyogQ29tcHJlc3Npb24gbXVzdCBzdGFydCB3aXRoIGFuIGVtcHR5IHBlbmRpbmcgYnVmZmVyICovXG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cbiAgfVxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEdaSVBfU1RBVEUpIHtcbiAgICAvKiBnemlwIGhlYWRlciAqL1xuICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuXG4gICAgICAvKiBDb21wcmVzc2lvbiBtdXN0IHN0YXJ0IHdpdGggYW4gZW1wdHkgcGVuZGluZyBidWZmZXIgKi9cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICApO1xuICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgIH1cbiAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGxldCBiZWcgPSBzLnBlbmRpbmc7ICAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgbGV0IGxlZnQgPSAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSAtIHMuZ3ppbmRleDtcbiAgICAgIHdoaWxlIChzLnBlbmRpbmcgKyBsZWZ0ID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGxldCBjb3B5ID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gcy5wZW5kaW5nO1xuICAgICAgICAvLyB6bWVtY3B5KHMucGVuZGluZ19idWYgKyBzLnBlbmRpbmcsXG4gICAgICAgIC8vICAgIHMuZ3poZWFkLmV4dHJhICsgcy5nemluZGV4LCBjb3B5KTtcbiAgICAgICAgcy5wZW5kaW5nX2J1Zi5zZXQocy5nemhlYWQuZXh0cmEuc3ViYXJyYXkocy5nemluZGV4LCBzLmd6aW5kZXggKyBjb3B5KSwgcy5wZW5kaW5nKTtcbiAgICAgICAgcy5wZW5kaW5nID0gcy5wZW5kaW5nX2J1Zl9zaXplO1xuICAgICAgICAvLy0tLSBIQ1JDX1VQREFURShiZWcpIC0tLS8vXG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzLmd6aW5kZXggKz0gY29weTtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAgIHJldHVybiBaX09LO1xuICAgICAgICB9XG4gICAgICAgIGJlZyA9IDA7XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgIH1cbiAgICAgIC8vIEpTIHNwZWNpZmljOiBzLmd6aGVhZC5leHRyYSBtYXkgYmUgVHlwZWRBcnJheSBvciBBcnJheSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgLy8gICAgICAgICAgICAgIFR5cGVkQXJyYXkuc2xpY2UgYW5kIFR5cGVkQXJyYXkuZnJvbSBkb24ndCBleGlzdCBpbiBJRTEwLUlFMTFcbiAgICAgIGxldCBnemhlYWRfZXh0cmEgPSBuZXcgVWludDhBcnJheShzLmd6aGVhZC5leHRyYSk7XG4gICAgICAvLyB6bWVtY3B5KHMtPnBlbmRpbmdfYnVmICsgcy0+cGVuZGluZyxcbiAgICAgIC8vICAgICBzLT5nemhlYWQtPmV4dHJhICsgcy0+Z3ppbmRleCwgbGVmdCk7XG4gICAgICBzLnBlbmRpbmdfYnVmLnNldChnemhlYWRfZXh0cmEuc3ViYXJyYXkocy5nemluZGV4LCBzLmd6aW5kZXggKyBsZWZ0KSwgcy5wZW5kaW5nKTtcbiAgICAgIHMucGVuZGluZyArPSBsZWZ0O1xuICAgICAgLy8tLS0gSENSQ19VUERBVEUoYmVnKSAtLS0vL1xuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICAvLy0tLS8vXG4gICAgICBzLmd6aW5kZXggPSAwO1xuICAgIH1cbiAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgbGV0IGJlZyA9IHMucGVuZGluZzsgICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICBsZXQgdmFsO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAvLy0tLSBIQ1JDX1VQREFURShiZWcpIC0tLS8vXG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgICAgIHJldHVybiBaX09LO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiZWcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG4gICAgICAvLy0tLSBIQ1JDX1VQREFURShiZWcpIC0tLS8vXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIC8vLS0tLy9cbiAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgfVxuICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBsZXQgYmVnID0gcy5wZW5kaW5nOyAgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIGxldCB2YWw7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIC8vLS0tIEhDUkNfVVBEQVRFKGJlZykgLS0tLy9cbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJlZyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcbiAgICAgIC8vLS0tIEhDUkNfVVBEQVRFKGJlZykgLS0tLy9cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgLy8tLS0vL1xuICAgIH1cbiAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG5cbiAgICAvKiBDb21wcmVzc2lvbiBtdXN0IHN0YXJ0IHdpdGggYW4gZW1wdHkgcGVuZGluZyBidWZmZXIgKi9cbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgbGV0IGJzdGF0ZSA9IHMubGV2ZWwgPT09IDAgPyBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkgOlxuICAgICAgICAgICAgICAgICBzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgICAgICAgICAgICBzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICBfdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn07XG5cblxuY29uc3QgZGVmbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKGRlZmxhdGVTdGF0ZUNoZWNrKHN0cm0pKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5jb25zdCBkZWZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG5cbiAgbGV0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBpZiAoZGVmbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgY29uc3Qgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIGxldCB0bXBEaWN0ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUpO1xuICAgIHRtcERpY3Quc2V0KGRpY3Rpb25hcnkuc3ViYXJyYXkoZGljdExlbmd0aCAtIHMud19zaXplLCBkaWN0TGVuZ3RoKSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGNvbnN0IGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgY29uc3QgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgY29uc3QgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgbGV0IHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbGV0IG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSk7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUdldERpY3Rpb25hcnkgPSBkZWZsYXRlR2V0RGljdGlvbmFyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xuY29uc3QgQkFEID0gMTYyMDk7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0IFRZUEUgPSAxNjE5MTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIGxldCBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIGxldCBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgbGV0IF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGxldCBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIGxldCB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgbGV0IHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgbGV0IHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICBsZXQgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIGxldCBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICBsZXQgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIGxldCBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIGxldCBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgbGV0IGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIGxldCBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgbGV0IG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIGxldCBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICBsZXQgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIGxldCBmcm9tX3NvdXJjZTtcblxuXG4gIGxldCBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuY29uc3QgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbmNvbnN0IGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbmNvbnN0IGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbmNvbnN0IENPREVTID0gMDtcbmNvbnN0IExFTlMgPSAxO1xuY29uc3QgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX0ZJTklTSCwgWl9CTE9DSywgWl9UUkVFUyxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELCBaX05FRURfRElDVCwgWl9TVFJFQU1fRVJST1IsIFpfREFUQV9FUlJPUiwgWl9NRU1fRVJST1IsIFpfQlVGX0VSUk9SLFxuICBaX0RFRkxBVEVEXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCAgICBIRUFEID0gMTYxODA7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xuY29uc3QgICAgRkxBR1MgPSAxNjE4MTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xuY29uc3QgICAgVElNRSA9IDE2MTgyOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbmNvbnN0ICAgIE9TID0gMTYxODM7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG5jb25zdCAgICBFWExFTiA9IDE2MTg0OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbmNvbnN0ICAgIEVYVFJBID0gMTYxODU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG5jb25zdCAgICBOQU1FID0gMTYxODY7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG5jb25zdCAgICBDT01NRU5UID0gMTYxODc7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xuY29uc3QgICAgSENSQyA9IDE2MTg4OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xuY29uc3QgICAgRElDVElEID0gMTYxODk7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIERJQ1QgPSAxNjE5MDsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbmNvbnN0ICAgICAgICBUWVBFID0gMTYxOTE7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuY29uc3QgICAgICAgIFRZUEVETyA9IDE2MTkyOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG5jb25zdCAgICAgICAgU1RPUkVEID0gMTYxOTM7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG5jb25zdCAgICAgICAgQ09QWV8gPSAxNjE5NDsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgQ09QWSA9IDE2MTk1OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG5jb25zdCAgICAgICAgVEFCTEUgPSAxNjE5NjsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIExFTkxFTlMgPSAxNjE5NzsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBDT0RFTEVOUyA9IDE2MTk4OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgICAgIExFTl8gPSAxNjE5OTsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgICAgICBMRU4gPSAxNjIwMDsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBMRU5FWFQgPSAxNjIwMTsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVCA9IDE2MjAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVEVYVCA9IDE2MjAzOyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgTUFUQ0ggPSAxNjIwNDsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xuY29uc3QgICAgICAgICAgICBMSVQgPSAxNjIwNTsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbmNvbnN0ICAgIENIRUNLID0gMTYyMDY7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIExFTkdUSCA9IDE2MjA3OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRE9ORSA9IDE2MjA4OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBCQUQgPSAxNjIwOTsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgTUVNID0gMTYyMTA7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBTWU5DID0gMTYyMTE7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG5jb25zdCBFTk9VR0hfTEVOUyA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmNvbnN0IHpzd2FwMzIgPSAocSkgPT4ge1xuXG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufTtcblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0IDIgdHJ1ZSB0byB2YWxpZGF0ZSBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpLCBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgaWYgcmF3IG9yIG5vIGhlYWRlciB5ZXQgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyBVaW50MTZBcnJheSgzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyBVaW50MTZBcnJheSgyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgSW50MzJBcnJheShFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5cbmNvbnN0IGluZmxhdGVTdGF0ZUNoZWNrID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0pIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICghc3RhdGUgfHwgc3RhdGUuc3RybSAhPT0gc3RybSB8fFxuICAgIHN0YXRlLm1vZGUgPCBIRUFEIHx8IHN0YXRlLm1vZGUgPiBTWU5DKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZmxhZ3MgPSAtMTtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgSW50MzJBcnJheShFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQgPSAoc3RybSkgPT4ge1xuXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcbiAgbGV0IHdyYXA7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoaW5mbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyA1O1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdDIgPSAoc3RybSwgd2luZG93Qml0cykgPT4ge1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUuc3RybSA9IHN0cm07XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5tb2RlID0gSEVBRDsgICAgIC8qIHRvIHBhc3Mgc3RhdGUgdGVzdCBpbiBpbmZsYXRlUmVzZXQyKCkgKi9cbiAgY29uc3QgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdCA9IChzdHJtKSA9PiB7XG5cbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufTtcblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG5sZXQgdmlyZ2luID0gdHJ1ZTtcblxubGV0IGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuXG5jb25zdCBmaXhlZHRhYmxlcyA9IChzdGF0ZSkgPT4ge1xuXG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICBsZW5maXggPSBuZXcgSW50MzJBcnJheSg1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgSW50MzJBcnJheSgzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIGxldCBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn07XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmNvbnN0IHVwZGF0ZXdpbmRvdyA9IChzdHJtLCBzcmMsIGVuZCwgY29weSkgPT4ge1xuXG4gIGxldCBkaXN0O1xuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgVWludDhBcnJheShzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBzdGF0ZS53c2l6ZSwgZW5kKSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCAtIGNvcHkgKyBkaXN0KSwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gY29weSwgZW5kKSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZSA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIGxldCBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICBsZXQgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICBsZXQgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuICBsZXQgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy9sZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIGxldCBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICBsZXQgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgY29uc3QgaGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICBsZXQgb3B0cztcblxuICBsZXQgbjsgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBORUVEX0JJVFNcblxuICBjb25zdCBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIG5ldyBVaW50OEFycmF5KFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdKTtcblxuXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS53Yml0cyA9IDE1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gMTUgfHwgbGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gISEhIHBha28gcGF0Y2guIEZvcmNlIHVzZSBgb3B0aW9ucy53aW5kb3dCaXRzYCBpZiBwYXNzZWQuXG4gICAgICAgIC8vIFJlcXVpcmVkIHRvIGFsd2F5cyB1c2UgbWF4IHdpbmRvdyBzaXplIGJ5IGRlZmF1bHQuXG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgICAgICAvL3N0YXRlLmRtYXggPSAxIDw8IGxlbjtcblxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAgICAgLyogaW5kaWNhdGUgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgJiYgKHN0YXRlLndyYXAgJiA0KSkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgJiYgKHN0YXRlLndyYXAgJiA0KSkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweDAyMDApICYmIChzdGF0ZS53cmFwICYgNCkpIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHgwMjAwKSAmJiAoc3RhdGUud3JhcCAmIDQpKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBVaW50OEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLnNldChcbiAgICAgICAgICAgICAgICBpbnB1dC5zdWJhcnJheShcbiAgICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgICAgbmV4dCArIGNvcHlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHgwMjAwKSAmJiAoc3RhdGUud3JhcCAmIDQpKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgJiYgKHN0YXRlLndyYXAgJiA0KSkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgJiYgKHN0YXRlLndyYXAgJiA0KSkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiA0KSAmJiBob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIG91dHB1dC5zZXQoaW5wdXQuc3ViYXJyYXkobmV4dCwgbmV4dCArIGNvcHkpLCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDQpICYmIF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEVfQ0hFQ0soc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDQpICYmIChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiA0KSAmJiBob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKChzdGF0ZS53cmFwICYgNCkgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFX0NIRUNLKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKGluZmxhdGVTdGF0ZUNoZWNrKHN0cm0pKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgbGV0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5jb25zdCBpbmZsYXRlR2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoaW5mbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVTZXREaWN0aW9uYXJ5ID0gKHN0cm0sIGRpY3Rpb25hcnkpID0+IHtcbiAgY29uc3QgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGRpY3RpZDtcbiAgbGV0IHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoaW5mbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVDb2Rlc1VzZWQgPSBpbmZsYXRlQ29kZXNVc2VkO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlVmFsaWRhdGUgPSBpbmZsYXRlVmFsaWRhdGU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IE1BWEJJVFMgPSAxNTtcbmNvbnN0IEVOT1VHSF9MRU5TID0gODUyO1xuY29uc3QgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy9jb25zdCBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxuY29uc3QgQ09ERVMgPSAwO1xuY29uc3QgTEVOUyA9IDE7XG5jb25zdCBESVNUUyA9IDI7XG5cbmNvbnN0IGxiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl0pO1xuXG5jb25zdCBsZXh0ID0gbmV3IFVpbnQ4QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl0pO1xuXG5jb25zdCBkYmFzZSA9IG5ldyBVaW50MTZBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl0pO1xuXG5jb25zdCBkZXh0ID0gbmV3IFVpbnQ4QXJyYXkoWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl0pO1xuXG5jb25zdCBpbmZsYXRlX3RhYmxlID0gKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpID0+XG57XG4gIGNvbnN0IGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIGxldCBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIGxldCBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICBsZXQgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgbGV0IHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgbGV0IGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgbGV0IGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICBsZXQgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIGxldCB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIGxldCBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICBsZXQgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgbGV0IGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICBsZXQgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgbGV0IG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICBsZXQgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuLy8gIGxldCBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgbGV0IG1hdGNoOyAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID49IG1hdGNoICovXG4gIGNvbnN0IGNvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIGNvbnN0IG9mZnMgPSBuZXcgVWludDE2QXJyYXkoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgbGV0IGV4dHJhID0gbnVsbDtcblxuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgbWF0Y2ggPSAyMDtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIG1hdGNoID0gMjU3O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgbWF0Y2ggPSAwO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dICsgMSA8IG1hdGNoKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPj0gbWF0Y2gpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVt3b3JrW3N5bV0gLSBtYXRjaF07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2Vbd29ya1tzeW1dIC0gbWF0Y2hdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGluZmxhdGVfdGFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLXVuYXJ5LW9wcyAqL1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL2NvbnN0IFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy9jb25zdCBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vY29uc3QgWl9STEUgICAgICAgICAgICAgICA9IDM7XG5jb25zdCBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy9jb25zdCBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuY29uc3QgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbmNvbnN0IFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxuY29uc3QgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyBsZXQgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbmNvbnN0IFNUT1JFRF9CTE9DSyA9IDA7XG5jb25zdCBTVEFUSUNfVFJFRVMgPSAxO1xuY29uc3QgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbmNvbnN0IE1JTl9NQVRDSCAgICA9IDM7XG5jb25zdCBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbmNvbnN0IExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG5jb25zdCBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbmNvbnN0IExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxuY29uc3QgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbmNvbnN0IEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG5jb25zdCBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxuY29uc3QgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbmNvbnN0IEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxuY29uc3QgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbmNvbnN0IFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbmNvbnN0IFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5jb25zdCBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXSk7XG5cbmNvbnN0IGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdKTtcblxuY29uc3QgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XSk7XG5cbmNvbnN0IGJsX29yZGVyID1cbiAgbmV3IFVpbnQ4QXJyYXkoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbmNvbnN0IERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxuY29uc3Qgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbmNvbnN0IHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG5jb25zdCBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbmNvbnN0IF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxuY29uc3QgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbmxldCBzdGF0aWNfbF9kZXNjO1xubGV0IHN0YXRpY19kX2Rlc2M7XG5sZXQgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuY29uc3QgZF9jb2RlID0gKGRpc3QpID0+IHtcblxuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmNvbnN0IHB1dF9zaG9ydCA9IChzLCB3KSA9PiB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmNvbnN0IHNlbmRfYml0cyA9IChzLCB2YWx1ZSwgbGVuZ3RoKSA9PiB7XG5cbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufTtcblxuXG5jb25zdCBzZW5kX2NvZGUgPSAocywgYywgdHJlZSkgPT4ge1xuXG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmNvbnN0IGJpX3JldmVyc2UgPSAoY29kZSwgbGVuKSA9PiB7XG5cbiAgbGV0IHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5jb25zdCBiaV9mbHVzaCA9IChzKSA9PiB7XG5cbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmNvbnN0IGdlbl9iaXRsZW4gPSAocywgZGVzYykgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xuXG4gIGNvbnN0IHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIGNvbnN0IHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICBjb25zdCBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIGNvbnN0IGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIGNvbnN0IGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIGNvbnN0IG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIGxldCBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICBsZXQgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgbGV0IHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIGxldCBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIGxldCBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNldigoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuY29uc3QgZ2VuX2NvZGVzID0gKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkgPT4ge1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xuXG4gIGNvbnN0IG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICBsZXQgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBsZXQgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuY29uc3QgdHJfc3RhdGljX2luaXQgPSAoKSA9PiB7XG5cbiAgbGV0IG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICBsZXQgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICBsZXQgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgbGV0IGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICBjb25zdCBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5jb25zdCBpbml0X2Jsb2NrID0gKHMpID0+IHtcblxuICBsZXQgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5zeW1fbmV4dCA9IHMubWF0Y2hlcyA9IDA7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmNvbnN0IGJpX3dpbmR1cCA9IChzKSA9Plxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5jb25zdCBzbWFsbGVyID0gKHRyZWUsIG4sIG0sIGRlcHRoKSA9PiB7XG5cbiAgY29uc3QgX24yID0gbiAqIDI7XG4gIGNvbnN0IF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuY29uc3QgcHFkb3duaGVhcCA9IChzLCB0cmVlLCBrKSA9PiB7XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG5cbiAgY29uc3QgdiA9IHMuaGVhcFtrXTtcbiAgbGV0IGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufTtcblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyBjb25zdCBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmNvbnN0IGNvbXByZXNzX2Jsb2NrID0gKHMsIGx0cmVlLCBkdHJlZSkgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG5cbiAgbGV0IGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICBsZXQgc3ggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gc3ltX2J1ZiAqL1xuICBsZXQgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgbGV0IGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMuc3ltX25leHQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gcy5wZW5kaW5nX2J1ZltzLnN5bV9idWYgKyBzeCsrXSAmIDB4ZmY7XG4gICAgICBkaXN0ICs9IChzLnBlbmRpbmdfYnVmW3Muc3ltX2J1ZiArIHN4KytdICYgMHhmZikgPDwgODtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLnN5bV9idWYgKyBzeCsrXTtcbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBzeW1fYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQocy0+cGVuZGluZyA8IHMtPmxpdF9idWZzaXplICsgc3gsIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKHN4IDwgcy5zeW1fbmV4dCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5jb25zdCBidWlsZF90cmVlID0gKHMsIGRlc2MpID0+IHtcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cblxuICBjb25zdCB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgbGV0IG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIGxldCBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgbGV0IG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5jb25zdCBzY2FuX3RyZWUgPSAocywgdHJlZSwgbWF4X2NvZGUpID0+IHtcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG5cbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmNvbnN0IHNlbmRfdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG5cbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5jb25zdCBidWlsZF9ibF90cmVlID0gKHMpID0+IHtcblxuICBsZXQgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5jb25zdCBzZW5kX2FsbF90cmVlcyA9IChzLCBsY29kZXMsIGRjb2RlcywgYmxjb2RlcykgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cblxuICBsZXQgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsb2NrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJhbGxvdyBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5jb25zdCBkZXRlY3RfZGF0YV90eXBlID0gKHMpID0+IHtcbiAgLyogYmxvY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxvY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICBsZXQgYmxvY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIGxldCBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibG9jay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxvY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsb2NrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcImFsbG93LWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsb2NrLWxpc3RlZFwiIG9yIFwiYWxsb3ctbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59O1xuXG5cbmxldCBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5jb25zdCBfdHJfaW5pdCA9IChzKSA9Plxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmNvbnN0IF90cl9zdG9yZWRfYmxvY2sgPSAocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSA9PiB7XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cblxuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cbiAgcHV0X3Nob3J0KHMsIHN0b3JlZF9sZW4pO1xuICBwdXRfc2hvcnQocywgfnN0b3JlZF9sZW4pO1xuICBpZiAoc3RvcmVkX2xlbikge1xuICAgIHMucGVuZGluZ19idWYuc2V0KHMud2luZG93LnN1YmFycmF5KGJ1ZiwgYnVmICsgc3RvcmVkX2xlbiksIHMucGVuZGluZyk7XG4gIH1cbiAgcy5wZW5kaW5nICs9IHN0b3JlZF9sZW47XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5jb25zdCBfdHJfYWxpZ24gPSAocykgPT4ge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgd3JpdGUgb3V0IHRoZSBlbmNvZGVkIGJsb2NrLlxuICovXG5jb25zdCBfdHJfZmx1c2hfYmxvY2sgPSAocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSA9PiB7XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xuXG4gIGxldCBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIGxldCBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN5bV9uZXh0IC8gMykpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuY29uc3QgX3RyX3RhbGx5ID0gKHMsIGRpc3QsIGxjKSA9PiB7XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cblxuICBzLnBlbmRpbmdfYnVmW3Muc3ltX2J1ZiArIHMuc3ltX25leHQrK10gPSBkaXN0O1xuICBzLnBlbmRpbmdfYnVmW3Muc3ltX2J1ZiArIHMuc3ltX25leHQrK10gPSBkaXN0ID4+IDg7XG4gIHMucGVuZGluZ19idWZbcy5zeW1fYnVmICsgcy5zeW1fbmV4dCsrXSA9IGxjO1xuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuICByZXR1cm4gKHMuc3ltX25leHQgPT09IHMuc3ltX2VuZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbm1vZHVsZS5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xubW9kdWxlLmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbm1vZHVsZS5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbm1vZHVsZS5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBOQU1FOiBcIk5vZGVCYWxsXCIsXG4gICAgU0VSVkVSX0hPU1Q6IFwiMTI3LjAuMC4xXCIsXG4gICAgU0VSVkVSX1BPUlQ6IDgwOTAsXG4gICAgU0VSVkVSX1VQREFURV9JTlRFUlZBTDogNjBcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb3VyY2VzID0gdm9pZCAwO1xuZXhwb3J0cy5SZXNvdXJjZXMgPSB7XG4gICAgLy8gQVVESU9cbiAgICBLSUNLOiBcImtpY2sud2F2XCIsXG4gICAgSk9JTjogXCJqb2luLndhdlwiLFxuICAgIExFQVZFOiBcImxlYXZlLndhdlwiLFxuICAgIEhJR0hMSUdIVDogXCJoaWdobGlnaHQud2F2XCIsXG4gICAgQ1JPV0Q6IFwiY3Jvd2Qud2F2XCIsXG4gICAgQ0hBVDogXCJjaGF0LndhdlwiLFxuICAgIEdPQUw6IFwiZ29hbC53YXZcIixcbiAgICBOT1RJRjogXCJub3RpZi5tcDNcIixcbiAgICAvLyBJTUFHRVNcbiAgICBUSUxFX0dSQVNTOiBcImdyYXNzLnBuZ1wiLFxuICAgIFRJTEVfSE9DS0VZOiBcImhvY2tleS5wbmdcIixcbiAgICBBVkFUQVJfMTogXCJhdmF0YXJzLzEuc3ZnXCIsXG4gICAgQVZBVEFSXzI6IFwiYXZhdGFycy8yLnN2Z1wiLFxuICAgIEFWQVRBUl8zOiBcImF2YXRhcnMvMy5zdmdcIixcbiAgICBBVkFUQVJfNDogXCJhdmF0YXJzLzQuc3ZnXCIsXG4gICAgQVZBVEFSXzU6IFwiYXZhdGFycy81LnN2Z1wiLFxuICAgIEFWQVRBUl82OiBcImF2YXRhcnMvNi5zdmdcIixcbiAgICBBVkFUQVJfNzogXCJhdmF0YXJzLzcuc3ZnXCIsXG4gICAgQVZBVEFSXzg6IFwiYXZhdGFycy84LnN2Z1wiLFxuICAgIEFWQVRBUl85OiBcImF2YXRhcnMvOS5zdmdcIixcbiAgICBBVkFUQVJfMTA6IFwiYXZhdGFycy8xMC5zdmdcIixcbiAgICBBVkFUQVJfMTE6IFwiYXZhdGFycy8xMS5zdmdcIixcbiAgICBBVkFUQVJfMTI6IFwiYXZhdGFycy8xMi5zdmdcIixcbiAgICBBVkFUQVJfMTM6IFwiYXZhdGFycy8xMy5zdmdcIixcbiAgICBBVkFUQVJfMTQ6IFwiYXZhdGFycy8xNC5zdmdcIixcbiAgICBBVkFUQVJfMTU6IFwiYXZhdGFycy8xNS5zdmdcIixcbiAgICBBVkFUQVJfMTY6IFwiYXZhdGFycy8xNi5zdmdcIixcbiAgICBBVkFUQVJfMTc6IFwiYXZhdGFycy8xNy5zdmdcIixcbiAgICBBVkFUQVJfMTg6IFwiYXZhdGFycy8xOC5zdmdcIixcbiAgICBBVkFUQVJfMTk6IFwiYXZhdGFycy8xOS5zdmdcIixcbiAgICBBVkFUQVJfMjA6IFwiYXZhdGFycy8yMC5zdmdcIixcbiAgICBBVkFUQVJfMjE6IFwiYXZhdGFycy8yMS5zdmdcIixcbiAgICBBVkFUQVJfMjI6IFwiYXZhdGFycy8yMi5zdmdcIixcbiAgICBBVkFUQVJfMjM6IFwiYXZhdGFycy8yMy5zdmdcIixcbiAgICBBVkFUQVJfMjQ6IFwiYXZhdGFycy8yNC5zdmdcIixcbiAgICBBVkFUQVJfMjU6IFwiYXZhdGFycy8yNS5zdmdcIixcbiAgICBBVkFUQVJfMjY6IFwiYXZhdGFycy8yNi5zdmdcIixcbiAgICBBVkFUQVJfMjc6IFwiYXZhdGFycy8yNy5zdmdcIixcbiAgICBBVkFUQVJfMjg6IFwiYXZhdGFycy8yOC5zdmdcIixcbiAgICBBVkFUQVJfMjk6IFwiYXZhdGFycy8yOS5zdmdcIixcbiAgICBBVkFUQVJfMzA6IFwiYXZhdGFycy8zMC5zdmdcIixcbiAgICBBVkFUQVJfMzE6IFwiYXZhdGFycy8zMS5zdmdcIixcbiAgICBBVkFUQVJfMzI6IFwiYXZhdGFycy8zMi5zdmdcIixcbiAgICBBVkFUQVJfMzM6IFwiYXZhdGFycy8zMy5zdmdcIixcbiAgICBBVkFUQVJfMzQ6IFwiYXZhdGFycy8zNC5zdmdcIixcbiAgICBBVkFUQVJfMzU6IFwiYXZhdGFycy8zNS5zdmdcIixcbiAgICBBVkFUQVJfMzY6IFwiYXZhdGFycy8zNi5zdmdcIixcbiAgICBBVkFUQVJfMzc6IFwiYXZhdGFycy8zNy5zdmdcIixcbiAgICBBVkFUQVJfMzg6IFwiYXZhdGFycy8zOC5zdmdcIixcbiAgICBBVkFUQVJfMzk6IFwiYXZhdGFycy8zOS5zdmdcIixcbiAgICBBVkFUQVJfNDA6IFwiYXZhdGFycy80MC5zdmdcIixcbiAgICBBVkFUQVJfNDE6IFwiYXZhdGFycy80MS5zdmdcIixcbiAgICBBVkFUQVJfNDI6IFwiYXZhdGFycy80Mi5zdmdcIixcbiAgICBBVkFUQVJfNDM6IFwiYXZhdGFycy80My5zdmdcIixcbiAgICBBVkFUQVJfNDQ6IFwiYXZhdGFycy80NC5zdmdcIixcbiAgICBBVkFUQVJfNDU6IFwiYXZhdGFycy80NS5zdmdcIixcbiAgICBBVkFUQVJfNDY6IFwiYXZhdGFycy80Ni5zdmdcIixcbiAgICBBVkFUQVJfNDc6IFwiYXZhdGFycy80Ny5zdmdcIixcbiAgICBBVkFUQVJfNDg6IFwiYXZhdGFycy80OC5zdmdcIixcbiAgICBBVkFUQVJfNDk6IFwiYXZhdGFycy80OS5zdmdcIixcbiAgICBBVkFUQVJfNTA6IFwiYXZhdGFycy81MC5zdmdcIixcbiAgICBBVkFUQVJfNTE6IFwiYXZhdGFycy81MS5zdmdcIixcbiAgICBBVkFUQVJfNTI6IFwiYXZhdGFycy81Mi5zdmdcIixcbiAgICBBVkFUQVJfNTM6IFwiYXZhdGFycy81My5zdmdcIixcbiAgICBBVkFUQVJfNTQ6IFwiYXZhdGFycy81NC5zdmdcIixcbiAgICBBVkFUQVJfNTU6IFwiYXZhdGFycy81NS5zdmdcIixcbiAgICBBVkFUQVJfNTY6IFwiYXZhdGFycy81Ni5zdmdcIixcbiAgICBBVkFUQVJfNTc6IFwiYXZhdGFycy81Ny5zdmdcIixcbiAgICBBVkFUQVJfNTg6IFwiYXZhdGFycy81OC5zdmdcIixcbiAgICBBVkFUQVJfNTk6IFwiYXZhdGFycy81OS5zdmdcIixcbiAgICBBVkFUQVJfNjA6IFwiYXZhdGFycy82MC5zdmdcIixcbiAgICBBVkFUQVJfNjE6IFwiYXZhdGFycy82MS5zdmdcIixcbiAgICBBVkFUQVJfNjI6IFwiYXZhdGFycy82Mi5zdmdcIixcbiAgICBBVkFUQVJfNjM6IFwiYXZhdGFycy82My5zdmdcIixcbiAgICBBVkFUQVJfNjQ6IFwiYXZhdGFycy82NC5zdmdcIixcbiAgICBBVkFUQVJfNjU6IFwiYXZhdGFycy82NS5zdmdcIixcbiAgICBBVkFUQVJfNjY6IFwiYXZhdGFycy82Ni5zdmdcIixcbiAgICBBVkFUQVJfNjc6IFwiYXZhdGFycy82Ny5zdmdcIixcbiAgICBBVkFUQVJfNjg6IFwiYXZhdGFycy82OC5zdmdcIixcbiAgICBBVkFUQVJfNjk6IFwiYXZhdGFycy82OS5zdmdcIixcbiAgICBBVkFUQVJfNzA6IFwiYXZhdGFycy83MC5zdmdcIixcbiAgICBBVkFUQVJfNzE6IFwiYXZhdGFycy83MS5zdmdcIixcbiAgICBBVkFUQVJfNzI6IFwiYXZhdGFycy83Mi5zdmdcIixcbiAgICBBVkFUQVJfNzM6IFwiYXZhdGFycy83My5zdmdcIixcbiAgICBBVkFUQVJfNzQ6IFwiYXZhdGFycy83NC5zdmdcIixcbiAgICBBVkFUQVJfNzU6IFwiYXZhdGFycy83NS5zdmdcIixcbiAgICBBVkFUQVJfNzY6IFwiYXZhdGFycy83Ni5zdmdcIixcbiAgICBBVkFUQVJfNzc6IFwiYXZhdGFycy83Ny5zdmdcIixcbiAgICBBVkFUQVJfNzg6IFwiYXZhdGFycy83OC5zdmdcIixcbiAgICBBVkFUQVJfNzk6IFwiYXZhdGFycy83OS5zdmdcIixcbiAgICBBVkFUQVJfODA6IFwiYXZhdGFycy84MC5zdmdcIixcbiAgICBBVkFUQVJfODE6IFwiYXZhdGFycy84MS5zdmdcIixcbiAgICBBVkFUQVJfODI6IFwiYXZhdGFycy84Mi5zdmdcIixcbiAgICBBVkFUQVJfODM6IFwiYXZhdGFycy84My5zdmdcIixcbiAgICBBVkFUQVJfODQ6IFwiYXZhdGFycy84NC5zdmdcIixcbiAgICBBVkFUQVJfODU6IFwiYXZhdGFycy84NS5zdmdcIixcbiAgICBBVkFUQVJfODY6IFwiYXZhdGFycy84Ni5zdmdcIixcbiAgICBBVkFUQVJfODc6IFwiYXZhdGFycy84Ny5zdmdcIixcbiAgICBBVkFUQVJfODg6IFwiYXZhdGFycy84OC5zdmdcIixcbiAgICBBVkFUQVJfODk6IFwiYXZhdGFycy84OS5zdmdcIixcbiAgICBBVkFUQVJfOTA6IFwiYXZhdGFycy85MC5zdmdcIixcbiAgICBBVkFUQVJfOTE6IFwiYXZhdGFycy85MS5zdmdcIixcbiAgICBBVkFUQVJfOTI6IFwiYXZhdGFycy85Mi5zdmdcIixcbiAgICBBVkFUQVJfOTM6IFwiYXZhdGFycy85My5zdmdcIixcbiAgICBBVkFUQVJfOTQ6IFwiYXZhdGFycy85NC5zdmdcIixcbiAgICBBVkFUQVJfOTU6IFwiYXZhdGFycy85NS5zdmdcIixcbiAgICBBVkFUQVJfOTY6IFwiYXZhdGFycy85Ni5zdmdcIixcbiAgICBBVkFUQVJfOTc6IFwiYXZhdGFycy85Ny5zdmdcIixcbiAgICBBVkFUQVJfOTg6IFwiYXZhdGFycy85OC5zdmdcIixcbiAgICBBVkFUQVJfOTk6IFwiYXZhdGFycy85OS5zdmdcIixcbiAgICBBVkFUQVJfMTAwOiBcImF2YXRhcnMvMTAwLnN2Z1wiLFxuICAgIEFWQVRBUl8xMDE6IFwiYXZhdGFycy8xMDEuc3ZnXCIsXG4gICAgQVZBVEFSXzEwMjogXCJhdmF0YXJzLzEwMi5zdmdcIixcbiAgICBBVkFUQVJfMTAzOiBcImF2YXRhcnMvMTAzLnN2Z1wiLFxuICAgIEFWQVRBUl8xMDQ6IFwiYXZhdGFycy8xMDQuc3ZnXCIsXG4gICAgQVZBVEFSXzEwNTogXCJhdmF0YXJzLzEwNS5zdmdcIixcbiAgICBBVkFUQVJfMTA2OiBcImF2YXRhcnMvMTA2LnN2Z1wiLFxuICAgIEFWQVRBUl8xMDc6IFwiYXZhdGFycy8xMDcuc3ZnXCIsXG4gICAgQVZBVEFSXzEwODogXCJhdmF0YXJzLzEwOC5zdmdcIixcbiAgICBBVkFUQVJfMTA5OiBcImF2YXRhcnMvMTA5LnN2Z1wiLFxuICAgIEFWQVRBUl8xMTA6IFwiYXZhdGFycy8xMTAuc3ZnXCIsXG4gICAgQVZBVEFSXzExMTogXCJhdmF0YXJzLzExMS5zdmdcIixcbiAgICBBVkFUQVJfMTEyOiBcImF2YXRhcnMvMTEyLnN2Z1wiLFxuICAgIEFWQVRBUl8xMTM6IFwiYXZhdGFycy8xMTMuc3ZnXCIsXG4gICAgQVZBVEFSXzExNDogXCJhdmF0YXJzLzExNC5zdmdcIixcbiAgICBBVkFUQVJfMTE1OiBcImF2YXRhcnMvMTE1LnN2Z1wiLFxuICAgIEFWQVRBUl8xMTY6IFwiYXZhdGFycy8xMTYuc3ZnXCIsXG4gICAgQVZBVEFSXzExNzogXCJhdmF0YXJzLzExNy5zdmdcIixcbiAgICBBVkFUQVJfMTE4OiBcImF2YXRhcnMvMTE4LnN2Z1wiLFxuICAgIEFWQVRBUl8xMTk6IFwiYXZhdGFycy8xMTkuc3ZnXCIsXG4gICAgQVZBVEFSXzEyMDogXCJhdmF0YXJzLzEyMC5zdmdcIixcbiAgICBBVkFUQVJfMTIxOiBcImF2YXRhcnMvMTIxLnN2Z1wiLFxuICAgIEFWQVRBUl8xMjI6IFwiYXZhdGFycy8xMjIuc3ZnXCIsXG4gICAgQVZBVEFSXzEyMzogXCJhdmF0YXJzLzEyMy5zdmdcIixcbiAgICBBVkFUQVJfMTI0OiBcImF2YXRhcnMvMTI0LnN2Z1wiLFxuICAgIEFWQVRBUl8xMjU6IFwiYXZhdGFycy8xMjUuc3ZnXCIsXG4gICAgQVZBVEFSXzEyNjogXCJhdmF0YXJzLzEyNi5zdmdcIixcbiAgICBBVkFUQVJfMTI3OiBcImF2YXRhcnMvMTI3LnN2Z1wiLFxuICAgIEFWQVRBUl8xMjg6IFwiYXZhdGFycy8xMjguc3ZnXCIsXG4gICAgQVZBVEFSXzEyOTogXCJhdmF0YXJzLzEyOS5zdmdcIixcbiAgICBBVkFUQVJfMTMwOiBcImF2YXRhcnMvMTMwLnN2Z1wiLFxuICAgIEFWQVRBUl8xMzE6IFwiYXZhdGFycy8xMzEuc3ZnXCIsXG4gICAgQVZBVEFSXzEzMjogXCJhdmF0YXJzLzEzMi5zdmdcIixcbiAgICBBVkFUQVJfMTMzOiBcImF2YXRhcnMvMTMzLnN2Z1wiLFxuICAgIEFWQVRBUl8xMzQ6IFwiYXZhdGFycy8xMzQuc3ZnXCIsXG4gICAgQVZBVEFSXzEzNTogXCJhdmF0YXJzLzEzNS5zdmdcIixcbiAgICBBVkFUQVJfMTM2OiBcImF2YXRhcnMvMTM2LnN2Z1wiLFxuICAgIEFWQVRBUl8xMzc6IFwiYXZhdGFycy8xMzcuc3ZnXCIsXG4gICAgQVZBVEFSXzEzODogXCJhdmF0YXJzLzEzOC5zdmdcIixcbiAgICBBVkFUQVJfMTM5OiBcImF2YXRhcnMvMTM5LnN2Z1wiLFxuICAgIEFWQVRBUl8xNDA6IFwiYXZhdGFycy8xNDAuc3ZnXCIsXG4gICAgQVZBVEFSXzE0MTogXCJhdmF0YXJzLzE0MS5zdmdcIixcbiAgICBBVkFUQVJfMTQyOiBcImF2YXRhcnMvMTQyLnN2Z1wiLFxuICAgIEFWQVRBUl8xNDM6IFwiYXZhdGFycy8xNDMuc3ZnXCIsXG4gICAgQVZBVEFSXzE0NDogXCJhdmF0YXJzLzE0NC5zdmdcIixcbiAgICBBVkFUQVJfMTQ1OiBcImF2YXRhcnMvMTQ1LnN2Z1wiLFxuICAgIEFWQVRBUl8xNDY6IFwiYXZhdGFycy8xNDYuc3ZnXCIsXG4gICAgQVZBVEFSXzE0NzogXCJhdmF0YXJzLzE0Ny5zdmdcIixcbiAgICBBVkFUQVJfMTQ4OiBcImF2YXRhcnMvMTQ4LnN2Z1wiLFxuICAgIEFWQVRBUl8xNDk6IFwiYXZhdGFycy8xNDkuc3ZnXCIsXG4gICAgQVZBVEFSXzE1MDogXCJhdmF0YXJzLzE1MC5zdmdcIixcbiAgICBBVkFUQVJfMTUxOiBcImF2YXRhcnMvMTUxLnN2Z1wiLFxuICAgIEFWQVRBUl8xNTI6IFwiYXZhdGFycy8xNTIuc3ZnXCIsXG4gICAgQVZBVEFSXzE1MzogXCJhdmF0YXJzLzE1My5zdmdcIixcbiAgICBBVkFUQVJfMTU0OiBcImF2YXRhcnMvMTU0LnN2Z1wiLFxuICAgIEFWQVRBUl8xNTU6IFwiYXZhdGFycy8xNTUuc3ZnXCIsXG4gICAgQVZBVEFSXzE1NjogXCJhdmF0YXJzLzE1Ni5zdmdcIixcbiAgICBBVkFUQVJfMTU3OiBcImF2YXRhcnMvMTU3LnN2Z1wiLFxuICAgIEFWQVRBUl8xNTg6IFwiYXZhdGFycy8xNTguc3ZnXCIsXG4gICAgQVZBVEFSXzE1OTogXCJhdmF0YXJzLzE1OS5zdmdcIixcbiAgICBBVkFUQVJfMTYwOiBcImF2YXRhcnMvMTYwLnN2Z1wiLFxuICAgIEFWQVRBUl8xNjE6IFwiYXZhdGFycy8xNjEuc3ZnXCIsXG4gICAgQVZBVEFSXzE2MjogXCJhdmF0YXJzLzE2Mi5zdmdcIixcbiAgICBBVkFUQVJfMTYzOiBcImF2YXRhcnMvMTYzLnN2Z1wiLFxuICAgIEFWQVRBUl8xNjQ6IFwiYXZhdGFycy8xNjQuc3ZnXCIsXG4gICAgQVZBVEFSXzE2NTogXCJhdmF0YXJzLzE2NS5zdmdcIixcbiAgICBBVkFUQVJfMTY2OiBcImF2YXRhcnMvMTY2LnN2Z1wiLFxuICAgIEFWQVRBUl8xNjc6IFwiYXZhdGFycy8xNjcuc3ZnXCIsXG4gICAgQVZBVEFSXzE2ODogXCJhdmF0YXJzLzE2OC5zdmdcIixcbiAgICBBVkFUQVJfMTY5OiBcImF2YXRhcnMvMTY5LnN2Z1wiLFxuICAgIEFWQVRBUl8xNzA6IFwiYXZhdGFycy8xNzAuc3ZnXCIsXG4gICAgQVZBVEFSXzE3MTogXCJhdmF0YXJzLzE3MS5zdmdcIixcbiAgICBBVkFUQVJfMTcyOiBcImF2YXRhcnMvMTcyLnN2Z1wiLFxuICAgIEFWQVRBUl8xNzM6IFwiYXZhdGFycy8xNzMuc3ZnXCIsXG4gICAgQVZBVEFSXzE3NDogXCJhdmF0YXJzLzE3NC5zdmdcIixcbiAgICBBVkFUQVJfMTc1OiBcImF2YXRhcnMvMTc1LnN2Z1wiLFxuICAgIEFWQVRBUl8xNzY6IFwiYXZhdGFycy8xNzYuc3ZnXCIsXG4gICAgQVZBVEFSXzE3NzogXCJhdmF0YXJzLzE3Ny5zdmdcIixcbiAgICBBVkFUQVJfMTc4OiBcImF2YXRhcnMvMTc4LnN2Z1wiLFxuICAgIEFWQVRBUl8xNzk6IFwiYXZhdGFycy8xNzkuc3ZnXCIsXG4gICAgQVZBVEFSXzE4MDogXCJhdmF0YXJzLzE4MC5zdmdcIixcbiAgICBBVkFUQVJfMTgxOiBcImF2YXRhcnMvMTgxLnN2Z1wiLFxuICAgIEFWQVRBUl8xODI6IFwiYXZhdGFycy8xODIuc3ZnXCIsXG4gICAgQVZBVEFSXzE4MzogXCJhdmF0YXJzLzE4My5zdmdcIixcbiAgICBBVkFUQVJfMTg0OiBcImF2YXRhcnMvMTg0LnN2Z1wiLFxuICAgIEFWQVRBUl8xODU6IFwiYXZhdGFycy8xODUuc3ZnXCIsXG4gICAgQVZBVEFSXzE4NjogXCJhdmF0YXJzLzE4Ni5zdmdcIixcbiAgICBBVkFUQVJfMTg3OiBcImF2YXRhcnMvMTg3LnN2Z1wiLFxuICAgIEFWQVRBUl8xODg6IFwiYXZhdGFycy8xODguc3ZnXCIsXG4gICAgQVZBVEFSXzE4OTogXCJhdmF0YXJzLzE4OS5zdmdcIixcbiAgICBBVkFUQVJfMTkwOiBcImF2YXRhcnMvMTkwLnN2Z1wiLFxuICAgIEFWQVRBUl8xOTE6IFwiYXZhdGFycy8xOTEuc3ZnXCIsXG4gICAgQVZBVEFSXzE5MjogXCJhdmF0YXJzLzE5Mi5zdmdcIixcbiAgICBBVkFUQVJfMTkzOiBcImF2YXRhcnMvMTkzLnN2Z1wiLFxuICAgIEFWQVRBUl8xOTQ6IFwiYXZhdGFycy8xOTQuc3ZnXCIsXG4gICAgQVZBVEFSXzE5NTogXCJhdmF0YXJzLzE5NS5zdmdcIixcbiAgICBBVkFUQVJfMTk2OiBcImF2YXRhcnMvMTk2LnN2Z1wiLFxuICAgIEFWQVRBUl8xOTc6IFwiYXZhdGFycy8xOTcuc3ZnXCIsXG4gICAgQVZBVEFSXzE5ODogXCJhdmF0YXJzLzE5OC5zdmdcIixcbiAgICBBVkFUQVJfMTk5OiBcImF2YXRhcnMvMTk5LnN2Z1wiLFxuICAgIEFWQVRBUl8yMDA6IFwiYXZhdGFycy8yMDAuc3ZnXCIsXG4gICAgQVZBVEFSXzIwMTogXCJhdmF0YXJzLzIwMS5zdmdcIixcbiAgICBBVkFUQVJfMjAyOiBcImF2YXRhcnMvMjAyLnN2Z1wiLFxuICAgIEFWQVRBUl8yMDM6IFwiYXZhdGFycy8yMDMuc3ZnXCIsXG4gICAgQVZBVEFSXzIwNDogXCJhdmF0YXJzLzIwNC5zdmdcIixcbiAgICBBVkFUQVJfMjA1OiBcImF2YXRhcnMvMjA1LnN2Z1wiLFxuICAgIEFWQVRBUl8yMDY6IFwiYXZhdGFycy8yMDYuc3ZnXCIsXG4gICAgQVZBVEFSXzIwNzogXCJhdmF0YXJzLzIwNy5zdmdcIixcbiAgICBBVkFUQVJfMjA4OiBcImF2YXRhcnMvMjA4LnN2Z1wiLFxuICAgIEFWQVRBUl8yMDk6IFwiYXZhdGFycy8yMDkuc3ZnXCIsXG4gICAgQVZBVEFSXzIxMDogXCJhdmF0YXJzLzIxMC5zdmdcIixcbiAgICBBVkFUQVJfMjExOiBcImF2YXRhcnMvMjExLnN2Z1wiLFxuICAgIEFWQVRBUl8yMTI6IFwiYXZhdGFycy8yMTIuc3ZnXCIsXG4gICAgQVZBVEFSXzIxMzogXCJhdmF0YXJzLzIxMy5zdmdcIixcbiAgICBBVkFUQVJfMjE0OiBcImF2YXRhcnMvMjE0LnN2Z1wiLFxuICAgIEFWQVRBUl8yMTU6IFwiYXZhdGFycy8yMTUuc3ZnXCIsXG4gICAgQVZBVEFSXzIxNjogXCJhdmF0YXJzLzIxNi5zdmdcIixcbiAgICBBVkFUQVJfMjE3OiBcImF2YXRhcnMvMjE3LnN2Z1wiLFxuICAgIEFWQVRBUl8yMTg6IFwiYXZhdGFycy8yMTguc3ZnXCIsXG4gICAgQVZBVEFSXzIxOTogXCJhdmF0YXJzLzIxOS5zdmdcIixcbiAgICBBVkFUQVJfMjIwOiBcImF2YXRhcnMvMjIwLnN2Z1wiLFxuICAgIEFWQVRBUl8yMjE6IFwiYXZhdGFycy8yMjEuc3ZnXCIsXG4gICAgQVZBVEFSXzIyMjogXCJhdmF0YXJzLzIyMi5zdmdcIixcbiAgICBBVkFUQVJfMjIzOiBcImF2YXRhcnMvMjIzLnN2Z1wiLFxuICAgIEFWQVRBUl8yMjQ6IFwiYXZhdGFycy8yMjQuc3ZnXCIsXG4gICAgQVZBVEFSXzIyNTogXCJhdmF0YXJzLzIyNS5zdmdcIixcbiAgICBBVkFUQVJfMjI2OiBcImF2YXRhcnMvMjI2LnN2Z1wiLFxuICAgIEFWQVRBUl8yMjc6IFwiYXZhdGFycy8yMjcuc3ZnXCIsXG4gICAgQVZBVEFSXzIyODogXCJhdmF0YXJzLzIyOC5zdmdcIixcbiAgICBBVkFUQVJfMjI5OiBcImF2YXRhcnMvMjI5LnN2Z1wiLFxuICAgIEFWQVRBUl8yMzA6IFwiYXZhdGFycy8yMzAuc3ZnXCIsXG4gICAgQVZBVEFSXzIzMTogXCJhdmF0YXJzLzIzMS5zdmdcIixcbiAgICBBVkFUQVJfMjMyOiBcImF2YXRhcnMvMjMyLnN2Z1wiLFxuICAgIEFWQVRBUl8yMzM6IFwiYXZhdGFycy8yMzMuc3ZnXCIsXG4gICAgQVZBVEFSXzIzNDogXCJhdmF0YXJzLzIzNC5zdmdcIixcbiAgICBBVkFUQVJfMjM1OiBcImF2YXRhcnMvMjM1LnN2Z1wiLFxuICAgIEFWQVRBUl8yMzY6IFwiYXZhdGFycy8yMzYuc3ZnXCIsXG4gICAgQVZBVEFSXzIzNzogXCJhdmF0YXJzLzIzNy5zdmdcIixcbiAgICBBVkFUQVJfMjM4OiBcImF2YXRhcnMvMjM4LnN2Z1wiLFxuICAgIEFWQVRBUl8yMzk6IFwiYXZhdGFycy8yMzkuc3ZnXCIsXG4gICAgQVZBVEFSXzI0MDogXCJhdmF0YXJzLzI0MC5zdmdcIixcbiAgICBBVkFUQVJfMjQxOiBcImF2YXRhcnMvMjQxLnN2Z1wiLFxuICAgIEFWQVRBUl8yNDI6IFwiYXZhdGFycy8yNDIuc3ZnXCIsXG4gICAgQVZBVEFSXzI0MzogXCJhdmF0YXJzLzI0My5zdmdcIixcbiAgICBBVkFUQVJfMjQ0OiBcImF2YXRhcnMvMjQ0LnN2Z1wiLFxuICAgIEFWQVRBUl8yNDU6IFwiYXZhdGFycy8yNDUuc3ZnXCIsXG4gICAgQVZBVEFSXzI0NjogXCJhdmF0YXJzLzI0Ni5zdmdcIixcbiAgICBBVkFUQVJfMjQ3OiBcImF2YXRhcnMvMjQ3LnN2Z1wiLFxuICAgIEFWQVRBUl8yNDg6IFwiYXZhdGFycy8yNDguc3ZnXCIsXG4gICAgQVZBVEFSXzI0OTogXCJhdmF0YXJzLzI0OS5zdmdcIixcbiAgICBBVkFUQVJfMjUwOiBcImF2YXRhcnMvMjUwLnN2Z1wiLFxuICAgIEFWQVRBUl8yNTE6IFwiYXZhdGFycy8yNTEuc3ZnXCIsXG4gICAgQVZBVEFSXzI1MjogXCJhdmF0YXJzLzI1Mi5zdmdcIixcbiAgICBBVkFUQVJfMjUzOiBcImF2YXRhcnMvMjUzLnN2Z1wiLFxuICAgIEFWQVRBUl8yNTQ6IFwiYXZhdGFycy8yNTQuc3ZnXCIsXG4gICAgQVZBVEFSXzI1NTogXCJhdmF0YXJzLzI1NS5zdmdcIixcbiAgICBBVkFUQVJfMjU2OiBcImF2YXRhcnMvMjU2LnN2Z1wiLFxuICAgIEFWQVRBUl8yNTc6IFwiYXZhdGFycy8yNTcuc3ZnXCIsXG4gICAgQVZBVEFSXzI1ODogXCJhdmF0YXJzLzI1OC5zdmdcIixcbiAgICBBVkFUQVJfMjU5OiBcImF2YXRhcnMvMjU5LnN2Z1wiLFxuICAgIEFWQVRBUl8yNjA6IFwiYXZhdGFycy8yNjAuc3ZnXCIsXG4gICAgQVZBVEFSXzI2MTogXCJhdmF0YXJzLzI2MS5zdmdcIixcbiAgICBBVkFUQVJfMjYyOiBcImF2YXRhcnMvMjYyLnN2Z1wiLFxuICAgIEFWQVRBUl8yNjM6IFwiYXZhdGFycy8yNjMuc3ZnXCIsXG4gICAgQVZBVEFSXzI2NDogXCJhdmF0YXJzLzI2NC5zdmdcIixcbiAgICBBVkFUQVJfMjY1OiBcImF2YXRhcnMvMjY1LnN2Z1wiLFxuICAgIEFWQVRBUl8yNjY6IFwiYXZhdGFycy8yNjYuc3ZnXCIsXG4gICAgQVZBVEFSXzI2NzogXCJhdmF0YXJzLzI2Ny5zdmdcIixcbiAgICBBVkFUQVJfMjY4OiBcImF2YXRhcnMvMjY4LnN2Z1wiLFxuICAgIEFWQVRBUl8yNjk6IFwiYXZhdGFycy8yNjkuc3ZnXCIsXG4gICAgQVZBVEFSXzI3MDogXCJhdmF0YXJzLzI3MC5zdmdcIixcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVOXzEgPSByZXF1aXJlKFwiLi9MaXN0L0VOXCIpO1xuY29uc3QgRlJfMSA9IHJlcXVpcmUoXCIuL0xpc3QvRlJcIik7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgRU46IEVOXzEuRU4sXG4gICAgRlI6IEZSXzEuRlJcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG1haW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWFpblwiKSk7XG5jb25zdCBMYW5ndWFnZUxpc3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9MYW5ndWFnZUxpc3RcIikpO1xuY2xhc3MgTGFuZ3VhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGFuZ3VhZ2UgPSBMYW5ndWFnZUxpc3RfMS5kZWZhdWx0LkVOO1xuICAgICAgICB0aGlzLmFjdGl2ZUxhbmd1YWdlID0gbnVsbDtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgbWFpbl8xLmRlZmF1bHQubG9nZ2VyLnNlbmRMb2coXCJJTkZPXCIsIFwiSW5pdGlsaWF6aW5nIGxhbmd1YWdlcy4uLlwiKTtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VTdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImxhbmd1YWdlXCIpO1xuICAgICAgICBpZiAobGFuZ3VhZ2VTdG9yZWQgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldExhbmd1YWdlKGxhbmd1YWdlU3RvcmVkKTtcbiAgICAgICAgY29uc3QgdXNlckxhbmd1YWdlID0gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSB8fCB3aW5kb3cubmF2aWdhdG9yLnVzZXJMYW5ndWFnZTtcbiAgICAgICAgaWYgKHVzZXJMYW5ndWFnZSAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZXRMYW5ndWFnZSh1c2VyTGFuZ3VhZ2Uuc3Vic3RyaW5nKDAsIDIpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5hY3RpdmVMYW5ndWFnZSA9IHRoaXMuZGVmYXVsdExhbmd1YWdlO1xuICAgIH1cbiAgICBzZXRMYW5ndWFnZShjb2RlKSB7XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlVmFsdWUgPSB0aGlzLmdldExhbmd1YWdlQnlDb2RlKGNvZGUpO1xuICAgICAgICBpZiAobGFuZ3VhZ2VWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImxhbmd1YWdlXCIsIGNvZGUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUxhbmd1YWdlID0gbGFuZ3VhZ2VWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUxhbmd1YWdlID0gdGhpcy5kZWZhdWx0TGFuZ3VhZ2U7XG4gICAgfVxuICAgIGdldExhbmd1YWdlQnlDb2RlKGNvZGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiBMYW5ndWFnZUxpc3RfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICBpZiAoY29kZS50b1VwcGVyQ2FzZSgpID09IGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExhbmd1YWdlTGlzdF8xLmRlZmF1bHRbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEF2YWlsYWJsZUxhbmd1YWdlcygpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlTGFuZ3VhZ2UgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSBpbiBMYW5ndWFnZUxpc3RfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICBhdmFpbGFibGVMYW5ndWFnZS5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdmFpbGFibGVMYW5ndWFnZTtcbiAgICB9XG4gICAgZ2V0VmFsdWVGb3JLZXkoa2V5LCBwYXJhbXMgPSBbXSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVMYW5ndWFnZSAhPSBudWxsICYmIHRoaXMuYWN0aXZlTGFuZ3VhZ2Vba2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtICE9IG51bGwgJiYgcGFyYW0udG9TdHJpbmcoKS5zdGFydHNXaXRoKFwiJVRSQURfXCIpKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbaW5kZXhdID0gdGhpcy5nZXRWYWx1ZUZvcktleShwYXJhbS5yZXBsYWNlKFwiJVRSQURfXCIsIFwiXCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlTGFuZ3VhZ2Vba2V5XS5zdXBwbGFudChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdExhbmd1YWdlW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtICE9IG51bGwgJiYgcGFyYW0udG9TdHJpbmcoKS5zdGFydHNXaXRoKFwiJVRSQURfXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2luZGV4XSA9IHRoaXMuZ2V0VmFsdWVGb3JLZXkocGFyYW0ucmVwbGFjZShcIiVUUkFEX1wiLCBcIlwiKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdExhbmd1YWdlW2tleV0uc3VwcGxhbnQocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJNaXNzaW5nIGtleTogXCIgKyBrZXk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTGFuZ3VhZ2VNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVOID0gdm9pZCAwO1xuZXhwb3J0cy5FTiA9IHtcbiAgICBDT0RFOiBcIkVOXCIsXG4gICAgLy8gTE9BRElOR1xuICAgIExPQURJTkdfTUVTU0FHRTogXCJJbml0aWFsaXppbmcgezB9Li4uXCIsXG4gICAgTE9BRElOR19SRVNPVVJDRVM6IFwiTG9hZGluZyByZXNvdXJjZXMuLi5cIixcbiAgICBMT0FESU5HX0NPTk5FQ1RJT05fVE9fTUFJTl9TRVJWRVI6IFwiQ29ubmVjdGluZyB0byBtYWluIHNlcnZlci4uLlwiLFxuICAgIExPQURJTkdfRkVUQ0hJTkdfUkVHSU9OX1NFUlZFUlM6IFwiRmV0Y2hpbmcgcmVnaW9uIHNlcnZlcnMuLi5cIixcbiAgICAvLyBHRU5FUklDX0VSUk9SXG4gICAgR0VORVJJQ19FUlJPUl9DT05ORUNUSU9OX0xPU1Q6IFwiQ29ubmVjdGlvbiB0byBzZXJ2ZXIgbG9zdC5cIixcbiAgICBHRU5FUklDX0VSUk9SX1NFUlZFUlM6IFwiQW4gZXJyb3Igb2NjdXJyZWQgd2l0aCBzZXJ2ZXJzLlwiLFxuICAgIEdFTkVSSUNfRVJST1JfTk9fU0VSVkVSX0FWQUlMQUJMRTogXCJUaGVyZSBhcmUgbm8gc2VydmVycyBhdmFpbGFibGUuXCIsXG4gICAgLy8gQUNDT1VOVFxuICAgIEFDQ09VTlRfTEFOR1VBR0U6IFwiTGFuZ3VhZ2VcIixcbiAgICBBQ0NPVU5UX0xPR0lOOiBcIkxvZ2luXCIsXG4gICAgQUNDT1VOVF9SRUdJU1RFUjogXCJSZWdpc3RlclwiLFxuICAgIEFDQ09VTlRfVVNFUk5BTUU6IFwiVXNlcm5hbWVcIixcbiAgICBBQ0NPVU5UX1BBU1NXT1JEOiBcIlBhc3N3b3JkXCIsXG4gICAgQUNDT1VOVF9DT05GSVJNX1BBU1NXT1JEOiBcIkNvbmZpcm0geW91ciBwYXNzd29yZFwiLFxuICAgIEFDQ09VTlRfU0VSVkVSOiBcIlNlcnZlciBbezB9XSAtIFBpbmc6IHsxfW1zXCIsXG4gICAgLy8gQUNDT1VOVF9FUlJPUlxuICAgIEFDQ09VTlRfRVJST1JfQkFOTkVEOiBcIllvdSBhcmUgYmFubmVkIHVudGlsIHRoZSB7MH0uXCIsXG4gICAgQUNDT1VOVF9FUlJPUl9PQ0NVUkVEOiBcIkFuIGVycm9yIG9jY3VyZWQsIHBsZWFzZSByZWxvYWQgdGhlIHBhZ2UuXCIsXG4gICAgQUNDT1VOVF9FUlJPUl9GSUVMRFM6IFwiUGxlYXNlIGNvbXBsZXRlIGFsbCBmaWVsZHMuXCIsXG4gICAgQUNDT1VOVF9FUlJPUl9BTFJFQURZX0xPR0dFRDogXCJZb3UgYXJlIGFscmVhZHkgbG9nZ2VkLlwiLFxuICAgIEFDQ09VTlRfRVJST1JfSU5WQUxJRDogXCJJbnZhbGlkIHVzZXJuYW1lIG9yIHBhc3N3b3JkLlwiLFxuICAgIEFDQ09VTlRfRVJST1JfVVNFUk5BTUVfTEVOR1RIOiBcIllvdXIgbmlja25hbWUgbXVzdCBiZSBiZXR3ZWVuIDMgYW5kIDE1IGNoYXJhY3RlcnMgbG9uZy5cIixcbiAgICBBQ0NPVU5UX0VSUk9SX1VTRVJOQU1FX0FMUEhBTlVNRVJJQzogXCJZb3VyIG5pY2tuYW1lIG11c3QgYmUgYWxwaGFudW1lcmljLlwiLFxuICAgIEFDQ09VTlRfRVJST1JfVVNFUk5BTUVfQUxSRUFEWV9VU0VEOiBcIllvdXIgbmlja25hbWUgaXMgYWxyZWFkeSB1c2VkLlwiLFxuICAgIEFDQ09VTlRfRVJST1JfVVNFUk5BTUVfU1RBUlRfTlVNQkVSOiBcIllvdXIgbmlja25hbWUgY2Fubm90IHN0YXJ0IHdpdGggYSBudW1iZXIuXCIsXG4gICAgQUNDT1VOVF9FUlJPUl9QQVNTV09SRF9MRU5HVEg6IFwiWW91ciBwYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nLlwiLFxuICAgIEFDQ09VTlRfRVJST1JfUEFTU1dPUkRTX0RJRkZFUkVOVDogXCJZb3VyIHR3byBwYXNzd29yZHMgYXJlIGRpZmZlcmVudC5cIixcbiAgICBBQ0NPVU5UX0lOVkFMSURfU0VSVkVSOiBcIlRoZSBzZWxlY3RlZCBzZXJ2ZXIgaXMgbm90IGF2YWlsYWJsZS5cIixcbiAgICAvLyBHQU1FXG4gICAgLy8gR0FNRV9HRU5FUkFMXG4gICAgR0FNRV9HRU5FUkFMX0xPQURJTkc6IFwiTG9hZGluZy4uLlwiLFxuICAgIEdBTUVfR0VORVJBTF9DTE9TRTogXCJDbG9zZVwiLFxuICAgIEdBTUVfR0VORVJBTF9PVkVSVElNRTogXCJPdmVydGltZSFcIixcbiAgICBHQU1FX0dFTkVSQUxfUEFVU0U6IFwiUGF1c2VcIixcbiAgICBHQU1FX0dFTkVSQUxfT1dOX0dPQUw6IFwiT3duIGdvYWwgYnkgPHNwYW4gY2xhc3M9J3swfSc+ezF9PC9zcGFuPiFcIixcbiAgICBHQU1FX0dFTkVSQUxfR09BTDogXCJHb2FsIGJ5IDxzcGFuIGNsYXNzPSd7MH0nPnsxfTwvc3Bhbj4hXCIsXG4gICAgR0FNRV9HRU5FUkFMX05PVF9BVkFJTEFCTEU6IFwiTm90IGF2YWlsYWJsZSB5ZXQuLi5cIixcbiAgICBHQU1FX0dFTkVSQUxfVEVBTTogXCJUZWFtXCIsXG4gICAgR0FNRV9HRU5FUkFMX1BMQVlFUjogXCJQbGF5ZXJcIixcbiAgICBHQU1FX0dFTkVSQUxfQllfUExBWUVSOiBcIkJ5IHBsYXllclwiLFxuICAgIEdBTUVfR0VORVJBTF9BQ1RJT046IFwiQWN0aW9uXCIsXG4gICAgR0FNRV9HRU5FUkFMX0RBVEU6IFwiRGF0ZVwiLFxuICAgIEdBTUVfR0VORVJBTF9UWVBFOiBcIlR5cGVcIixcbiAgICBHQU1FX0dFTkVSQUxfRVhQSVJFOiBcIkV4cGlyZVwiLFxuICAgIEdBTUVfR0VORVJBTF9WQUxJREFURTogXCJWYWxpZGF0ZVwiLFxuICAgIC8vIFRFQU1cbiAgICBHQU1FX1RFQU1fU1BFQ1RBVE9SUzogXCJTcGVjdGF0b3JzXCIsXG4gICAgR0FNRV9URUFNX1JFRDogXCJSZWRcIixcbiAgICBHQU1FX1RFQU1fQkxVRTogXCJCbHVlXCIsXG4gICAgLy8gR0FNRV9DSEFUXG4gICAgR0FNRV9DSEFUX01FU1NBR0U6IFwiTWVzc2FnZS4uLlwiLFxuICAgIEdBTUVfQ0hBVF9PUFRJT05fUk9PTTogXCJSb29tXCIsXG4gICAgR0FNRV9DSEFUX09QVElPTl9URUFNOiBcIlRlYW1cIixcbiAgICBHQU1FX0NIQVRfUk9PTV9KT0lORUQ6IFwiWW91IGp1c3Qgam9pbmVkIHRoZSByb29tIHswfSwgdHlwZSAvcm9vbSA8cm9vbU5hbWU+IHRvIGNoYW5nZSByb29tLlwiLFxuICAgIEdBTUVfQ0hBVF9QTV9GUk9NOiBcIldoaXNwZXIgZnJvbSB7MH1cIixcbiAgICBHQU1FX0NIQVRfUE1fVE86IFwiV2hpc3BlciB0byB7MH1cIixcbiAgICBHQU1FX0NIQVRfUE1fT0ZGTElORTogXCJ7MH0gaXMgb2ZmbGluZS5cIixcbiAgICBHQU1FX0NIQVRfRlJJRU5EX0FEREVEOiBcInswfSBpcyBub3cgeW91ciBmcmllbmQuXCIsXG4gICAgR0FNRV9DSEFUX0ZSSUVORF9PVEhFUl9BRERFRDogXCJ7MH0gYWRkZWQgeW91IHRvIHRoZWlyIGZyaWVuZHMgbGlzdC4gVHlwZSAvZnJpZW5kIHswfSB0byBhZGQgaGltIGJhY2suXCIsXG4gICAgR0FNRV9DSEFUX0ZSSUVORF9PVEhFUl9BRERFRF9CQUNLOiBcInswfSBhZGRlZCB5b3UgYmFjayB0byB0aGVpciBmcmllbmQgbGlzdC5cIixcbiAgICBHQU1FX0NIQVRfSk9JTl9ST09NOiBcInswfSBqb2luZWQgdGhlIHJvb20uXCIsXG4gICAgR0FNRV9DSEFUX0xFRlRfUk9PTTogXCJ7MH0gbGVmdCB0aGUgcm9vbS5cIixcbiAgICBHQU1FX0NIQVRfRlJJRU5EX0xPR0lOOiBcInswfSBqdXN0IGxvZ2dlZCBpbi5cIixcbiAgICBHQU1FX0NIQVRfRlJJRU5EX0xPR09VVDogXCJ7MH0ganVzdCBsb2dnZWQgb3V0LlwiLFxuICAgIEdBTUVfQ0hBVF9GUklFTkRfRVJST1JfTUFYOiBcIllvdSBoYXZlIHJlYWNoZWQgdGhlIGxpbWl0IG9mIHswfSBmcmllbmRzLlwiLFxuICAgIEdBTUVfQ0hBVF9JTlZBTElEX0NPTU1BTkQ6IFwiSW52YWxpZCBjb21tYW5kLlwiLFxuICAgIEdBTUVfQ0hBVF9NVVRFRF9NSU5VVEVTOiBcIllvdSBhcmUgbXV0ZWQgZm9yIHswfSBtaW51dGUocykuXCIsXG4gICAgR0FNRV9DSEFUX01VVEVEX0hPVVJTOiBcIllvdSBhcmUgbXV0ZWQgZm9yIHswfSBob3VycyhzKS5cIixcbiAgICBHQU1FX0NIQVRfTkVXX1JFUE9SVDogXCJOZXcgcmVwb3J0IGJ5IHswfS5cIixcbiAgICBHQU1FX0NIQVRfUkVQT1JURUQ6IFwiezB9IGhhcyBiZWVuIHJlcG9ydGVkLlwiLFxuICAgIEdBTUVfQ0hBVF9BTFJFQURZX1JFUE9SVEVEOiBcIllvdSBoYXZlIGFscmVhZHkgcmVwb3J0ZWQgezB9LlwiLFxuICAgIEdBTUVfQ0hBVF9SRUJPT1RfQ0FOQ0VMOiBcIlNlcnZlciByZXN0YXJ0IHdhcyBjYW5jZWxlZC5cIixcbiAgICBHQU1FX0NIQVRfUkVCT09UX01JTlVURVM6IFwiVGhlIHNlcnZlciB3aWxsIHJlc3RhcnQgaW4gezB9IG1pbnV0ZXMuXCIsXG4gICAgR0FNRV9DSEFUX1JFQk9PVF9TRUNPTkRTOiBcIlRoZSBzZXJ2ZXIgd2lsbCByZXN0YXJ0IGluIHswfSBzZWNvbmRzLlwiLFxuICAgIEdBTUVfQ0hBVF9MRVZFTF9VUDogXCJZb3UgYXJlIG5vdyBsZXZlbCB7MH0uXCIsXG4gICAgR0FNRV9DSEFUX1JBTktfVVA6IFwiWW91IGFyZSBub3cgezB9IHsxfS5cIixcbiAgICAvLyBHQU1FX1VTRVJfTUVOVVxuICAgIEdBTUVfVVNFUl9NRU5VX1BST0ZJTEU6IFwiUHJvZmlsZVwiLFxuICAgIEdBTUVfVVNFUl9NRU5VX1dISVNQRVI6IFwiV2hpc3BlclwiLFxuICAgIEdBTUVfVVNFUl9NRU5VX0ZSSUVORDogXCJBZGQgYXMgZnJpZW5kXCIsXG4gICAgR0FNRV9VU0VSX01FTlVfUkVQT1JUOiBcIlJlcG9ydFwiLFxuICAgIEdBTUVfVVNFUl9NRU5VX01VVEU6IFwiTXV0ZVwiLFxuICAgIEdBTUVfVVNFUl9NRU5VX0JBTjogXCJCYW5cIixcbiAgICAvLyBHQU1FX1NFVFRJTkdTXG4gICAgR0FNRV9TRVRUSU5HUzogXCJTZXR0aW5nc1wiLFxuICAgIEdBTUVfTUVOVV9HUkFQSElDUzogXCJHcmFwaGljc1wiLFxuICAgIEdBTUVfTUVOVV9HUkFQSElDU19aT09NOiBcIlpvb21cIixcbiAgICBHQU1FX01FTlVfR1JBUEhJQ1NfRlBTOiBcIkZQUyBMaW1pdFwiLFxuICAgIEdBTUVfTUVOVV9HUkFQSElDU19GUFNfTk9fTElNSVQ6IFwiTm9uZVwiLFxuICAgIEdBTUVfTUVOVV9BVURJTzogXCJBdWRpb1wiLFxuICAgIEdBTUVfTUVOVV9BVURJT19HRU5FUkFMOiBcIkdlbmVyYWxcIixcbiAgICBHQU1FX01FTlVfQVVESU9fQ0hBVDogXCJDaGF0XCIsXG4gICAgR0FNRV9NRU5VX0FVRElPX0dBTUU6IFwiR2FtZVwiLFxuICAgIEdBTUVfTUVOVV9BVURJT19OT1RJRklDQVRJT046IFwiTm90aWZpY2F0aW9uXCIsXG4gICAgR0FNRV9NRU5VX0lOUFVUUzogXCJJbnB1dHNcIixcbiAgICBHQU1FX01FTlVfSU5QVVRTX1BSRVNTOiBcIlByZXNzIGEga2V5XCIsXG4gICAgR0FNRV9NRU5VX0lOUFVUU19VUDogXCJVcFwiLFxuICAgIEdBTUVfTUVOVV9JTlBVVFNfRE9XTjogXCJEb3duXCIsXG4gICAgR0FNRV9NRU5VX0lOUFVUU19MRUZUOiBcIkxlZnRcIixcbiAgICBHQU1FX01FTlVfSU5QVVRTX1JJR0hUOiBcIlJpZ2h0XCIsXG4gICAgR0FNRV9NRU5VX0lOUFVUU19LSUNLOiBcIktpY2tcIixcbiAgICBHQU1FX01FTlVfSU5QVVRTX1RPR0dMRV9DSEFUOiBcIlRvZ2dsZSBjaGF0XCIsXG4gICAgLy8gR0FNRV9TVEFUU1xuICAgIEdBTUVfU1RBVFNfUkVHSVNURVJFRDogXCJSZWdpc3RlcmVkXCIsXG4gICAgR0FNRV9TVEFUU19MRVZFTF9YUDogXCJMZXZlbFwiLFxuICAgIEdBTUVfU1RBVFNfRUxPOiBcIlJhbmtcIixcbiAgICBHQU1FX1NUQVRTX0dBTUVTOiBcIkdhbWVzXCIsXG4gICAgR0FNRV9TVEFUU19HQU1FU19QTEFZRUQ6IFwiR2FtZXMgcGxheWVkXCIsXG4gICAgR0FNRV9TVEFUU19HQU1FU19XT046IFwiR2FtZXMgd29uXCIsXG4gICAgR0FNRV9TVEFUU19HQU1FU19MT1NUOiBcIkdhbWVzIGxvc3RcIixcbiAgICBHQU1FX1NUQVRTX1dJTl9SQVRFOiBcIldpbiByYXRlXCIsXG4gICAgR0FNRV9TVEFUU19CRVNUX1NUUkVBSzogXCJCZXN0IHN0cmVha1wiLFxuICAgIEdBTUVfU1RBVFNfR0VORVJBTDogXCJHZW5lcmFsIHN0YXRzXCIsXG4gICAgR0FNRV9TVEFUU19TSE9UUzogXCJTaG90c1wiLFxuICAgIEdBTUVfU1RBVFNfU0hPVFNfUEVSX01BVENIOiBcIlNob3RzIHBlciBtYXRjaFwiLFxuICAgIEdBTUVfU1RBVFNfR09BTFM6IFwiR29hbHNcIixcbiAgICBHQU1FX1NUQVRTX0dPQUxTX1BFUl9NQVRDSDogXCJHb2FscyBwZXIgbWF0Y2hcIixcbiAgICBHQU1FX1NUQVRTX0hBVF9UUklDS1M6IFwiSGF0IHRyaWNrc1wiLFxuICAgIEdBTUVfU1RBVFNfQVNTSVNUUzogXCJBc3Npc3RzXCIsXG4gICAgR0FNRV9TVEFUU19BU1NJU1RTX1BFUl9NQVRDSDogXCJBc3Npc3RzIHBlciBtYXRjaFwiLFxuICAgIEdBTUVfU1RBVFNfU0FWRVM6IFwiU2F2ZXNcIixcbiAgICBHQU1FX1NUQVRTX1NBVkVTX1BFUl9NQVRDSDogXCJTYXZlcyBwZXIgbWF0Y2hcIixcbiAgICBHQU1FX1NUQVRTX1BBU1NfQUNDVVJBQ1k6IFwiUGFzcyBhY2N1cmFjeVwiLFxuICAgIEdBTUVfU1RBVFNfUEFTU19QRVJfTUFUQ0g6IFwiUGFzcyBwZXIgbWF0Y2hcIixcbiAgICBHQU1FX1NUQVRTX0dPQUxLRUVQRVI6IFwiR29hbGtlZXBlclwiLFxuICAgIEdBTUVfU1RBVFNfUExBWUVEX0dLOiBcIkdhbWVzIHBsYXllZCBhcyBnb2Fsa2VlcGVyXCIsXG4gICAgR0FNRV9TVEFUU19DUzogXCJDbGVhbiBzaGVldHNcIixcbiAgICBHQU1FX1NUQVRTX0NTX1BFUkNFTlRBR0U6IFwiQ2xlYW4gc2hlZXRzIHBlcmNlbnRhZ2VcIixcbiAgICBHQU1FX1NUQVRTX0JBREdFUzogXCJCYWRnZXMgdW5sb2NrZWRcIixcbiAgICAvLyBHQU1FX0xFQURFUkJPQVJEXG4gICAgR0FNRV9MRUFERVJCT0FSRDogXCJMZWFkZXJib2FyZFwiLFxuICAgIEdBTUVfTEVBREVSQk9BUkRfRklMVEVSOiBcIkZpbHRlciBieVwiLFxuICAgIC8vIEdBTUVfRlJJRU5EU1xuICAgIEdBTUVfRlJJRU5EUzogXCJGcmllbmRzXCIsXG4gICAgR0FNRV9GUklFTkRTX05PTkU6IFwiWW91ciBmcmllbmRzIGxpc3QgaXMgZW1wdHkuXCIsXG4gICAgLy8gR0FNRV9TSE9QXG4gICAgR0FNRV9TSE9QOiBcIlNob3BcIixcbiAgICBHQU1FX1NIT1BfQ0FURUdPUllfRkxBR1M6IFwiRmxhZ3NcIixcbiAgICBHQU1FX1NIT1BfRVFVSVA6IFwiRXF1aXBcIixcbiAgICBHQU1FX1NIT1BfRVFVSVBFRDogXCJFcXVpcGVkXCIsXG4gICAgLy8gR0FNRV9TQU5DVElPTlxuICAgIEdBTUVfU0FOQ1RJT05fTVVURTogXCJ7MH0gaGFzIGJlZW4gbXV0ZWQgZm9yIHsxfSBob3VyKHMpLlwiLFxuICAgIEdBTUVfU0FOQ1RJT05fQkFOOiBcInswfSBoYXMgYmVlbiBiYW5uZWQgZm9yIHsxfSBob3VyKHMpLlwiLFxuICAgIC8vIEdBTUVfQURNSU5cbiAgICBHQU1FX0FETUlOOiBcIkFkbWluIHBhbmVsXCIsXG4gICAgR0FNRV9BRE1JTl9URUFNOiBcIlRlYW1cIixcbiAgICBHQU1FX0FETUlOX1JFUE9SVFM6IFwiUmVwb3J0c1wiLFxuICAgIEdBTUVfQURNSU5fU0FOQ1RJT05fTVVURTogXCJNdXRlXCIsXG4gICAgR0FNRV9BRE1JTl9TQU5DVElPTl9CQU46IFwiQmFuXCIsXG4gICAgR0FNRV9BRE1JTl9TQU5DVElPTl9USU1FOiBcIkR1cmF0aW9uIGluIGhvdXJzXCIsXG4gICAgR0FNRV9BRE1JTl9TQU5DVElPTl9SRUFTT046IFwiUmVhc29uXCIsXG4gICAgR0FNRV9BRE1JTl9TQU5DVElPTlM6IFwiU2FuY3Rpb25zXCIsXG4gICAgR0FNRV9BRE1JTl9ORVdfU0FOQ1RJT046IFwiTmV3IHNhbmN0aW9uXCIsXG4gICAgR0FNRV9BRE1JTl9SQU5LOiBcIlJhbmtzXCIsXG4gICAgR0FNRV9BRE1JTl9DSEFUTE9HUzogXCJDaGF0IGxvZ3NcIixcbiAgICBHQU1FX0FETUlOX0VSUk9SX1VTRVJOQU1FOiBcIlRoaXMgcGxheWVyIGRvZXMgbm90IGV4aXN0LlwiLFxuICAgIEdBTUVfQURNSU5fRVJST1JfUkFOSzogXCJ7MH0gaGFzIGFscmVhZHkgezF9IHJhbmsuXCIsXG4gICAgR0FNRV9BRE1JTl9TVUNDRVNTX1JBTks6IFwiezB9IGlzIG5vdyB7MX0uXCIsXG4gICAgR0FNRV9BRE1JTl9FUlJPUl9SQU5LX1BFUk1TOiBcIllvdSBjYW4ndCBjaGFuZ2UgezB9IHJhbmsuXCIsXG4gICAgR0FNRV9BRE1JTl9FUlJPUl9TQU5DVElPTl9QRVJNUzogXCJZb3UgY2FuJ3Qgc2FuY3Rpb25hdGUgezB9LlwiLFxuICAgIEdBTUVfQURNSU5fRVJST1JfU0FOQ1RJT05fQUxSRUFEWV9NVVRFRDogXCJ7MH0gaXMgYWxyZWFkeSBtdXRlZC5cIixcbiAgICBHQU1FX0FETUlOX0VSUk9SX1NBTkNUSU9OX0FMUkVBRFlfQkFOOiBcInswfSBpcyBhbHJlYWR5IGJhbm5lZC5cIixcbiAgICBHQU1FX0FETUlOX0VSUk9SX1NBTkNUSU9OX0RVUkFUSU9OOiBcIlRoZSBkdXJhdGlvbiBpcyBpbnZhbGlkLlwiLFxuICAgIC8vIEdBTUVfUkFOS1xuICAgIEdBTUVfUkFOS19PV05FUjogXCJPd25lclwiLFxuICAgIEdBTUVfUkFOS19NQU5BR0VSOiBcIk1hbmFnZXJcIixcbiAgICBHQU1FX1JBTktfQURNSU46IFwiQWRtaW5cIixcbiAgICBHQU1FX1JBTktfTU9EOiBcIk1vZGVyYXRvclwiLFxuICAgIEdBTUVfUkFOS19WSVA6IFwiVklQXCIsXG4gICAgR0FNRV9SQU5LX1VTRVI6IFwiVXNlclwiLFxuICAgIC8vIEdBTUVfRUxPXG4gICAgR0FNRV9FTE9fSVJPTjogXCJJcm9uXCIsXG4gICAgR0FNRV9FTE9fU0lMVkVSOiBcIlNpbHZlclwiLFxuICAgIEdBTUVfRUxPX0dPTEQ6IFwiR29sZFwiLFxuICAgIEdBTUVfRUxPX1BMQVRJTklVTTogXCJQbGF0aW5pdW1cIixcbiAgICBHQU1FX0VMT19ESUFNT05EOiBcIkRpYW1vbmRcIixcbiAgICBHQU1FX0VMT19DSEFNUElPTjogXCJDaGFtcGlvblwiLFxuICAgIEdBTUVfRUxPX0NIQUxMRU5HRVI6IFwiQ2hhbGxlbmdlclwiLFxuICAgIC8vIEhJU1RPUllcbiAgICBISVNUT1JZX01BVENIX1NUQVJURUQ6IFwiTWF0Y2ggc3RhcnRlZFwiLFxuICAgIEhJU1RPUllfU0hPVDogXCJTaG90IGJ5IDxzcGFuIGNsYXNzPSd7MH0nPnsxfTwvc3Bhbj5cIixcbiAgICBISVNUT1JZX1NBVkU6IFwiU2F2ZSBieSA8c3BhbiBjbGFzcz0nezB9Jz57MX08L3NwYW4+XCIsXG4gICAgSElTVE9SWV9HT0FMOiBcIkdvYWwgYnkgPHNwYW4gY2xhc3M9J3swfSc+ezF9PC9zcGFuPlwiLFxuICAgIEhJU1RPUllfR09BTF9BU1NJU1RFRDogXCJHb2FsIGJ5IDxzcGFuIGNsYXNzPSd7MH0nPnsxfTwvc3Bhbj4gYXNzaXN0ZWQgYnkgPHNwYW4gY2xhc3M9J3swfSc+ezJ9PC9zcGFuPlwiLFxuICAgIEhJU1RPUllfT1dOX0dPQUw6IFwiT3duIGdvYWwgYnkgPHNwYW4gY2xhc3M9J3swfSc+ezF9PC9zcGFuPlwiLFxuICAgIEhJU1RPUllfRU5EX1JFRDogXCJSZWQgdGVhbSB3b24gdGhlIGdhbWUg8J+UtCB7MH0gLSB7MX0g8J+UtSwgcG9zc2Vzc2lvbiDwn5S0IHsyfSUgLSB7M30lIPCflLVcIixcbiAgICBISVNUT1JZX0VORF9CTFVFOiBcIkJsdWUgdGVhbSB3b24gdGhlIGdhbWUg8J+UtCB7MH0gLSB7MX0g8J+UtSwgcG9zc2Vzc2lvbiDwn5S0IHsyfSUgLSB7M30lIPCflLVcIixcbiAgICAvLyBDT1BZUklHSFRcbiAgICBDT1BZUklHSFQ6IFwiwqkgezB9LCBkZXZlbG9wZWQgd2l0aCDimaUgYnkgT3ZCLlwiXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZSID0gdm9pZCAwO1xuZXhwb3J0cy5GUiA9IHtcbiAgICBDT0RFOiBcIkZSXCIsXG4gICAgLy8gTE9BRElOR1xuICAgIExPQURJTkdfTUVTU0FHRTogXCJJbml0aWFsaXNhdGlvbiBkZSB7MH0uLi5cIixcbiAgICBMT0FESU5HX1JFU09VUkNFUzogXCJDaGFyZ2VtZW50IGRlcyByZXNzb3VyY2VzLi4uXCIsXG4gICAgTE9BRElOR19DT05ORUNUSU9OX1RPX01BSU5fU0VSVkVSOiBcIkNvbm5leGlvbiBhdSBzZXJ2ZXVyIHByaW5jaXBhbC4uLlwiLFxuICAgIExPQURJTkdfRkVUQ0hJTkdfUkVHSU9OX1NFUlZFUlM6IFwiUsOpY3Vww6lyYXRpb24gZGVzIHNlcnZldXJzIGRlIHLDqWdpb24uLi5cIixcbiAgICAvLyBHRU5FUklDX0VSUk9SXG4gICAgR0VORVJJQ19FUlJPUl9DT05ORUNUSU9OX0xPU1Q6IFwiQ29ubmV4aW9uIGF1IHNlcnZldXIgcGVyZHVlLlwiLFxuICAgIEdFTkVSSUNfRVJST1JfU0VSVkVSUzogXCJVbmUgZXJyZXVyIHMnZXN0IHByb2R1aXRlIGF2ZWMgbGVzIHNlcnZldXJzLlwiLFxuICAgIEdFTkVSSUNfRVJST1JfTk9fU0VSVkVSX0FWQUlMQUJMRTogXCJJbCBuJ3kgYSBhdWN1biBzZXJ2ZXVyIGRpc3BvbmlibGUuXCIsXG4gICAgLy8gQUNDT1VOVFxuICAgIEFDQ09VTlRfTEFOR1VBR0U6IFwiTGFuZ2FnZVwiLFxuICAgIEFDQ09VTlRfTE9HSU46IFwiQ29ubmV4aW9uXCIsXG4gICAgQUNDT1VOVF9SRUdJU1RFUjogXCJJbnNjcmlwdGlvblwiLFxuICAgIEFDQ09VTlRfVVNFUk5BTUU6IFwiUHNldWRvbnltZVwiLFxuICAgIEFDQ09VTlRfUEFTU1dPUkQ6IFwiTW90IGRlIHBhc3NlXCIsXG4gICAgQUNDT1VOVF9DT05GSVJNX1BBU1NXT1JEOiBcIkNvbmZpcm1leiB2b3RyZSBtb3QgZGUgcGFzc2VcIixcbiAgICBBQ0NPVU5UX1NFUlZFUjogXCJTZXJ2ZXVyIFt7MH1dIC0gUGluZzogezF9bXNcIixcbiAgICAvLyBBQ0NPVU5UX0VSUk9SXG4gICAgQUNDT1VOVF9FUlJPUl9PQ0NVUkVEOiBcIlVuZSBlcnJldXIgZXN0IHN1cnZlbnVlLCB2ZXVpbGxleiByZWNoYXJnZXIgbGEgcGFnZS5cIixcbiAgICBBQ0NPVU5UX0VSUk9SX0ZJRUxEUzogXCJNZXJjaSBkZSBjb21wbMOpdGVyIHRvdXMgbGVzIGNoYW1wcy5cIixcbiAgICBBQ0NPVU5UX0VSUk9SX0FMUkVBRFlfTE9HR0VEOiBcIlZvdXMgw6p0ZXMgZMOpasOgIGNvbm5lY3TDqS5cIixcbiAgICBBQ0NPVU5UX0VSUk9SX0lOVkFMSUQ6IFwiUHNldW9ueW1lIG91IG1vdCBkZSBwYXNzZSBpbnZhbGlkZS5cIixcbiAgICBBQ0NPVU5UX0VSUk9SX1VTRVJOQU1FX0xFTkdUSDogXCJWb3RyZSBwc2V1ZG9ueW1lIGRvaXQgZmFpcmUgZW50cmUgMyBldCAxNSBjYXJhY3TDqHJlcy5cIixcbiAgICBBQ0NPVU5UX0VSUk9SX1VTRVJOQU1FX0FMUEhBTlVNRVJJQzogXCJWb3RyZSBwc2V1ZG9ueW1lIGRvaXQgw6p0cmUgYWxwaGFudW3DqXJpcXVlLlwiLFxuICAgIEFDQ09VTlRfRVJST1JfUEFTU1dPUkRfTEVOR1RIOiBcIlZvdHJlIG1vdCBkZSBwYXNzZSBkb2l0IGZhaXJlIDYgY2FyYWN0w6hyZXMgbWluaW11bS5cIixcbiAgICBBQ0NPVU5UX0VSUk9SX1BBU1NXT1JEU19ESUZGRVJFTlQ6IFwiVm9zIGRldXggbW90cyBkZSBwYXNzZSBzb250IGRpZmbDqXJlbnRzLlwiLFxuICAgIEFDQ09VTlRfSU5WQUxJRF9TRVJWRVI6IFwiTGUgc2VydmV1ciBzw6lsZWN0aW9ubsOpIG4nZXN0IHBhcyBkaXNwb25pYmxlLlwiLFxuICAgIC8vIENPUFlSSUdIVFxuICAgIENPUFlSSUdIVDogXCLCqSB7MH0sIGTDqXZlbG9wcMOpIGF2ZWMg4pmlIHBhciBPdkIuXCJcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVzb3VyY2VzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlnL1Jlc291cmNlc1wiKTtcbmNvbnN0IG1haW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWFpblwiKSk7XG5jbGFzcyBSZXNvdXJjZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlc291cmNlcyA9IHt9O1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5sb2dnZXIuc2VuZExvZyhcIklORk9cIiwgXCJJbml0aWxpYXppbmcgcmVzb3VyY2VzLi4uXCIpO1xuICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5pbml0U2NlbmUoMCAvKiBTY2VuZUxpc3QuTWVzc2FnZVNjZW5lICovLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleSgnTE9BRElOR19SRVNPVVJDRVMnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RPZlByb21pc2UgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIFJlc291cmNlc18xLlJlc291cmNlcykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0T2ZQcm9taXNlLnB1c2godGhpcy5sb2FkUmVzb3VyY2UoaSwgUmVzb3VyY2VzXzEuUmVzb3VyY2VzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKGxpc3RPZlByb21pc2UpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFwiQWxsIHJlc291cmNlcyBoYXZlIGJlZW4gbG9hZGVkLlwiKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4gcmVqZWN0KGUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkUmVzb3VyY2Uoa2V5LCBmaWxlTmFtZSkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsZU5hbWUuZW5kc1dpdGgoXCIucG5nXCIpIHx8IGZpbGVOYW1lLmVuZHNXaXRoKFwiLmpwZ1wiKSB8fCBmaWxlTmFtZS5lbmRzV2l0aChcIi5zdmdcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVzb3VyY2VzW2BJTUFHRV8ke2tleX1gXSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGBJbWFnZSAke2tleX0gbG9hZGVkLmApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGBJbXBvc3NpYmxlIHRvIGxvYWQgaW1hZ2UgJHtrZXl9LmApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gYGFzc2V0cy9pbWFnZXMvcmVzb3VyY2VzLyR7ZmlsZU5hbWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbGVOYW1lLmVuZHNXaXRoKFwiLm1wM1wiKSB8fCBmaWxlTmFtZS5lbmRzV2l0aChcIi53YXZcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdWRpbyA9IG5ldyBBdWRpbyhgYXNzZXRzL2F1ZGlvLyR7ZmlsZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgYXVkaW8ub25sb2FkZWRkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZXNvdXJjZXNbYEFVRElPXyR7a2V5fWBdID0gYXVkaW87XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYEF1ZGlvICR7a2V5fSBsb2FkZWQuYCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhdWRpby5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoYEltcG9zc2libGUgdG8gbG9hZCBhdWRpbyAke2tleX0uYCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmVzb3VyY2VNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTaGFyZWFibGVEYXRhXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL3NoYXJlZC9TaGFyZWFibGVEYXRhL1NoYXJlYWJsZURhdGFcIikpO1xuY2xhc3MgUm9vbSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICB0aGlzLmlkID0gZGF0YS5pZDtcbiAgICAgICAgdGhpcy5jdXJyZW50UGxheWVycyA9IGRhdGEuY3VycmVudFBsYXllcnM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBkYXRhLnN0YXRlO1xuICAgICAgICB0aGlzLnNjb3JlID0gZGF0YS5zY29yZTtcbiAgICAgICAgdGhpcy5zdGFkaXVtID0gZGF0YS5zdGFkaXVtO1xuICAgICAgICB0aGlzLnBpY2tNb2RlID0gZGF0YS5waWNrTW9kZTtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gZGF0YS5oaXN0b3J5O1xuICAgICAgICB0aGlzLmRpc2NIaXN0b3J5ID0ge307XG4gICAgfVxuICAgIHJlb3JkZXJQbGF5ZXIocGxheWVyc0FycmF5KSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBsYXllcnMgPSBwbGF5ZXJzQXJyYXk7XG4gICAgfVxuICAgIGdldFBsYXllcihwbGF5ZXJJZCkge1xuICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmN1cnJlbnRQbGF5ZXJzLmZpbHRlcigocGxheWVyKSA9PiBwbGF5ZXIuaWQgPT0gcGxheWVySWQpWzBdO1xuICAgICAgICBpZiAocGxheWVyICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGxheWVySm9pbihwbGF5ZXIpIHtcbiAgICAgICAgY29uc3QgcGxheWVyRGF0YSA9IHRoaXMuZ2V0UGxheWVyKHBsYXllci5pZCk7XG4gICAgICAgIGlmIChwbGF5ZXJEYXRhICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY3VycmVudFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgIH1cbiAgICBwbGF5ZXJMZWF2ZShwbGF5ZXJJZCkge1xuICAgICAgICBjb25zdCBwbGF5ZXJEYXRhID0gdGhpcy5nZXRQbGF5ZXIocGxheWVySWQpO1xuICAgICAgICBpZiAocGxheWVyRGF0YSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmN1cnJlbnRQbGF5ZXJzID0gdGhpcy5jdXJyZW50UGxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIHBsYXllci5pZCAhPSBwbGF5ZXJJZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBsYXllcnMgPSBkYXRhLmN1cnJlbnRQbGF5ZXJzO1xuICAgICAgICB0aGlzLnN0YXRlID0gZGF0YS5zdGF0ZTtcbiAgICAgICAgdGhpcy5zY29yZSA9IGRhdGEuc2NvcmU7XG4gICAgICAgIHRoaXMuc3RhZGl1bS5kaXNjcyA9IGRhdGEuZGlzY3M7XG4gICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5zdGFkaXVtLmRpc2NzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNjSGlzdG9yeVtpXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuZGlzY0hpc3RvcnlbaV0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZGlzY0hpc3RvcnlbaV0ucHVzaChuZXcgU2hhcmVhYmxlRGF0YV8xLmRlZmF1bHQocGVyZm9ybWFuY2Uubm93KCksIHsgeDogdGhpcy5zdGFkaXVtLmRpc2NzW2ldLngsIHk6IHRoaXMuc3RhZGl1bS5kaXNjc1tpXS55IH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJvb207XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvQmFzZS9CYXNlXCIpO1xuY29uc3QgQ29sb3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL0NvbG9yL0NvbG9yXCIpKTtcbmNvbnN0IEVsb18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3NoYXJlZC9FbG8vRWxvXCIpO1xuY29uc3QgTGV2ZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvTGV2ZWwvTGV2ZWxcIik7XG5jb25zdCBSb29tU3RhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvUm9vbVN0YXRlL1Jvb21TdGF0ZVwiKTtcbmNvbnN0IFRlYW1fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL1RlYW0vVGVhbVwiKSk7XG5jb25zdCBtYWluXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL21haW5cIikpO1xuY29uc3QgU2NlbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vU2NlbmVcIikpO1xuY2xhc3MgR2FtZVNjZW5lIGV4dGVuZHMgU2NlbmVfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICBzdXBlcihzdGF0ZS5uYW1lKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRVc2VyOiBzdGF0ZS5wYXJhbXMuY3VycmVudFVzZXIsXG4gICAgICAgICAgICBjYW52YXM6IG51bGwsXG4gICAgICAgICAgICBjdHg6IG51bGwsXG4gICAgICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgICAgICBmcHM6IDAsXG4gICAgICAgICAgICBjYW52YXNfcmVjdDogWy0xNTAsIC03NSwgMTUwLCA3NV0sXG4gICAgICAgICAgICBjYW1lcmFGb2xsb3c6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgdW5wYXVzZUludGVydmFsOiAwLFxuICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVwOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBraWNrOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RDaGFuZ2VGcHM6IG51bGwsXG4gICAgICAgICAgICBzZXR0aW5nc19jYXRlZ29yeTogXCJncmFwaGljc1wiLFxuICAgICAgICAgICAgc2V0dGluZ3NfcmVjb3JkX2lucHV0OiBudWxsLFxuICAgICAgICAgICAgZm9jdXNVc2VyOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldEZwcyh2YWwpIHtcbiAgICAgICAgY29uc3QgZnBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmcHNcIik7XG4gICAgICAgIGlmIChmcHMgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgbm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnN0YXRlLmZwcyA9IHZhbDtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubGFzdENoYW5nZUZwcyAhPSBudWxsICYmIHRoaXMuc3RhdGUubGFzdENoYW5nZUZwcyArIDEwMDAgPiBub3cpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGUubGFzdENoYW5nZUZwcyA9IG5vdztcbiAgICAgICAgZnBzLnRleHRDb250ZW50ID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHNldFN0YXRlKHBhcmFtcykge1xuICAgICAgICBzdXBlci5zZXRTdGF0ZShwYXJhbXMpO1xuICAgICAgICBmb3IgKGxldCBpIGluIHBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVtpXSA9IHBhcmFtc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBvbldpbGxJbml0KCkge1xuICAgICAgICBzdXBlci5vbldpbGxJbml0KCk7XG4gICAgfVxuICAgIG9uSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbWVcIik7XG4gICAgICAgIHRoaXMuc3RhdGUuY3R4ID0gdGhpcy5zdGF0ZS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNzZXR0aW5ncyAubWVudSBsaScpKS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnNldFNldHRpbmdzQ2F0ZWdvcnkuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNhZG1pbl9tZW51IGxpJykpLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuc2V0QWRtaW5DYXRlZ29yeS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3NldHRpbmdzIGlucHV0LCAjc2V0dGluZ3Mgc2VsZWN0JykpLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLnNldFNldHRpbmdzLmJpbmQodGhpcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbGVhZGVyYm9hcmRGaWx0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxlYWRlcmJvYXJkRmlsdGVyXCIpO1xuICAgICAgICBpZiAobGVhZGVyYm9hcmRGaWx0ZXIgIT0gbnVsbClcbiAgICAgICAgICAgIGxlYWRlcmJvYXJkRmlsdGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5yZXF1ZXN0TGVhZGVyYm9hcmQuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQcm9maWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXF1ZXN0X3Byb2ZpbGVcIik7XG4gICAgICAgIGlmIChyZXF1ZXN0UHJvZmlsZSAhPSBudWxsKVxuICAgICAgICAgICAgcmVxdWVzdFByb2ZpbGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuc3dpdGNoUHJvZmlsZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZ2VuZXJhbF9tZW51XCIpKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgICAgQXJyYXkuZnJvbShlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuc3dpdGNoTWVudS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwicGlja19saXN0X3RlYW1cIikpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLmRyb3AuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1c2VyX21lbnUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInVzZXJfbWVudVwiKTtcbiAgICAgICAgaWYgKHVzZXJfbWVudSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsaSA9IHVzZXJfbWVudS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpXCIpO1xuICAgICAgICAgICAgQXJyYXkuZnJvbShsaSkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMudXNlck1lbnVJdGVtLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiY2xvc2VcIikpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlICE9IG51bGwgJiYgZWwucGFyZW50Tm9kZS5wYXJlbnROb2RlICE9IG51bGwgJiYgZWwucGFyZW50Tm9kZS5wYXJlbnROb2RlLnBhcmVudEVsZW1lbnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlEb3duSGFuZGxlci5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5LZXlVcEhhbmRsZXIuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBjaGF0Rm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2hhdEZvcm1cIik7XG4gICAgICAgIGNoYXRGb3JtID09PSBudWxsIHx8IGNoYXRGb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGF0Rm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMuc2VuZENoYXQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucmVuZGVyTWVudSgpO1xuICAgIH1cbiAgICByZW5kZXJNZW51KCkge1xuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJnZW5lcmFsX21lbnVcIikpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpKS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PSBcImFkbWluXCIgJiYgW1widXNlclwiLCBcInZpcFwiXS5pbmNsdWRlcyhtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5yYW5rKSlcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2ZpbGVEYXRhKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvZmlsZVwiKTtcbiAgICAgICAgaWYgKHByb2ZpbGUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgQXJyYXkuZnJvbShwcm9maWxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWcsIHNwYW5cIikpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9maWxlX2RhdGEgPSBlbC5nZXRBdHRyaWJ1dGUoXCJwcm9maWxlX2RhdGFcIik7XG4gICAgICAgICAgICBpZiAocHJvZmlsZV9kYXRhID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHByb2ZpbGVfZGF0YSA9PSBcInVzZXJuYW1lXCIpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGRhdGEucmFuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvZmlsZV9kYXRhID09IFwiYXZhdGFyXCIpXG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwic3JjXCIsIG1haW5fMS5kZWZhdWx0LnJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbXCJJTUFHRV9BVkFUQVJfXCIgKyBkYXRhLmF2YXRhcl0uc3JjKTtcbiAgICAgICAgICAgIGlmIChwcm9maWxlX2RhdGEgPT0gXCJvbmxpbmVcIikge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLm9ubGluZSlcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChcIm9ubGluZVwiKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJvbmxpbmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhW3Byb2ZpbGVfZGF0YV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IGRhdGFbcHJvZmlsZV9kYXRhXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuc3RhdHNbcHJvZmlsZV9kYXRhXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2ZpbGVfZGF0YSA9PSBcImVsb1wiKVxuICAgICAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IGAke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleSgoMCwgRWxvXzEuZ2V0RWxvKShkYXRhLnN0YXRzLmVsbykubmFtZSl9ICR7KDAsIEVsb18xLmdldEVsbykoZGF0YS5zdGF0cy5lbG8pLnZhbHVlfSAoJHtkYXRhLnN0YXRzLmVsb30pYDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9maWxlX2RhdGEgPT0gXCJsZXZlbF94cFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gKDAsIExldmVsXzEuZ2V0TGV2ZWwpKGRhdGEuc3RhdHMubGV2ZWxfeHApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IGRhdGEuc3RhdHNbcHJvZmlsZV9kYXRhXTtcbiAgICAgICAgICAgICAgICAgICAgW1wid2luX3JhdGVcIiwgXCJwYXNzX2FjY3VyYWN5XCIsIFwiY3NfcGVyY2VudGFnZVwiXS5pbmNsdWRlcyhwcm9maWxlX2RhdGEpID8gZWwudGV4dENvbnRlbnQgKz0gXCIlXCIgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhdGUuekluZGV4Kys7XG4gICAgICAgIHByb2ZpbGUuc3R5bGUuekluZGV4ID0gdGhpcy5zdGF0ZS56SW5kZXg7XG4gICAgICAgIHByb2ZpbGUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB9XG4gICAgc3dpdGNoTWVudShlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuekluZGV4Kys7XG4gICAgICAgIHN3aXRjaCAoZS5zcmNFbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzaG9wXCI6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaFNob3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmcmllbmRzXCI6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaEZyaWVuZHMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1lbnVcIjoge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibGVhZGVyYm9hcmRcIjoge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoTGVhZGVyYm9hcmQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhZG1pblwiOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hBZG1pbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRlYW1cIjoge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3Q2hhdCh7IHR5cGU6IFwiYW5ub3VuY2VtZW50XCIsIG1lc3NhZ2U6IFwiR0FNRV9HRU5FUkFMX05PVF9BVkFJTEFCTEVcIiwgY29sb3I6IENvbG9yXzEuZGVmYXVsdC5ST09NX0FOTk9VTkNFTUVOVCwgc291bmQ6IDEsIG9mZmljaWFsVHJhZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTZXR0aW5ncyhlKSB7XG4gICAgICAgIGlmIChlLnNyY0VsZW1lbnQuY2hlY2tlZCAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5zZXRTZXR0aW5ncyhlLnNyY0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwic2V0dGluZ3NfY2F0ZWdvcnlcIiksIGUuc3JjRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzZXR0aW5nc192YWxcIiksIGUuc3JjRWxlbWVudC5jaGVja2VkKTtcbiAgICAgICAgbWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLnNldFNldHRpbmdzKGUuc3JjRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzZXR0aW5nc19jYXRlZ29yeVwiKSwgZS5zcmNFbGVtZW50LmdldEF0dHJpYnV0ZShcInNldHRpbmdzX3ZhbFwiKSwgZS5zcmNFbGVtZW50LnZhbHVlKTtcbiAgICB9XG4gICAgc2V0U2V0dGluZ3NDYXRlZ29yeShlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0dGluZ3NfY2F0ZWdvcnkgPSBlLnNyY0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY2F0ZWdvcnlcIik7XG4gICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3NldHRpbmdzIC5tZW51IGxpJykpLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImNhdGVnb3J5XCIpID09IHRoaXMuc3RhdGUuc2V0dGluZ3NfY2F0ZWdvcnkgJiYgIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRcIikpXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbG9hZFNldHRpbmdzKCk7XG4gICAgfVxuICAgIHJlbW92ZUtleSh0eXBlLCBrZXkpIHtcbiAgICAgICAgbWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLnJlbW92ZUtleSh0eXBlLCBrZXkpO1xuICAgICAgICB0aGlzLnJlbG9hZFNldHRpbmdzKCk7XG4gICAgfVxuICAgIGFkZEhpc3RvcnkoZGF0YSkge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoaXN0b3J5XCIpO1xuICAgICAgICBpZiAoaGlzdG9yeSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuY2xhc3NMaXN0LmFkZChcInJvd1wiKTtcbiAgICAgICAgY29uc3QgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChpY29uKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdGltZS5jbGFzc0xpc3QuYWRkKFwidGltZVwiKTtcbiAgICAgICAgdGltZS50ZXh0Q29udGVudCA9IHRoaXMuZm10TVNTKE1hdGguZmxvb3IoZGF0YS52YWx1ZS50aW1lKSk7XG4gICAgICAgIGluZm8uYXBwZW5kQ2hpbGQodGltZSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpbmZvLmFwcGVuZENoaWxkKG1lc3NhZ2UpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoaW5mbyk7XG4gICAgICAgIHN3aXRjaCAoZGF0YS5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtYXRjaFN0YXJ0ZWRcIjoge1xuICAgICAgICAgICAgICAgIGhpc3RvcnkuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpY29uLnNyYyA9IFwiYXNzZXRzL2ltYWdlcy9pY29ucy93aGlzdGxlLnBuZ1wiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGV4dENvbnRlbnQgPSBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJISVNUT1JZX01BVENIX1NUQVJURURcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic2hvdFwiOiB7XG4gICAgICAgICAgICAgICAgaWNvbi5zcmMgPSBcImFzc2V0cy9pbWFnZXMvaWNvbnMvc2hvdC5wbmdcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmlubmVySFRNTCA9IG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkhJU1RPUllfU0hPVFwiLCBbZGF0YS52YWx1ZS50ZWFtLm5hbWUsIGRhdGEudmFsdWUudXNlcm5hbWVdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzYXZlXCI6IHtcbiAgICAgICAgICAgICAgICBpY29uLnNyYyA9IFwiYXNzZXRzL2ltYWdlcy9pY29ucy9zYXZlLnBuZ1wiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5uZXJIVE1MID0gbWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiSElTVE9SWV9TQVZFXCIsIFtkYXRhLnZhbHVlLnRlYW0ubmFtZSwgZGF0YS52YWx1ZS51c2VybmFtZV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdvYWxcIjoge1xuICAgICAgICAgICAgICAgIGljb24uc3JjID0gXCJhc3NldHMvaW1hZ2VzL2ljb25zL2JhbGwucG5nXCI7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm90aWYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5vdGlmXCIpO1xuICAgICAgICAgICAgICAgIGlmIChub3RpZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnZhbHVlLnRlYW0uaWQgIT0gZGF0YS52YWx1ZS5zY29yZV90ZWFtLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWYuaW5uZXJIVE1MID0gYCR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9HRU5FUkFMX09XTl9HT0FMXCIsIFtkYXRhLnZhbHVlLnRlYW0ubmFtZSwgZGF0YS52YWx1ZS51c2VybmFtZV0pfWA7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmLmlubmVySFRNTCA9IGAke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9HT0FMXCIsIFtkYXRhLnZhbHVlLnRlYW0ubmFtZSwgZGF0YS52YWx1ZS51c2VybmFtZV0pfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnZhbHVlLnRlYW0uaWQgIT0gZGF0YS52YWx1ZS5zY29yZV90ZWFtLmlkKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlubmVySFRNTCA9IG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkhJU1RPUllfT1dOX0dPQUxcIiwgW2RhdGEudmFsdWUudGVhbS5uYW1lLCBkYXRhLnZhbHVlLnVzZXJuYW1lXSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS52YWx1ZS5hc3Npc3RfaWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbm5lckhUTUwgPSBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJISVNUT1JZX0dPQUxfQVNTSVNURURcIiwgW2RhdGEudmFsdWUudGVhbS5uYW1lLCBkYXRhLnZhbHVlLnVzZXJuYW1lLCBkYXRhLnZhbHVlLmFzc2lzdF91c2VybmFtZV0pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbm5lckhUTUwgPSBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJISVNUT1JZX0dPQUxcIiwgW2RhdGEudmFsdWUudGVhbS5uYW1lLCBkYXRhLnZhbHVlLnVzZXJuYW1lXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZW5kR2FtZVwiOiB7XG4gICAgICAgICAgICAgICAgaWNvbi5zcmMgPSBcImFzc2V0cy9pbWFnZXMvaWNvbnMvd2hpc3RsZS5wbmdcIjtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS52YWx1ZS5zY29yZS5yZWQgPiBkYXRhLnZhbHVlLnNjb3JlLmJsdWUpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5uZXJIVE1MID0gbWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiSElTVE9SWV9FTkRfUkVEXCIsIFtkYXRhLnZhbHVlLnNjb3JlLnJlZCwgZGF0YS52YWx1ZS5zY29yZS5ibHVlLCBkYXRhLnZhbHVlLnBvc3Nlc3Npb24ucmVkLCBkYXRhLnZhbHVlLnBvc3Nlc3Npb24uYmx1ZV0pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbm5lckhUTUwgPSBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJISVNUT1JZX0VORF9CTFVFXCIsIFtkYXRhLnZhbHVlLnNjb3JlLnJlZCwgZGF0YS52YWx1ZS5zY29yZS5ibHVlLCBkYXRhLnZhbHVlLnBvc3Nlc3Npb24ucmVkLCBkYXRhLnZhbHVlLnBvc3Nlc3Npb24uYmx1ZV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhpc3RvcnkucHJlcGVuZChkaXYpO1xuICAgIH1cbiAgICByZWNvcmRLZXkodHlwZSkge1xuICAgICAgICBjb25zdCByZWNvcmRLZXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlY29yZEtleVwiKTtcbiAgICAgICAgaWYgKHJlY29yZEtleSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlLnNldHRpbmdzX3JlY29yZF9pbnB1dCA9IHR5cGU7XG4gICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLnVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLmRvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMubGVmdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5yaWdodCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5raWNrID0gZmFsc2U7XG4gICAgICAgIHJlY29yZEtleS5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgfVxuICAgIHJlbG9hZFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2V0dGluZ3NcIiksIHJlY29yZEtleSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVjb3JkS2V5XCIpO1xuICAgICAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHJlY29yZEtleSAhPSBudWxsKVxuICAgICAgICAgICAgcmVjb3JkS2V5LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgQXJyYXkuZnJvbShzZXR0aW5ncy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiY2F0ZWdvcnlcIikpLmZvckVhY2goKGNhdGVnb3J5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeV9uYW1lID0gY2F0ZWdvcnkuZ2V0QXR0cmlidXRlKFwiY2F0ZWdvcnlfbmFtZVwiKTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeV9uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnlfbmFtZSA9PSB0aGlzLnN0YXRlLnNldHRpbmdzX2NhdGVnb3J5KVxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQXJyYXkuZnJvbShjYXRlZ29yeS5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXQsIHNlbGVjdCwgLmlucHV0c192YWx1ZVwiKSkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzX2NhdGVnb3J5ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzZXR0aW5nc19jYXRlZ29yeVwiKSwgc2V0dGluZ3NfdmFsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzZXR0aW5nc192YWxcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzX2NhdGVnb3J5ICE9IG51bGwgJiYgc2V0dGluZ3NfdmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5nc19jYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdyYXBoaWNzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmdyYXBoaWNzW3NldHRpbmdzX3ZhbF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGVja2VkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNoZWNrZWQgPSBtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuZ3JhcGhpY3Nbc2V0dGluZ3NfdmFsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5ncmFwaGljc1tzZXR0aW5nc192YWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhdWRpb1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5hdWRpb1tzZXR0aW5nc192YWxdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hlY2tlZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jaGVja2VkID0gbWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmF1ZGlvW3NldHRpbmdzX3ZhbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuYXVkaW9bc2V0dGluZ3NfdmFsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5wdXRzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5pbnB1dHNbc2V0dGluZ3NfdmFsXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmlucHV0c1tzZXR0aW5nc192YWxdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImdhbWVJbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRFbGVtZW50LnRleHRDb250ZW50ID0ga2V5LnRvU3RyaW5nKCkucmVwbGFjZShcIktleVwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVJbnB1dC5zcmMgPSBcImFzc2V0cy9pbWFnZXMvaWNvbnMvY3Jvc3Muc3ZnXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLnJlbW92ZUtleShzZXR0aW5nc192YWwsIGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuYXBwZW5kQ2hpbGQoZGVsZXRlSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGlucHV0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImdhbWVJbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5wdXQuY2xhc3NMaXN0LmFkZChcImFkZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJbnB1dC5zcmMgPSBcImFzc2V0cy9pbWFnZXMvaWNvbnMvYWRkLnN2Z1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZElucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLnJlY29yZEtleShzZXR0aW5nc192YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuYXBwZW5kQ2hpbGQoYWRkSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3dpdGNoUHJvZmlsZSgpIHtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByb2ZpbGVcIik7XG4gICAgICAgIGlmIChwcm9maWxlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcm9maWxlLnN0eWxlLmRpc3BsYXkgPT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICBwcm9maWxlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYWluXzEuZGVmYXVsdC53ZWJTb2NrZXRzTWFuYWdlci5zZW5kTXNnKFwicmVxdWVzdFByb2ZpbGVcIiwgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIudXNlcm5hbWUpO1xuICAgIH1cbiAgICByZXF1ZXN0TGVhZGVyYm9hcmQoZSkge1xuICAgICAgICB0aGlzLmZldGNoTGVhZGVyYm9hcmQoZS5zcmNFbGVtZW50LnZhbHVlKTtcbiAgICB9XG4gICAgZmV0Y2hMZWFkZXJib2FyZChrZXkpIHtcbiAgICAgICAgY29uc3QgbGVhZGVyYm9hcmRDb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWFkZXJib2FyZENvbnRlbnRcIik7XG4gICAgICAgIGlmIChsZWFkZXJib2FyZENvbnRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGVhZGVyYm9hcmRDb250ZW50LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwibG9hZGVyXCI+PC9kaXY+YDtcbiAgICAgICAgbWFpbl8xLmRlZmF1bHQud2ViU29ja2V0c01hbmFnZXIuc2VuZE1zZyhcImZldGNoTGVhZGVyYm9hcmRcIiwga2V5KTtcbiAgICB9XG4gICAgc2V0TGVhZGVyYm9hcmREYXRhKGRhdGEpIHtcbiAgICAgICAgY29uc3QgbGVhZGVyYm9hcmRDb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWFkZXJib2FyZENvbnRlbnRcIik7XG4gICAgICAgIGlmIChsZWFkZXJib2FyZENvbnRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGVhZGVyYm9hcmRDb250ZW50LmlubmVySFRNTCA9IGBgO1xuICAgICAgICBkYXRhLnBsYXllcnMuZm9yRWFjaCgocGxheWVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicm93XCIpO1xuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgIGF2YXRhci5zcmMgPSBtYWluXzEuZGVmYXVsdC5yZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW1wiSU1BR0VfQVZBVEFSX1wiICsgcGxheWVyLmF2YXRhcl0uc3JjO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGF2YXRhcik7XG4gICAgICAgICAgICBjb25zdCB1c2VybmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB1c2VybmFtZS5jbGFzc0xpc3QuYWRkKFwidXNlcm5hbWVcIik7XG4gICAgICAgICAgICB1c2VybmFtZS50ZXh0Q29udGVudCA9IHBsYXllci51c2VybmFtZTtcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZCh1c2VybmFtZSk7XG4gICAgICAgICAgICBjb25zdCByYW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHJhbmsuY2xhc3NMaXN0LmFkZChcInJhbmtcIik7XG4gICAgICAgICAgICByYW5rLnRleHRDb250ZW50ID0gXCIjXCIgKyAoaW5kZXggKyAxKS50b1N0cmluZygpO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHJhbmspO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdmFsdWUuY2xhc3NMaXN0LmFkZChcInZhbHVlXCIpO1xuICAgICAgICAgICAgaWYgKFtcIndpbl9yYXRlXCIsIFwicGFzc19hY2N1cmFjeVwiLCBcImNzX3BlcmNlbnRhZ2VcIl0uaW5jbHVkZXMoZGF0YS5rZXkpKVxuICAgICAgICAgICAgICAgIHZhbHVlLnRleHRDb250ZW50ID0gcGxheWVyLnZhbHVlICsgXCIlXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLmtleSA9PSBcImxldmVsX3hwXCIpXG4gICAgICAgICAgICAgICAgdmFsdWUudGV4dENvbnRlbnQgPSAoMCwgTGV2ZWxfMS5nZXRMZXZlbCkocGxheWVyLnZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5rZXkgPT0gXCJlbG9cIilcbiAgICAgICAgICAgICAgICB2YWx1ZS50ZXh0Q29udGVudCA9IGAke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleSgoMCwgRWxvXzEuZ2V0RWxvKShwbGF5ZXIudmFsdWUpLm5hbWUpfSAkeygwLCBFbG9fMS5nZXRFbG8pKHBsYXllci52YWx1ZSkudmFsdWV9ICgke3BsYXllci52YWx1ZX0pYDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB2YWx1ZS50ZXh0Q29udGVudCA9IHBsYXllci52YWx1ZTtcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgICAgICAgICBsZWFkZXJib2FyZENvbnRlbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhpZGVNZW51KCkge1xuICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20uc3RhdGUgIT0gUm9vbVN0YXRlXzEuUm9vbVN0YXRlLktJQ0tfT0ZGX1JFU0VUKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuaGlkZU1lbnUuYmluZCh0aGlzKSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBpY2tfbGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGlja19saXN0XCIpO1xuICAgICAgICBpZiAocGlja19saXN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwaWNrX2xpc3Quc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGlja19saXN0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgc2hvd01lbnUoKSB7XG4gICAgICAgIGNvbnN0IHBpY2tfbGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGlja19saXN0XCIpO1xuICAgICAgICBpZiAocGlja19saXN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwaWNrX2xpc3Quc3R5bGUuZGlzcGxheSA9PSBcImJsb2NrXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBpY2tfbGlzdC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH1cbiAgICBzd2l0Y01lbnUoKSB7XG4gICAgICAgIGNvbnN0IHBpY2tfbGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGlja19saXN0XCIpO1xuICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20uc3RhdGUgPT0gUm9vbVN0YXRlXzEuUm9vbVN0YXRlLkdBTUVfRU5ERUQgfHwgcGlja19saXN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwaWNrX2xpc3Quc3R5bGUuZGlzcGxheSA9PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgIHBpY2tfbGlzdC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGlja19saXN0LnN0eWxlLnpJbmRleCA9IHRoaXMuc3RhdGUuekluZGV4O1xuICAgICAgICBwaWNrX2xpc3Quc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB9XG4gICAgcmVuZGVyQWRtaW4oZGF0YSkge1xuICAgICAgICBjb25zdCBhZG1pbkNvbnRlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFkbWluX2NvbnRlbnRcIik7XG4gICAgICAgIGlmIChhZG1pbkNvbnRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3dpdGNoIChkYXRhLmNhdGVnb3J5KSB7XG4gICAgICAgICAgICBjYXNlIFwidGVhbVwiOiB7XG4gICAgICAgICAgICAgICAgYWRtaW5Db250ZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZGF0YS50ZWFtLmZvckVhY2goKHVzZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInJvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZhdGFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhdGFyLnNyYyA9IG1haW5fMS5kZWZhdWx0LnJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbXCJJTUFHRV9BVkFUQVJfXCIgKyB1c2VyLmF2YXRhcl0uc3JjO1xuICAgICAgICAgICAgICAgICAgICBhdmF0YXIuY2xhc3NMaXN0LmFkZChcImF2YXRhclwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChhdmF0YXIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VybmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lLmNsYXNzTGlzdC5hZGQoXCJ1c2VybmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWUudGV4dENvbnRlbnQgPSB1c2VyLnVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHVzZXJuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIHJhbmsuY2xhc3NMaXN0LmFkZChcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICByYW5rLmNsYXNzTGlzdC5hZGQodXNlci5yYW5rKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuay50ZXh0Q29udGVudCA9IG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShgR0FNRV9SQU5LXyR7dXNlci5yYW5rLnRvVXBwZXJDYXNlKCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQocmFuayk7XG4gICAgICAgICAgICAgICAgICAgIGFkbWluQ29udGVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZXBvcnRzXCI6IHtcbiAgICAgICAgICAgICAgICBhZG1pbkNvbnRlbnQuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJyb3cgaW5mb1wiPjxkaXYgc3R5bGU9XCJ3aWR0aDogMzAlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0dFTkVSQUxfUExBWUVSXCIpfTwvZGl2PjxkaXYgc3R5bGU9XCJ3aWR0aDogMzAlXCJcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9CWV9QTEFZRVJcIil9PC9kaXY+PGRpdiBzdHlsZT1cIndpZHRoOiAzMCVcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9EQVRFXCIpfTwvZGl2PjxkaXYgY2xhc3M9XCJ2YWx1ZVwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9HRU5FUkFMX0FDVElPTlwiKX08L2Rpdj48L2Rpdj5gO1xuICAgICAgICAgICAgICAgIGRhdGEucmVwb3J0cy5mb3JFYWNoKChyZXBvcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInJvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZS5zdHlsZS53aWR0aCA9IFwiMzAlXCI7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lLnRleHRDb250ZW50ID0gcmVwb3J0LnVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHVzZXJuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ZWRfdXNlcm5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRlZF91c2VybmFtZS5zdHlsZS53aWR0aCA9IFwiMzAlXCI7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydGVkX3VzZXJuYW1lLnRleHRDb250ZW50ID0gcmVwb3J0LnJlcG9ydGVkX3VzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHJlcG9ydGVkX3VzZXJuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUuc3R5bGUud2lkdGggPSBcIjMwJVwiO1xuICAgICAgICAgICAgICAgICAgICBkYXRlLnRleHRDb250ZW50ID0gcmVwb3J0LmRhdGU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5jbGFzc0xpc3QuYWRkKFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXRMb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgICAgICAgICBjaGF0TG9nLmNsYXNzTGlzdC5hZGQoXCJpY29uXCIpO1xuICAgICAgICAgICAgICAgICAgICBjaGF0TG9nLnNyYyA9IFwiYXNzZXRzL2ltYWdlcy9pY29ucy9jaGF0LnN2Z1wiO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24uYXBwZW5kQ2hpbGQoY2hhdExvZyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXRMb2cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hBZG1pbkNhdGVnb3J5KFwiY2hhdGxvZ3NcIiwgcmVwb3J0LnJlcG9ydGVkX3VzZXJuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUNyb3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlQ3Jvc3MuY2xhc3NMaXN0LmFkZChcImljb25cIik7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUNyb3NzLnNyYyA9IFwiYXNzZXRzL2ltYWdlcy9pY29ucy9jcm9zcy5zdmdcIjtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmFwcGVuZENoaWxkKGRlbGV0ZUNyb3NzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlQ3Jvc3MuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LndlYlNvY2tldHNNYW5hZ2VyLnNlbmRNc2coXCJkZWxldGVSZXBvcnRcIiwgcmVwb3J0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYWRtaW5Db250ZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNhbmN0aW9uc1wiOiB7XG4gICAgICAgICAgICAgICAgYWRtaW5Db250ZW50LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwicm93IGluZm9cIj48ZGl2IHN0eWxlPVwid2lkdGg6IDI1JVwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9HRU5FUkFMX1BMQVlFUlwiKX08L2Rpdj48ZGl2IHN0eWxlPVwid2lkdGg6IDI1JVwiXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0dFTkVSQUxfQllfUExBWUVSXCIpfTwvZGl2PjxkaXYgc3R5bGU9XCJ3aWR0aDogMTAlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0dFTkVSQUxfVFlQRVwiKX08L2Rpdj48ZGl2IHN0eWxlPVwid2lkdGg6IDMwJVwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9HRU5FUkFMX0VYUElSRVwiKX08L2Rpdj48ZGl2IGNsYXNzPVwidmFsdWVcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9BQ1RJT05cIil9PC9kaXY+PC9kaXY+YDtcbiAgICAgICAgICAgICAgICBkYXRhLnNhbmN0aW9ucy5mb3JFYWNoKChzYW5jdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicm93XCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VybmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lLnN0eWxlLndpZHRoID0gXCIyNSVcIjtcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWUudGV4dENvbnRlbnQgPSBzYW5jdGlvbi51c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh1c2VybmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5X3VzZXJuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnlfdXNlcm5hbWUuc3R5bGUud2lkdGggPSBcIjI1JVwiO1xuICAgICAgICAgICAgICAgICAgICBieV91c2VybmFtZS50ZXh0Q29udGVudCA9IHNhbmN0aW9uLmJ5X3BsYXllcjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChieV91c2VybmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlLnN0eWxlLndpZHRoID0gXCIxMCVcIjtcbiAgICAgICAgICAgICAgICAgICAgdHlwZS50ZXh0Q29udGVudCA9IG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShgR0FNRV9BRE1JTl9TQU5DVElPTl8ke3NhbmN0aW9uLnR5cGUudG9VcHBlckNhc2UoKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUuc3R5bGUud2lkdGggPSBcIjMwJVwiO1xuICAgICAgICAgICAgICAgICAgICBkYXRlLnRleHRDb250ZW50ID0gc2FuY3Rpb24uZW5kX2RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5jbGFzc0xpc3QuYWRkKFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXRMb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgICAgICAgICBjaGF0TG9nLmNsYXNzTGlzdC5hZGQoXCJpY29uXCIpO1xuICAgICAgICAgICAgICAgICAgICBjaGF0TG9nLnNyYyA9IFwiYXNzZXRzL2ltYWdlcy9pY29ucy9jaGF0LnN2Z1wiO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24uYXBwZW5kQ2hpbGQoY2hhdExvZyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXRMb2cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hBZG1pbkNhdGVnb3J5KFwiY2hhdGxvZ3NcIiwgc2FuY3Rpb24udXNlcm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlQ3Jvc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVDcm9zcy5jbGFzc0xpc3QuYWRkKFwiaWNvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlQ3Jvc3Muc3JjID0gXCJhc3NldHMvaW1hZ2VzL2ljb25zL2Nyb3NzLnN2Z1wiO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24uYXBwZW5kQ2hpbGQoZGVsZXRlQ3Jvc3MpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVDcm9zcy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQud2ViU29ja2V0c01hbmFnZXIuc2VuZE1zZyhcImRlbGV0ZVNhbmN0aW9uXCIsIHNhbmN0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYWRtaW5Db250ZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImNoYXRsb2dzXCI6IHtcbiAgICAgICAgICAgICAgICBhZG1pbkNvbnRlbnQuaW5uZXJIVE1MID0gYGA7XG4gICAgICAgICAgICAgICAgZGF0YS5sb2dzLmZvckVhY2goKGxvZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicm93XCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZXh0Q29udGVudCA9IGxvZztcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRtaW5Db250ZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlckFkbWluQWxlcnQoZGF0YSkge1xuICAgICAgICBjb25zdCBhZG1pbl9hbGVydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWRtaW5fYWxlcnRcIik7XG4gICAgICAgIGlmIChhZG1pbl9hbGVydCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZGF0YS5lcnJvcilcbiAgICAgICAgICAgIGFkbWluX2FsZXJ0LmNsYXNzTGlzdC5hZGQoXCJlcnJvclwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYWRtaW5fYWxlcnQuY2xhc3NMaXN0LnJlbW92ZShcImVycm9yXCIpO1xuICAgICAgICBhZG1pbl9hbGVydC50ZXh0Q29udGVudCA9IG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShkYXRhLm1lc3NhZ2UsIGRhdGEuYXJncyk7XG4gICAgICAgIGFkbWluX2FsZXJ0LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxuICAgIHNldFJhbmsoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHVzZXJuYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyYW5rVXNlcm5hbWVcIiksIHJhbmsgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJhbmtWYWx1ZVwiKTtcbiAgICAgICAgbWFpbl8xLmRlZmF1bHQud2ViU29ja2V0c01hbmFnZXIuc2VuZE1zZyhcImFkbWluUmFua1wiLCB7IHVzZXJuYW1lOiB1c2VybmFtZS52YWx1ZSwgcmFuazogcmFuay52YWx1ZSB9KTtcbiAgICB9XG4gICAgbmV3U2FuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHVzZXJuYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYW5jdGlvblVzZXJuYW1lXCIpLCB0eXBlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYW5jdGlvblR5cGVcIiksIHRpbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNhbmN0aW9uVGltZVwiKSwgcmVhc29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYW5jdGlvblJlYXNvblwiKTtcbiAgICAgICAgbWFpbl8xLmRlZmF1bHQud2ViU29ja2V0c01hbmFnZXIuc2VuZE1zZyhcImFkbWluU2FuY3Rpb25cIiwgeyB1c2VybmFtZTogdXNlcm5hbWUudmFsdWUsIHR5cGU6IHR5cGUudmFsdWUsIHRpbWU6IHRpbWUudmFsdWUsIHJlYXNvbjogcmVhc29uLnZhbHVlIH0pO1xuICAgIH1cbiAgICBmZXRjaEFkbWluQ2F0ZWdvcnkodHlwZSwgYXJncykge1xuICAgICAgICBjb25zdCBhZG1pblRpdGxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZG1pbl90aXRsZVwiKSwgYWRtaW5Db250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZG1pbl9jb250ZW50XCIpO1xuICAgICAgICBpZiAoYWRtaW5UaXRsZSA9PSBudWxsIHx8IGFkbWluQ29udGVudCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhZG1pblRpdGxlLmlubmVyVGV4dCA9IG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShgR0FNRV9BRE1JTl8ke3R5cGUudG9VcHBlckNhc2UoKX1gKTtcbiAgICAgICAgYWRtaW5Db250ZW50LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwibG9hZGVyXCI+PC9kaXY+YDtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGVhbVwiOiB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQud2ViU29ja2V0c01hbmFnZXIuc2VuZE1zZyhcImZldGNoQWRtaW5cIiwgeyBrZXk6IFwidGVhbVwiIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlcG9ydHNcIjoge1xuICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LndlYlNvY2tldHNNYW5hZ2VyLnNlbmRNc2coXCJmZXRjaEFkbWluXCIsIHsga2V5OiBcInJlcG9ydHNcIiB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJjaGF0bG9nc1wiOiB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQud2ViU29ja2V0c01hbmFnZXIuc2VuZE1zZyhcImZldGNoQWRtaW5cIiwgeyBrZXk6IFwiY2hhdGxvZ3NcIiwgdXNlcm5hbWU6IGFyZ3MgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic2FuY3Rpb25zXCI6IHtcbiAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC53ZWJTb2NrZXRzTWFuYWdlci5zZW5kTXNnKFwiZmV0Y2hBZG1pblwiLCB7IGtleTogXCJzYW5jdGlvbnNcIiB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJuZXdfc2FuY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIGFkbWluQ29udGVudC5pbm5lckhUTUwgPSBgPGRpdiBpZD1cImFkbWluX2FsZXJ0XCI+PC9kaXY+PGZvcm0gaWQ9XCJhZG1pblNhbmN0aW9uRm9ybVwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwic2FuY3Rpb25Vc2VybmFtZVwiIHBsYWNlaG9sZGVyPVwiJHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJBQ0NPVU5UX1VTRVJOQU1FXCIpfVwiLz48c2VsZWN0IGlkPVwic2FuY3Rpb25UeXBlXCI+PG9wdGlvbiB2YWx1ZT1cIm11dGVcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfQURNSU5fU0FOQ1RJT05fTVVURVwiKX08L29wdGlvbj48b3B0aW9uIHZhbHVlPVwiYmFuXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0FETUlOX1NBTkNUSU9OX0JBTlwiKX08L29wdGlvbj48L3NlbGVjdD48aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cInNhbmN0aW9uVGltZVwiIHBsYWNlaG9sZGVyPVwiJHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0FETUlOX1NBTkNUSU9OX1RJTUVcIil9XCIvPjxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwic2FuY3Rpb25SZWFzb25cIiBwbGFjZWhvbGRlcj1cIiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9BRE1JTl9TQU5DVElPTl9SRUFTT05cIil9XCIgbWF4bGVuZ3RoPVwiMTUwXCIvPjxpbnB1dCB0eXBlPVwic3VibWl0XCIgdmFsdWU9XCIke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9WQUxJREFURVwiKX1cIj48L2Zvcm0+YDtcbiAgICAgICAgICAgICAgICBpZiAoYXJncyAhPSBudWxsICYmIGFyZ3MudXNlcm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VybmFtZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYW5jdGlvblVzZXJuYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlcm5hbWVJbnB1dCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWVJbnB1dC52YWx1ZSA9IGFyZ3MudXNlcm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmdzICE9IG51bGwgJiYgYXJncy50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZVNlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2FuY3Rpb25UeXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZVNlbGVjdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVNlbGVjdC52YWx1ZSA9IGFyZ3MudHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWRtaW5TYW5jdGlvbkZvcm1cIik7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMubmV3U2FuY3Rpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJhbmtcIjoge1xuICAgICAgICAgICAgICAgIGFkbWluQ29udGVudC5pbm5lckhUTUwgPSBgPGRpdiBpZD1cImFkbWluX2FsZXJ0XCI+PC9kaXY+PGZvcm0gaWQ9XCJhZG1pblJhbmtGb3JtXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJyYW5rVXNlcm5hbWVcIiBwbGFjZWhvbGRlcj1cIiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiQUNDT1VOVF9VU0VSTkFNRVwiKX1cIi8+PHNlbGVjdCBpZD1cInJhbmtWYWx1ZVwiPjwvc2VsZWN0PjxpbnB1dCB0eXBlPVwic3VibWl0XCIgdmFsdWU9XCIke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9WQUxJREFURVwiKX1cIj48L2Zvcm0+YDtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5rVmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJhbmtWYWx1ZVwiKTtcbiAgICAgICAgICAgICAgICBbXCJvd25lclwiLCBcIm1hbmFnZXJcIiwgXCJhZG1pblwiLCBcIm1vZFwiLCBcInZpcFwiLCBcInVzZXJcIl0uZm9yRWFjaCgocmFuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24udmFsdWUgPSByYW5rO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoYEdBTUVfUkFOS18ke3JhbmsudG9VcHBlckNhc2UoKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmFua1ZhbHVlID09PSBudWxsIHx8IHJhbmtWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFua1ZhbHVlLmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWRtaW5SYW5rRm9ybVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgdGhpcy5zZXRSYW5rKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBZG1pbkNhdGVnb3J5KGUpIHtcbiAgICAgICAgdGhpcy5zd2l0Y2hBZG1pbihlLnNyY0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSk7XG4gICAgfVxuICAgIHN3aXRjaEFkbWluKHR5cGUgPSBudWxsLCBhcmdzID0gbnVsbCkge1xuICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbCB8fCBbXCJ1c2VyXCIsIFwidmlwXCJdLmluY2x1ZGVzKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLnJhbmspKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBhZG1pbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWRtaW5cIiksIGFkbWluX21lbnUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFkbWluX21lbnVcIik7XG4gICAgICAgIGlmIChhZG1pbiA9PSBudWxsIHx8IGFkbWluX21lbnUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0eXBlICYmIGFkbWluLnN0eWxlLmRpc3BsYXkgPT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICBhZG1pbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT0gbnVsbClcbiAgICAgICAgICAgIHR5cGUgPSBcInRlYW1cIjtcbiAgICAgICAgQXJyYXkuZnJvbShhZG1pbl9tZW51LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlcIikpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PSBcInJhbmtcIiAmJiAhW1wib3duZXJcIiwgXCJtYW5hZ2VyXCJdLmluY2x1ZGVzKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLnJhbmspKVxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IHR5cGUpXG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mZXRjaEFkbWluQ2F0ZWdvcnkodHlwZSwgYXJncyk7XG4gICAgICAgIGFkbWluLnN0eWxlLnpJbmRleCA9IHRoaXMuc3RhdGUuekluZGV4O1xuICAgICAgICBhZG1pbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH1cbiAgICBzd2l0Y2hMZWFkZXJib2FyZCgpIHtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxlYWRlcmJvYXJkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWFkZXJib2FyZFwiKSwgbGVhZGVyYm9hcmRGaWx0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxlYWRlcmJvYXJkRmlsdGVyXCIpO1xuICAgICAgICBpZiAobGVhZGVyYm9hcmQgPT0gbnVsbCB8fCBsZWFkZXJib2FyZEZpbHRlciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobGVhZGVyYm9hcmQuc3R5bGUuZGlzcGxheSA9PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgIGxlYWRlcmJvYXJkLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGVyYm9hcmRGaWx0ZXIudmFsdWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZXNTdGF0cyA9IFtcImVsb1wiLCBcImxldmVsX3hwXCIsIFwiZ2FtZXNfcGxheWVkXCIsIFwiZ2FtZXNfd29uXCIsIFwiZ2FtZXNfbG9zdFwiLCBcIndpbl9yYXRlXCIsIFwiYmVzdF9zdHJlYWtcIiwgXCJzaG90c1wiLCBcInNob3RzX3Blcl9tYXRjaFwiLCBcImdvYWxzXCIsIFwiZ29hbHNfcGVyX21hdGNoXCIsIFwiaGF0X3RyaWNrc1wiLCBcImFzc2lzdHNcIiwgXCJhc3Npc3RzX3Blcl9tYXRjaFwiLCBcInNhdmVzXCIsIFwic2F2ZXNfcGVyX21hdGNoXCIsIFwicGFzc19hY2N1cmFjeVwiLCBcInBhc3NfcGVyX21hdGNoXCIsIFwicGxheWVkX2drXCIsIFwiY3NcIiwgXCJjc19wZXJjZW50YWdlXCJdO1xuICAgICAgICAgICAgYXZhaWxhYmxlc1N0YXRzLmZvckVhY2goKHN0YXQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHN0YXQ7XG4gICAgICAgICAgICAgICAgb3B0aW9uLnRleHRDb250ZW50ID0gbWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KGBHQU1FX1NUQVRTXyR7c3RhdC50b1VwcGVyQ2FzZSgpfWApO1xuICAgICAgICAgICAgICAgIGxlYWRlcmJvYXJkRmlsdGVyLmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hMZWFkZXJib2FyZChhdmFpbGFibGVzU3RhdHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hMZWFkZXJib2FyZChsZWFkZXJib2FyZEZpbHRlci52YWx1ZSk7XG4gICAgICAgIGxlYWRlcmJvYXJkLnN0eWxlLnpJbmRleCA9IHRoaXMuc3RhdGUuekluZGV4O1xuICAgICAgICBsZWFkZXJib2FyZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH1cbiAgICBzd2l0Y2hTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZXR0aW5nc1wiKTtcbiAgICAgICAgaWYgKHNldHRpbmdzID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChzZXR0aW5ncy5zdHlsZS5kaXNwbGF5ID09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgc2V0dGluZ3Muc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVsb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgc2V0dGluZ3Muc3R5bGUuekluZGV4ID0gdGhpcy5zdGF0ZS56SW5kZXg7XG4gICAgICAgIHNldHRpbmdzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxuICAgIHJlbG9hZEZyaWVuZHMoKSB7XG4gICAgICAgIGNvbnN0IGZyaWVuZHNMaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmcmllbmRzTGlzdFwiKTtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwgfHwgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuZnJpZW5kcyA9PSBudWxsIHx8IGZyaWVuZHNMaXN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZyaWVuZHNMaXN0LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmZyaWVuZHMuZm9yRWFjaCgoZnJpZW5kKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicm93XCIpO1xuICAgICAgICAgICAgaWYgKGZyaWVuZC5vbmxpbmUpXG4gICAgICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJvbmxpbmVcIik7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHVzZXIuY2xhc3NMaXN0LmFkZChcInVzZXJcIik7XG4gICAgICAgICAgICB1c2VyLmlubmVyVGV4dCA9IGZyaWVuZC51c2VybmFtZTtcbiAgICAgICAgICAgIGlmIChmcmllbmQuc2VydmVyUmVnaW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gYGFzc2V0cy9pbWFnZXMvZmxhZ3MvcmVnaW9uLyR7dGhpcy5nZXRSZWdpb25GbGFnKGZyaWVuZC5zZXJ2ZXJSZWdpb24ucmVnaW9uKX0uc3ZnYDtcbiAgICAgICAgICAgICAgICB1c2VyLnByZXBlbmQoaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHVzZXIpO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGFjdGlvbi5jbGFzc0xpc3QuYWRkKFwiYWN0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKGZyaWVuZC5vbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aGlzcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgICAgICB3aGlzcGVyLnNyYyA9IFwiYXNzZXRzL2ltYWdlcy9pY29ucy9jaGF0LnN2Z1wiO1xuICAgICAgICAgICAgICAgIHdoaXNwZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMud2hpc3BlcihmcmllbmQudXNlcm5hbWUpKTtcbiAgICAgICAgICAgICAgICBhY3Rpb24uYXBwZW5kQ2hpbGQod2hpc3Blcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJpZW5kLnNlcnZlclJlZ2lvbiAhPSBudWxsICYmIGZyaWVuZC5zZXJ2ZXJSZWdpb24ucmVnaW9uID09ICgoX2EgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1cnJlbnRTZXJ2ZXIpICYmIGZyaWVuZC5zZXJ2ZXJSZWdpb24uY3VycmVudFJvb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgICAgIGpvaW4uc2V0QXR0cmlidXRlKFwicm9vbVwiLCBmcmllbmQuc2VydmVyUmVnaW9uLmN1cnJlbnRSb29tKTtcbiAgICAgICAgICAgICAgICBqb2luLnNyYyA9IFwiYXNzZXRzL2ltYWdlcy9pY29ucy9jaGV2X3JpZ2h0LnN2Z1wiO1xuICAgICAgICAgICAgICAgIGFjdGlvbi5hcHBlbmRDaGlsZChqb2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUZyaWVuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICBkZWxldGVGcmllbmQuc3JjID0gXCJhc3NldHMvaW1hZ2VzL2ljb25zL2Nyb3NzLnN2Z1wiO1xuICAgICAgICAgICAgZGVsZXRlRnJpZW5kLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiBtYWluXzEuZGVmYXVsdC53ZWJTb2NrZXRzTWFuYWdlci5zZW5kTXNnKFwiZGVsZXRlRnJpZW5kXCIsIGZyaWVuZC5pZCkpO1xuICAgICAgICAgICAgYWN0aW9uLmFwcGVuZENoaWxkKGRlbGV0ZUZyaWVuZCk7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoYWN0aW9uKTtcbiAgICAgICAgICAgIGZyaWVuZHNMaXN0LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY291bnQgPT0gMClcbiAgICAgICAgICAgIGZyaWVuZHNMaXN0LmlubmVyVGV4dCA9IG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfRlJJRU5EU19OT05FXCIpO1xuICAgIH1cbiAgICBzd2l0Y2hGcmllbmRzKCkge1xuICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnJpZW5kcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJpZW5kc1wiKTtcbiAgICAgICAgaWYgKGZyaWVuZHMgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGZyaWVuZHMuc3R5bGUuZGlzcGxheSA9PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgIGZyaWVuZHMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVsb2FkRnJpZW5kcygpO1xuICAgICAgICBmcmllbmRzLnN0eWxlLnpJbmRleCA9IHRoaXMuc3RhdGUuekluZGV4O1xuICAgICAgICBmcmllbmRzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxuICAgIHN3aXRjaFNob3AoKSB7XG4gICAgICAgIGNvbnN0IHNob3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3BcIik7XG4gICAgICAgIGlmIChzaG9wID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChzaG9wLnN0eWxlLmRpc3BsYXkgPT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICBzaG9wLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzaG9wLnN0eWxlLnpJbmRleCA9IHRoaXMuc3RhdGUuekluZGV4O1xuICAgICAgICBtYWluXzEuZGVmYXVsdC53ZWJTb2NrZXRzTWFuYWdlci5zZW5kTXNnKFwiZmV0Y2hTaG9wXCIpO1xuICAgIH1cbiAgICBmZXRjaEl0ZW1Gb3JDYXRlZ29yeShlKSB7XG4gICAgICAgIG1haW5fMS5kZWZhdWx0LndlYlNvY2tldHNNYW5hZ2VyLnNlbmRNc2coXCJmZXRjaEl0ZW1zXCIsIGUuc3JjRWxlbWVudC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IHNob3BJdGVtcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2hvcEl0ZW1zXCIpO1xuICAgICAgICBpZiAoc2hvcEl0ZW1zID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNob3BJdGVtcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgIH1cbiAgICBzaG9wRGF0YShzaG9wRGF0YSkge1xuICAgICAgICBjb25zdCBzaG9wID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG9wXCIpLCBzaG9wQ29pblZhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2hvcENvaW5WYWxcIiksIHNob3BDYXRlZ29yeXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3BDYXRlZ29yeXNcIik7XG4gICAgICAgIGlmIChzaG9wID09IG51bGwgfHwgc2hvcENvaW5WYWwgPT0gbnVsbCB8fCBzaG9wQ2F0ZWdvcnlzID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlciAhPSBudWxsKVxuICAgICAgICAgICAgc2hvcENvaW5WYWwudGV4dENvbnRlbnQgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jb2lucy50b1N0cmluZygpO1xuICAgICAgICBzaG9wQ2F0ZWdvcnlzLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIHNob3BEYXRhLmNhdGVnb3J5cy5mb3JFYWNoKChjYXRlZ29yeSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG4gICAgICAgICAgICBpbnB1dC5uYW1lID0gXCJTSE9QX0NBVEVHT1JZXCI7XG4gICAgICAgICAgICBpbnB1dC5pZCA9IGNhdGVnb3J5Lm5hbWU7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGNhdGVnb3J5Lm5hbWU7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5mZXRjaEl0ZW1Gb3JDYXRlZ29yeS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuICAgICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZm9yXCIsIGNhdGVnb3J5Lm5hbWUpO1xuICAgICAgICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1wiICsgY2F0ZWdvcnkubmFtZSk7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICAgICAgc2hvcENhdGVnb3J5cy5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaG9wRGF0YUl0ZW1zKHNob3BEYXRhLml0ZW1zKTtcbiAgICAgICAgc2hvcC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH1cbiAgICByZWZyZXNoU2hvcCgpIHtcbiAgICAgICAgY29uc3Qgc2hvcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2hvcFwiKSwgc2hvcENvaW5WYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3BDb2luVmFsXCIpLCBzaG9wSXRlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3BJdGVtc1wiKTtcbiAgICAgICAgaWYgKHNob3BDb2luVmFsID09IG51bGwgfHwgc2hvcEl0ZW1zID09IG51bGwgfHwgc2hvcCA9PSBudWxsIHx8IHNob3Auc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyICE9IG51bGwpXG4gICAgICAgICAgICBzaG9wQ29pblZhbC50ZXh0Q29udGVudCA9IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmNvaW5zLnRvU3RyaW5nKCk7XG4gICAgICAgIEFycmF5LmZyb20oc2hvcEl0ZW1zLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpKS5maWx0ZXIoKGVsZW1lbnQpID0+IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwicm93XCIpKS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ3Jvdyc7XG4gICAgICAgICAgICBjb25zdCBpdGVtX2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJpdGVtX2lkXCIpLCBwcmljZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicHJpY2VcIik7XG4gICAgICAgICAgICBjb25zdCBzcGFuID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNwYW5cIilbMF07XG4gICAgICAgICAgICBpZiAoaXRlbV9pZCA9PSBudWxsIHx8IHByaWNlID09IG51bGwgfHwgc3BhbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICgoKF9hID0gbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdmF0YXIpID09IHBhcnNlSW50KGl0ZW1faWQpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZXF1aXBlZFwiKTtcbiAgICAgICAgICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gbWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TSE9QX0VRVUlQRURcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoX2IgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLml0ZW1zLmluY2x1ZGVzKHBhcnNlSW50KGl0ZW1faWQpKSkge1xuICAgICAgICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NIT1BfRVFVSVBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgIT0gbnVsbCAmJiBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jb2lucyA8IHBhcnNlSW50KHByaWNlKSlcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY2FudF9idXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaG9wRGF0YUl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHNob3BJdGVtcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2hvcEl0ZW1zXCIpO1xuICAgICAgICBpZiAoc2hvcEl0ZW1zID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNob3BJdGVtcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicm93XCIpO1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcIml0ZW1faWRcIiwgaXRlbS5pZCk7XG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwicHJpY2VcIiwgaXRlbS5wcmljZSk7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IG1haW5fMS5kZWZhdWx0LnJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbXCJJTUFHRV9BVkFUQVJfXCIgKyBpdGVtLmlkXTtcbiAgICAgICAgICAgIGlmIChpbWFnZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIml0ZW1cIik7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gaW1hZ2Uuc3JjO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGltYWdlRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgYWN0aW9uLmNsYXNzTGlzdC5hZGQoXCJhY3Rpb25cIik7XG4gICAgICAgICAgICBhY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IG1haW5fMS5kZWZhdWx0LndlYlNvY2tldHNNYW5hZ2VyLnNlbmRNc2coXCJ0b2dnbGVJdGVtXCIsIGl0ZW0uaWQpKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdmF0YXIpID09IGl0ZW0uaWQpIHtcbiAgICAgICAgICAgICAgICBkaXYuY2xhc3NMaXN0LmFkZChcImVxdWlwZWRcIik7XG4gICAgICAgICAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU0hPUF9FUVVJUEVEXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKF9iID0gbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pdGVtcy5pbmNsdWRlcyhpdGVtLmlkKSkge1xuICAgICAgICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NIT1BfRVFVSVBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgIT0gbnVsbCAmJiBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jb2lucyA8IGl0ZW0ucHJpY2UpXG4gICAgICAgICAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiY2FudF9idXlcIik7XG4gICAgICAgICAgICAgICAgc3Bhbi5pbm5lckhUTUwgPSAnPGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL2ljb25zL2NvaW4ucG5nXCI+ICcgKyBpdGVtLnByaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9uLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGFjdGlvbik7XG4gICAgICAgICAgICBzaG9wSXRlbXMuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRDaGF0KGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBjaGF0Q2F0ZWdvcnkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1zZ1R5cGVcIiksIGNoYXRNc2cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXRNc2dcIik7XG4gICAgICAgIGlmIChjaGF0Q2F0ZWdvcnkgPT0gbnVsbCB8fCBjaGF0Q2F0ZWdvcnkudmFsdWUubGVuZ3RoID09IDAgfHwgY2hhdE1zZyA9PSBudWxsIHx8IGNoYXRNc2cudmFsdWUubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1haW5fMS5kZWZhdWx0LndlYlNvY2tldHNNYW5hZ2VyLnNlbmRNc2coXCJuZXdDaGF0XCIsIHsgdHlwZTogY2hhdENhdGVnb3J5LnZhbHVlLCBtZXNzYWdlOiBjaGF0TXNnLnZhbHVlIH0pO1xuICAgICAgICBjaGF0TXNnLnZhbHVlID0gXCJcIjtcbiAgICB9XG4gICAga2V5RG93bkhhbmRsZXIoZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYW52YXMgPT0gbnVsbCB8fCB0aGlzLnN0YXRlLmN0eCA9PSBudWxsIHx8IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwgfHwgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20gPT0gbnVsbCB8fCBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbS5zdGFkaXVtID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlucHV0Q2hhdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2hhdE1zZ1wiKTtcbiAgICAgICAgaWYgKGlucHV0Q2hhdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZXR0aW5nc19yZWNvcmRfaW5wdXQgJiYgaW5wdXRDaGF0ICE9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5zZXRTZXR0aW5ncyhcImlucHV0c1wiLCB0aGlzLnN0YXRlLnNldHRpbmdzX3JlY29yZF9pbnB1dCwgZS5jb2RlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0dGluZ3NfcmVjb3JkX2lucHV0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5jb2RlLnN0YXJ0c1dpdGgoXCJEaWdpdFwiKSAmJiBpbnB1dENoYXQgIT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3Qgem9vbSA9IFsxLCAxLjI1LCAxLjUsIDEuNzUsIDIsIDIuMjUsIDIuNV07XG4gICAgICAgICAgICBjb25zdCB6b29tTGV2ZWwgPSBwYXJzZUludChlLmNvZGUucmVwbGFjZShcIkRpZ2l0XCIsIFwiXCIpKTtcbiAgICAgICAgICAgIGlmICh6b29tW3pvb21MZXZlbCAtIDFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuc2V0U2V0dGluZ3MoXCJncmFwaGljc1wiLCBcInpvb21cIiwgem9vbVt6b29tTGV2ZWwgLSAxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxvYWRTZXR0aW5ncygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmNvZGUgPT0gXCJLZXlQXCIgJiYgaW5wdXRDaGF0ICE9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlciA9IG1haW5fMS5kZWZhdWx0LnJlZ2lvblNlcnZlck1hbmFnZXIuZ2V0U2VydmVyQnlJZChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50U2VydmVyKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXIgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuc2VuZE1zZyhcInBhdXNlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuaW5wdXRzLnJpZ2h0LmluY2x1ZGVzKGUuY29kZSkpXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5yaWdodCA9IHRydWU7XG4gICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuaW5wdXRzLmxlZnQuaW5jbHVkZXMoZS5jb2RlKSlcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLmxlZnQgPSB0cnVlO1xuICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmlucHV0cy51cC5pbmNsdWRlcyhlLmNvZGUpKVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMudXAgPSB0cnVlO1xuICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmlucHV0cy5kb3duLmluY2x1ZGVzKGUuY29kZSkpXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5kb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5pbnB1dHMua2ljay5pbmNsdWRlcyhlLmNvZGUpKVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMua2ljayA9IHRydWU7XG4gICAgICAgIGlmIChpbnB1dENoYXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLnVwID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5kb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5sZWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5yaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMua2ljayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlciA9IG1haW5fMS5kZWZhdWx0LnJlZ2lvblNlcnZlck1hbmFnZXIuZ2V0U2VydmVyQnlJZChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50U2VydmVyKTtcbiAgICAgICAgaWYgKHNlcnZlciAhPSBudWxsKVxuICAgICAgICAgICAgc2VydmVyLnNlbmRNc2coXCJpbnB1dHNcIiwgdGhpcy5zdGF0ZS5pbnB1dHMpO1xuICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmlucHV0cy50b2dnbGVfY2hhdC5pbmNsdWRlcyhlLmNvZGUpKSB7XG4gICAgICAgICAgICBpZiAoKGlucHV0Q2hhdCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXRlLmNhbnZhcy5mb2N1cygpLCAxKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gaW5wdXRDaGF0LmZvY3VzKCksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEtleVVwSGFuZGxlcihlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbnZhcyA9PSBudWxsIHx8IHRoaXMuc3RhdGUuY3R4ID09IG51bGwgfHwgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbCB8fCBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbSA9PSBudWxsIHx8IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tLnN0YWRpdW0gPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5pbnB1dHMucmlnaHQuaW5jbHVkZXMoZS5jb2RlKSlcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLnJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuaW5wdXRzLmxlZnQuaW5jbHVkZXMoZS5jb2RlKSlcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLmxlZnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5pbnB1dHMudXAuaW5jbHVkZXMoZS5jb2RlKSlcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLnVwID0gZmFsc2U7XG4gICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuaW5wdXRzLmRvd24uaW5jbHVkZXMoZS5jb2RlKSlcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLmRvd24gPSBmYWxzZTtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5pbnB1dHMua2ljay5pbmNsdWRlcyhlLmNvZGUpKVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMua2ljayA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzZXJ2ZXIgPSBtYWluXzEuZGVmYXVsdC5yZWdpb25TZXJ2ZXJNYW5hZ2VyLmdldFNlcnZlckJ5SWQobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFNlcnZlcik7XG4gICAgICAgIGlmIChzZXJ2ZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHNlcnZlci5zZW5kTXNnKFwiaW5wdXRzXCIsIHRoaXMuc3RhdGUuaW5wdXRzKTtcbiAgICB9XG4gICAgb25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5vbkRlc3Ryb3koKTtcbiAgICAgICAgY29uc3QgY2hhdEZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXRGb3JtXCIpO1xuICAgICAgICBjaGF0Rm9ybSA9PT0gbnVsbCB8fCBjaGF0Rm9ybSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhdEZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYXRGb3JtXCIsIHRoaXMuc2VuZENoYXQuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlEb3duSGFuZGxlci5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5LZXlVcEhhbmRsZXIuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIH1cbiAgICBmbXRNU1Mocykge1xuICAgICAgICByZXR1cm4gKHMgLSAocyAlPSA2MCkpIC8gNjAgKyAoOSA8IHMgPyAnOicgOiAnOjAnKSArIHM7XG4gICAgfVxuICAgIHVwZGF0ZUF2YXRhcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnJlc2hTaG9wKCk7XG4gICAgICAgIGNvbnN0IGF2YXRhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYXZhdGFyXCIpO1xuICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGF2YXRhci5zcmMgPSBtYWluXzEuZGVmYXVsdC5yZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW1wiSU1BR0VfQVZBVEFSX1wiICsgKChfYSA9IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXZhdGFyKV0uc3JjO1xuICAgIH1cbiAgICBpbml0Um9vbShyb29tKSB7XG4gICAgICAgIGNvbnN0IHJvb21OYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb29tTmFtZVwiKTtcbiAgICAgICAgaWYgKHJvb21OYW1lICE9IG51bGwpXG4gICAgICAgICAgICByb29tTmFtZS50ZXh0Q29udGVudCA9IHJvb20uaWQ7XG4gICAgICAgIGNvbnN0IHBsYXllcnNDb3VudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxheWVyc0NvdW50XCIpO1xuICAgICAgICBpZiAocGxheWVyc0NvdW50ICE9IG51bGwpXG4gICAgICAgICAgICBwbGF5ZXJzQ291bnQudGV4dENvbnRlbnQgPSByb29tLmN1cnJlbnRQbGF5ZXJzLmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNjb3JlRGF0YShyb29tLnNjb3JlKTtcbiAgICAgICAgY29uc3QgbGlzdF91c2VycyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGlzdF91c2Vyc1wiKTtcbiAgICAgICAgaWYgKGxpc3RfdXNlcnMgIT0gbnVsbClcbiAgICAgICAgICAgIGxpc3RfdXNlcnMuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgcm9vbS5jdXJyZW50UGxheWVycy5mb3JFYWNoKChwbGF5ZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAgICAgICAgbGkuZGF0YXNldC51c2VySWQgPSBwbGF5ZXIuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxpLnNldEF0dHJpYnV0ZShcInVzZXJuYW1lXCIsIHBsYXllci51c2VybmFtZSk7XG4gICAgICAgICAgICBsaS5pbm5lckhUTUwgPSBgJHtwbGF5ZXIudXNlcm5hbWV9IDxzcGFuPiR7cGxheWVyLnBpbmcudG9TdHJpbmcoKX08L3NwYW4+YDtcbiAgICAgICAgICAgIGlmIChwbGF5ZXIudGVhbS5pZCA9PSBUZWFtXzEuZGVmYXVsdC5SRUQuaWQpXG4gICAgICAgICAgICAgICAgbGkuY2xhc3NMaXN0LmFkZChcInJlZFwiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYXllci50ZWFtLmlkID09IFRlYW1fMS5kZWZhdWx0LkJMVUUuaWQpXG4gICAgICAgICAgICAgICAgbGkuY2xhc3NMaXN0LmFkZChcImJsdWVcIik7XG4gICAgICAgICAgICBpZiAobGlzdF91c2VycyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGxpc3RfdXNlcnMuYXBwZW5kQ2hpbGQobGkpO1xuICAgICAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuc2hvd1VzZXJNZW51LmJpbmQodGhpcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vbS5oaXN0b3J5LmZvckVhY2goKGhpc3RvcnkpID0+IHRoaXMuYWRkSGlzdG9yeShoaXN0b3J5KSk7XG4gICAgICAgIHRoaXMucmVmcmVzaFBpY2tMaXN0KCk7XG4gICAgfVxuICAgIHVwZGF0ZShyb29tKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2NvcmVEYXRhKHJvb20uc2NvcmUpO1xuICAgICAgICBjb25zdCBsaXN0X3VzZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaXN0X3VzZXJzXCIpO1xuICAgICAgICBpZiAobGlzdF91c2VycyAhPSBudWxsKSB7XG4gICAgICAgICAgICByb29tLmN1cnJlbnRQbGF5ZXJzLmZvckVhY2goKHBsYXllcikgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RfdXNlcnMucXVlcnlTZWxlY3RvckFsbChcImxpXCIpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmRhdGFzZXQudXNlcklkID09IHBsYXllci5pZC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyLnRlYW0uaWQgPT0gVGVhbV8xLmRlZmF1bHQuUkVELmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYmx1ZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiYmx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwicmVkXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJyZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwbGF5ZXIudGVhbS5pZCA9PSBUZWFtXzEuZGVmYXVsdC5CTFVFLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwicmVkXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJyZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImJsdWVcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImJsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcInJlZFwiKSB8fCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImJsdWVcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLltcInJlZFwiLCBcImJsdWVcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGluZyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzcGFuXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpbmcgIT0gbnVsbCAmJiBwaW5nLnRleHRDb250ZW50ICE9IHBsYXllci5waW5nLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGluZy50ZXh0Q29udGVudCA9IHBsYXllci5waW5nLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENhbWVyYUZvbGxvdygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgbGV0IGNlbnRlclgsIGNlbnRlclk7XG4gICAgICAgIGNvbnN0IHBsYXllckRpc2MgPSAoX2IgPSAoX2EgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1cnJlbnRSb29tKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhZGl1bS5kaXNjcy5maWx0ZXIoKGRpc2MpID0+IGRpc2MucGxheWVyID09IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmlkKVswXSwgYmFsbCA9IChfZCA9IChfYyA9IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3VycmVudFJvb20pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zdGFkaXVtLmRpc2NzWzBdO1xuICAgICAgICBpZiAoYmFsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNhbWVyYV9mb2xsb3cgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3R0b21Db250YWluZXJIZWlnaHQgPSAxNjA7XG4gICAgICAgIGNlbnRlclggPSAoX2YgPSAoX2UgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmN1cnJlbnRSb29tKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3RhZGl1bS5kaXNjc1swXS54O1xuICAgICAgICBjZW50ZXJZID0gKCgoX2ggPSAoX2cgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmN1cnJlbnRSb29tKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guc3RhZGl1bS5kaXNjc1swXS55KSArIGJvdHRvbUNvbnRhaW5lckhlaWdodCk7XG4gICAgICAgIGlmIChwbGF5ZXJEaXNjICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNlbnRlclggPSAwLjUgKiAoY2VudGVyWCArIHBsYXllckRpc2MueCk7XG4gICAgICAgICAgICBjZW50ZXJZID0gMC41ICogKGNlbnRlclkgKyBwbGF5ZXJEaXNjLnkpO1xuICAgICAgICAgICAgY29uc3QgbWlkWCA9IDAuNSAqIHRoaXMuc3RhdGUuY2FudmFzLndpZHRoLCBtaWRZID0gMC41ICogdGhpcy5zdGF0ZS5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgaW5mWCA9IHBsYXllckRpc2MueCAtIG1pZFggKyA1MCwgaW5mWSA9IHBsYXllckRpc2MueSAtIG1pZFkgKyA1MCwgc3VwWCA9IHBsYXllckRpc2MueCArIG1pZFggLSA1MCwgc3VwWSA9IHBsYXllckRpc2MueSArIG1pZFkgLSA1MDtcbiAgICAgICAgICAgIGNlbnRlclggPSBjZW50ZXJYID4gc3VwWCA/IHN1cFggOiBjZW50ZXJYIDwgaW5mWCA/IGluZlggOiBjZW50ZXJYO1xuICAgICAgICAgICAgY2VudGVyWSA9IGNlbnRlclkgPiBzdXBZID8gc3VwWSA6IGNlbnRlclkgPCBpbmZZID8gaW5mWSA6IGNlbnRlclk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZyYW1lcyA9IDYwICogKDEgLyB0aGlzLnN0YXRlLmZwcyk7XG4gICAgICAgIGlmIChmcmFtZXMgPiAxKVxuICAgICAgICAgICAgZnJhbWVzID0gMTtcbiAgICAgICAgY29uc3Qgc21vb3RoaW5nUmF0aW8gPSAwLjA0O1xuICAgICAgICBmcmFtZXMgKj0gc21vb3RoaW5nUmF0aW87XG4gICAgICAgIHRoaXMuc3RhdGUuY2FtZXJhRm9sbG93LnggKz0gKGNlbnRlclggLSB0aGlzLnN0YXRlLmNhbWVyYUZvbGxvdy54KSAqIGZyYW1lcztcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW1lcmFGb2xsb3cueSArPSAoY2VudGVyWSAtIHRoaXMuc3RhdGUuY2FtZXJhRm9sbG93LnkpICogZnJhbWVzO1xuICAgICAgICBjb25zdCByb29tID0gbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb207XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IDEyNSwgY2FudmFzSGVpZ2h0ID0gdGhpcy5zdGF0ZS5jYW52YXMuaGVpZ2h0IC0gYm90dG9tQ29udGFpbmVySGVpZ2h0LCBzdGFkaXVtV2lkdGggPSByb29tLnN0YWRpdW0ud2lkdGggKyBtYXJnaW4sIHN0YWRpdW1IZWlnaHQgPSByb29tLnN0YWRpdW0uaGVpZ2h0ICsgbWFyZ2luO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYW52YXMud2lkdGggPiAyICogc3RhZGl1bVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNhbWVyYUZvbGxvdy54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLmNhbWVyYUZvbGxvdy54ICsgMC41ICogdGhpcy5zdGF0ZS5jYW52YXMud2lkdGggPiBzdGFkaXVtV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FtZXJhRm9sbG93LnggPSBzdGFkaXVtV2lkdGggLSAwLjUgKiB0aGlzLnN0YXRlLmNhbnZhcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLmNhbWVyYUZvbGxvdy54IC0gMC41ICogdGhpcy5zdGF0ZS5jYW52YXMud2lkdGggPCAtc3RhZGl1bVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNhbWVyYUZvbGxvdy54ID0gLXN0YWRpdW1XaWR0aCArIDAuNSAqIHRoaXMuc3RhdGUuY2FudmFzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW52YXNIZWlnaHQgPiAyICogc3RhZGl1bUhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYW1lcmFGb2xsb3cueSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5jYW1lcmFGb2xsb3cueSArIDAuNSAqIGNhbnZhc0hlaWdodCA+IHN0YWRpdW1IZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FtZXJhRm9sbG93LnkgPSBzdGFkaXVtSGVpZ2h0IC0gMC41ICogY2FudmFzSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuY2FtZXJhRm9sbG93LnkgLSAwLjUgKiBjYW52YXNIZWlnaHQgPCAtc3RhZGl1bUhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYW1lcmFGb2xsb3cueSA9IC1zdGFkaXVtSGVpZ2h0ICsgMC41ICogY2FudmFzSGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlck5vdGlmKGR0KSB7XG4gICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlciA9PSBudWxsIHx8IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5vdGlmID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJub3RpZlwiKTtcbiAgICAgICAgaWYgKG5vdGlmID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN3aXRjaCAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20uc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgUm9vbVN0YXRlXzEuUm9vbVN0YXRlLlBBVVNFOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYW52YXMuY2xhc3NMaXN0LmFkZChcInBhdXNlXCIpO1xuICAgICAgICAgICAgICAgIG5vdGlmLmlubmVySFRNTCA9IGAke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9QQVVTRVwiKX1gO1xuICAgICAgICAgICAgICAgIGlmIChub3RpZi5zdHlsZS5kaXNwbGF5ID09IFwibm9uZVwiKVxuICAgICAgICAgICAgICAgICAgICBub3RpZi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBSb29tU3RhdGVfMS5Sb29tU3RhdGUuVU5QQVVTRToge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gUExBWUVSIEpPSU4gT04gVU5QQVVTRVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUudW5wYXVzZUludGVydmFsIC09IChkdCAqIDEwMDApO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FudmFzLmNsYXNzTGlzdC5hZGQoXCJwYXVzZVwiKTtcbiAgICAgICAgICAgICAgICBub3RpZi5pbm5lckhUTUwgPSBgJHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0dFTkVSQUxfUEFVU0VcIil9IDxkaXYgaWQ9J3BhdXNlJyBzdHlsZT0nd2lkdGg6ICR7dGhpcy5zdGF0ZS51bnBhdXNlSW50ZXJ2YWwgKiAxMDAgLyAzMDAwfSUnPjwvZGl2PmA7XG4gICAgICAgICAgICAgICAgaWYgKG5vdGlmLnN0eWxlLmRpc3BsYXkgPT0gXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFJvb21TdGF0ZV8xLlJvb21TdGF0ZS5HT0FMX1NDT1JFOiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdGlmLnN0eWxlLmRpc3BsYXkgPT0gXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FudmFzLmNsYXNzTGlzdC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbnZhcy5jbGFzc0xpc3QgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChub3RpZi5zdHlsZS5kaXNwbGF5ID09IFwiYmxvY2tcIilcbiAgICAgICAgICAgICAgICAgICAgbm90aWYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIG5vdGlmLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyR2FtZShkdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbnZhcyA9PSBudWxsIHx8IHRoaXMuc3RhdGUuY3R4ID09IG51bGwgfHwgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbCB8fCBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbSA9PSBudWxsIHx8IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tLnN0YWRpdW0gPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tLnN0YXRlID09IFJvb21TdGF0ZV8xLlJvb21TdGF0ZS5HQU1FX0VOREVEKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zdGF0ZS5jYW52YXNfcmVjdFsyXSAtIHRoaXMuc3RhdGUuY2FudmFzX3JlY3RbMF0sIHRoaXMuc3RhdGUuY2FudmFzX3JlY3RbM10gLSB0aGlzLnN0YXRlLmNhbnZhc19yZWN0WzFdKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm90aWYoZHQpO1xuICAgICAgICAgICAgdGhpcy5zaG93TWVudSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplX2NhbnZhcygpO1xuICAgICAgICB0aGlzLnJlbmRlck5vdGlmKGR0KTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB0aGlzLnN0YXRlLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zdGF0ZS5jYW52YXNfcmVjdFsyXSAtIHRoaXMuc3RhdGUuY2FudmFzX3JlY3RbMF0sIHRoaXMuc3RhdGUuY2FudmFzX3JlY3RbM10gLSB0aGlzLnN0YXRlLmNhbnZhc19yZWN0WzFdKTtcbiAgICAgICAgdGhpcy5zZXRDYW1lcmFGb2xsb3coKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jdHgudHJhbnNsYXRlKC10aGlzLnN0YXRlLmNhbnZhc19yZWN0WzBdLCAtdGhpcy5zdGF0ZS5jYW52YXNfcmVjdFsxXSk7XG4gICAgICAgIHRoaXMuc3RhdGUuY3R4LnNjYWxlKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICogbWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmdyYXBoaWNzLnpvb20sIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICogbWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmdyYXBoaWNzLnpvb20pO1xuICAgICAgICB0aGlzLnN0YXRlLmN0eC50cmFuc2xhdGUoLXRoaXMuc3RhdGUuY2FtZXJhRm9sbG93LngsIC10aGlzLnN0YXRlLmNhbWVyYUZvbGxvdy55KTtcbiAgICAgICAgdGhpcy5yZW5kZXJiZyhtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbS5zdGFkaXVtLCB0aGlzLnN0YXRlLmN0eCk7XG4gICAgICAgIG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tLnN0YWRpdW0uc2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQudmlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdHgubGluZVdpZHRoID0gMztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3JfdG9fc3R5bGUoc2VnbWVudC5jb2xvciwgQmFzZV8xLkJhc2Uuc2VnbWVudF9jb2xvcik7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ1YwID0gc2VnbWVudC52MDtcbiAgICAgICAgICAgICAgICB2YXIgc2VnVjEgPSBzZWdtZW50LnYxO1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LmN1cnZlRiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3R4Lm1vdmVUbyhzZWdWMFswXSwgc2VnVjBbMV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN0eC5saW5lVG8oc2VnVjFbMF0sIHNlZ1YxWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdDQyA9IHNlZ21lbnQuY2lyY2xlQ2VudGVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zX3ggPSBzZWdWMFswXSAtIHNlZ0NDWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zX3kgPSBzZWdWMFsxXSAtIHNlZ0NDWzFdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN0eC5hcmMoc2VnQ0NbMF0sIHNlZ0NDWzFdLCBNYXRoLnNxcnQocG9zX3ggKiBwb3NfeCArIHBvc195ICogcG9zX3kpLCBNYXRoLmF0YW4yKHBvc195LCBwb3NfeCksIE1hdGguYXRhbjIoc2VnVjFbMV0gLSBzZWdDQ1sxXSwgc2VnVjFbMF0gLSBzZWdDQ1swXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCByZW5kZXJUaW1lc3RhbXAgPSBub3cgLSAoMC4wMTY2NjY2NjY2NjY2NjY2NjYpICsgKCgoX2QgPSAoX2IgPSAoX2EgPSBtYWluXzEuZGVmYXVsdCA9PT0gbnVsbCB8fCBtYWluXzEuZGVmYXVsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50Um9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFBsYXllcigoX2MgPSBtYWluXzEuZGVmYXVsdCA9PT0gbnVsbCB8fCBtYWluXzEuZGVmYXVsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pZCkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5waW5nKSB8fCAwKTtcbiAgICAgICAgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20uc3RhZGl1bS5kaXNjcy5mb3JFYWNoKChkaXNjLCBpKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gKF9iID0gKF9hID0gbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50Um9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2NIaXN0b3J5W2ldO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGggPj0gMiAmJiBidWZmZXJbMV0udGltZXN0YW1wIDw9IHJlbmRlclRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPj0gMiAmJiBidWZmZXJbMF0udGltZXN0YW1wIDw9IHJlbmRlclRpbWVzdGFtcCAmJiByZW5kZXJUaW1lc3RhbXAgPD0gYnVmZmVyWzFdLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNjLnggPSB0aGlzLmludGVycG9sYXRlKGJ1ZmZlclswXS5zaGFyZWFibGVEYXRhLngsIGJ1ZmZlclsxXS5zaGFyZWFibGVEYXRhLngsIGJ1ZmZlclswXS50aW1lc3RhbXAsIGJ1ZmZlclsxXS50aW1lc3RhbXAsIHJlbmRlclRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc2MueSA9IHRoaXMuaW50ZXJwb2xhdGUoYnVmZmVyWzBdLnNoYXJlYWJsZURhdGEueSwgYnVmZmVyWzFdLnNoYXJlYWJsZURhdGEueSwgYnVmZmVyWzBdLnRpbWVzdGFtcCwgYnVmZmVyWzFdLnRpbWVzdGFtcCwgcmVuZGVyVGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBteURpc2MgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbS5zdGFkaXVtLmRpc2NzLmZpbHRlcigoZGlzYykgPT4gZGlzYy5wbGF5ZXIgPT0gbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuaWQpO1xuICAgICAgICBpZiAobXlEaXNjWzBdICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLmRyYXdQbGF5ZXJEaXNjRXh0TGluZShteURpc2NbMF0pO1xuICAgICAgICBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbS5zdGFkaXVtLmRpc2NzLmZvckVhY2goKGRpc2MsIGkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdHguYXJjKGRpc2MueCwgZGlzYy55LCBkaXNjLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGRpc2MucGxheWVyICE9IG51bGwgJiYgZGlzYy5wbGF5ZXIgIT0gMCAmJiBkaXNjLnBsYXllciAhPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXllciA9IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tLmN1cnJlbnRQbGF5ZXJzLmZpbHRlcigocCkgPT4gcC5pZCA9PSBkaXNjLnBsYXllcilbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBsYXllciAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdVc2VybmFtZShwbGF5ZXIudXNlcm5hbWUsIGRpc2MsIHBsYXllci50ZWFtLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXNjLmtpY2spXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdHguc3Ryb2tlU3R5bGUgPSAncmdiKDI1NSwyNTUsMjU1KSc7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdHguc3Ryb2tlU3R5bGUgPSAncmdiKDAsMCwwKSc7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgaWYgKGRpc2MuYXZhdGFyICE9IG51bGwgJiYgZGlzYy5hdmF0YXIgIT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN0eC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdHguZHJhd0ltYWdlKG1haW5fMS5kZWZhdWx0LnJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbXCJJTUFHRV9BVkFUQVJfXCIgKyBkaXNjLmF2YXRhcl0sIGRpc2MueCAtIGRpc2MucmFkaXVzLCBkaXNjLnkgLSBkaXNjLnJhZGl1cywgZGlzYy5yYWRpdXMgKiAyLCBkaXNjLnJhZGl1cyAqIDIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3JfdG9fc3R5bGUoZGlzYy5jb2xvciwgQmFzZV8xLkJhc2UuZGlzY1BoeXNpY3MuY29sb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY3R4LnN0cm9rZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHJhd1VzZXJuYW1lKHVzZXJuYW1lLCBkaXNjLCB0ZWFtKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuY3R4LmZvbnQgPSAnMTJweCBzYW5zLXNlcmlmJztcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMuc3RhdGUuY3R4Lm1lYXN1cmVUZXh0KHVzZXJuYW1lKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgdGhpcy5zdGF0ZS5jdHguc3Ryb2tlVGV4dCh1c2VybmFtZSwgZGlzYy54IC0gKHRleHQud2lkdGggLyAyKSwgZGlzYy55ICsgZGlzYy5yYWRpdXMgKyAxNSk7XG4gICAgICAgIGlmICh0ZWFtID09IFRlYW1fMS5kZWZhdWx0LlJFRC5pZClcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY3R4LmZpbGxTdHlsZSA9ICcjYmQzODM4JztcbiAgICAgICAgZWxzZSBpZiAodGVhbSA9PSBUZWFtXzEuZGVmYXVsdC5CTFVFLmlkKVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdHguZmlsbFN0eWxlID0gJyNiZDM4MzgnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgIHRoaXMuc3RhdGUuY3R4Lmdsb2JhbEFscGhhID0gMC44O1xuICAgICAgICB0aGlzLnN0YXRlLmN0eC5maWxsVGV4dCh1c2VybmFtZSwgZGlzYy54IC0gKHRleHQud2lkdGggLyAyKSwgZGlzYy55ICsgZGlzYy5yYWRpdXMgKyAxNSk7XG4gICAgICAgIHRoaXMuc3RhdGUuY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICB9XG4gICAgZHJhd1BsYXllckRpc2NFeHRMaW5lKGRpc2MpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuc3RhdGUuY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgICAgIHRoaXMuc3RhdGUuY3R4LnN0cm9rZVN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgdGhpcy5zdGF0ZS5jdHguZ2xvYmFsQWxwaGEgPSAwLjM7XG4gICAgICAgIHRoaXMuc3RhdGUuY3R4LmFyYyhkaXNjLngsIGRpc2MueSwgZGlzYy5yYWRpdXMgKyAxMCwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuc3RhdGUuY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICB9XG4gICAgaW50ZXJwb2xhdGUocDAsIHAxLCB0MCwgdDEsIHJlbmRlclRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCBkZWx0YU1vdmVtZW50ID0gKHAxIC0gcDApO1xuICAgICAgICByZXR1cm4gcDAgKyBkZWx0YU1vdmVtZW50ICogKHJlbmRlclRpbWVzdGFtcCAtIHQwKSAvICh0MSAtIHQwKTtcbiAgICB9XG4gICAgcmVzaXplX2NhbnZhcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgICAgICB2YXIgcmVjdCA9IFstKChfYiA9IChfYSA9IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFkaXVtLndpZHRoKSwgLSgoX2QgPSAoX2MgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmN1cnJlbnRSb29tKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc3RhZGl1bS5oZWlnaHQpLCAoX2YgPSAoX2UgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmN1cnJlbnRSb29tKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3RhZGl1bS53aWR0aCwgKF9oID0gKF9nID0gbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5jdXJyZW50Um9vbSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnN0YWRpdW0uaGVpZ2h0XTtcbiAgICAgICAgdmFyIGNvbnNpZGVyID0gZnVuY3Rpb24gKHB0LCByKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHB0WzBdO1xuICAgICAgICAgICAgdmFyIHkgPSBwdFsxXTtcbiAgICAgICAgICAgIGlmICh4IC0gciA8IHJlY3RbMF0pXG4gICAgICAgICAgICAgICAgcmVjdFswXSA9IHggLSByO1xuICAgICAgICAgICAgaWYgKHkgLSByIDwgcmVjdFsxXSlcbiAgICAgICAgICAgICAgICByZWN0WzFdID0geSAtIHI7XG4gICAgICAgICAgICBpZiAoeCArIHIgPiByZWN0WzJdKVxuICAgICAgICAgICAgICAgIHJlY3RbMl0gPSB4ICsgcjtcbiAgICAgICAgICAgIGlmICh5ICsgciA+IHJlY3RbM10pXG4gICAgICAgICAgICAgICAgcmVjdFszXSA9IHkgKyByO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZvcl9hbGxfc2hhcGVzKChfayA9IChfaiA9IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouY3VycmVudFJvb20pID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5zdGFkaXVtLCBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBvID0gc2hhcGUub2JqZWN0O1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndmVydGV4ZXMnOlxuICAgICAgICAgICAgICAgICAgICBjb25zaWRlcihbby54LCBvLnldLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZ29hbHMnOlxuICAgICAgICAgICAgICAgICAgICBjb25zaWRlcihvLnAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc2lkZXIoby5wMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2NzJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc2lkZXIoW28ueCwgby55XSwgby5yYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjYW52YXNfZGl2X3NpemUgPSBbdGhpcy5zdGF0ZS5jYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuc3RhdGUuY2FudmFzLmNsaWVudEhlaWdodF07XG4gICAgICAgIHJlY3QgPSBbXG4gICAgICAgICAgICBNYXRoLnJvdW5kKE1hdGgubWluKHJlY3RbMF0gLSAwLCAtY2FudmFzX2Rpdl9zaXplWzBdIC8gMikpLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChNYXRoLm1pbihyZWN0WzFdIC0gMCwgLWNhbnZhc19kaXZfc2l6ZVsxXSAvIDIpKSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoTWF0aC5tYXgocmVjdFsyXSArIDAsIGNhbnZhc19kaXZfc2l6ZVswXSAvIDIpKSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoTWF0aC5tYXgocmVjdFszXSArIDAsIGNhbnZhc19kaXZfc2l6ZVsxXSAvIDIpKSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW52YXNfcmVjdCA9IHJlY3Q7XG4gICAgICAgIHRoaXMuc3RhdGUuY2FudmFzLndpZHRoID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW52YXMuaGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG4gICAgfVxuICAgIGZvcl9hbGxfc2hhcGVzKHN0LCB0eXBlcywgZiA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFmKSB7XG4gICAgICAgICAgICBmID0gdHlwZXM7XG4gICAgICAgICAgICB0eXBlcyA9IFsndmVydGV4ZXMnLCAnc2VnbWVudHMnLCAnZ29hbHMnLCAnZGlzY3MnLCAncGxhbmVzJ107XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gc3RbbmFtZV07XG4gICAgICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgICAgICBncm91cC5mb3JFYWNoKChvYmosIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYodGhpcy5TaGFwZShuYW1lLCBvYmosIGkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFNoYXBlKHR5cGUsIG9iamVjdCwgaSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBvYmplY3Q6IG9iamVjdCwgaW5kZXg6IGkgfTtcbiAgICB9XG4gICAgcmVuZGVyYmcoc3RhZGl1bSwgY3R4KSB7XG4gICAgICAgIHZhciBiZyA9IHN0YWRpdW0uYmc7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmIChiZy50eXBlID09ICdncmFzcycgfHwgYmcudHlwZSA9PSAnaG9ja2V5Jykge1xuICAgICAgICAgICAgaWYgKGJnLnR5cGUgPT0gJ2dyYXNzJylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBCYXNlXzEuQmFzZVtcImdyYXNzXCJdLmJnX2NvbG9yO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IEJhc2VfMS5CYXNlW1wiaG9ja2V5XCJdLmJnX2NvbG9yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbygtYmcud2lkdGggKyBiZy5jb3JuZXJSYWRpdXMsIC1iZy5oZWlnaHQpO1xuICAgICAgICAgICAgLy8gVE9ETzogTGVmdCBib3JkZXIgaXMgd3JvbmdcbiAgICAgICAgICAgIGN0eC5hcmNUbyhiZy53aWR0aCwgLWJnLmhlaWdodCwgYmcud2lkdGgsIC1iZy5oZWlnaHQgKyBiZy5jb3JuZXJSYWRpdXMsIGJnLmNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICBjdHguYXJjVG8oYmcud2lkdGgsIGJnLmhlaWdodCwgYmcud2lkdGggLSBiZy5jb3JuZXJSYWRpdXMsIGJnLmhlaWdodCwgYmcuY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5hcmNUbygtYmcud2lkdGgsIGJnLmhlaWdodCwgLWJnLndpZHRoLCBiZy5oZWlnaHQgLSBiZy5jb3JuZXJSYWRpdXMsIGJnLmNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICBjdHguYXJjVG8oLWJnLndpZHRoLCAtYmcuaGVpZ2h0LCAtYmcud2lkdGggKyBiZy5jb3JuZXJSYWRpdXMsIC1iZy5oZWlnaHQsIGJnLmNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoNDAsIDQwKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnN0YXRlLmN0eC5jcmVhdGVQYXR0ZXJuKG1haW5fMS5kZWZhdWx0LnJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbYElNQUdFX1RJTEVfJHtiZy50eXBlLnRvVXBwZXJDYXNlKCl9YF0sIG51bGwpO1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KC1zdGFkaXVtLndpZHRoIC0gNTAsIC1zdGFkaXVtLmhlaWdodCAtIDUwLCAyICogc3RhZGl1bS53aWR0aCAtIDQwLCAyICogc3RhZGl1bS5oZWlnaHQgLSAyMCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCAtYmcuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgYmcuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oYmcua2lja09mZlJhZGl1cywgMCk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIGJnLmtpY2tPZmZSYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQmFzZV8xLkJhc2VbXCJncmFzc1wiXS5ib3JkZXJfY29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmcudHlwZSA9PSAnJyAmJiBiZy5jb2xvciAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yX3RvX3N0eWxlKGJnLmNvbG9yKTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgtc3RhZGl1bS53aWR0aCwgLXN0YWRpdW0uaGVpZ2h0LCAyICogc3RhZGl1bS53aWR0aCwgMiAqIHN0YWRpdW0uaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSB0aGlzLmNvbG9yX3RvX3N0eWxlKGJnLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBCYXNlXzEuQmFzZVtcImdyYXNzXCJdLmJnX2NvbG9yO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBjb2xvcl90b19zdHlsZShjb2xvciwgZGVmID0gbnVsbCkge1xuICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmID8gZGVmIDogJ3JnYigwLDAsMCknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbG9yLnN1YnN0cikge1xuICAgICAgICAgICAgcmV0dXJuICcjJyArIGNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdyZ2IoJyArIGNvbG9yWzBdICsgJywnICsgY29sb3JbMV0gKyAnLCcgKyBjb2xvclsyXSArICcpJztcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTY29yZURhdGEoc2NvcmUpIHtcbiAgICAgICAgY29uc3Qgc2NvcmVSZWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNjb3JlUmVkXCIpO1xuICAgICAgICBpZiAoc2NvcmVSZWQgIT0gbnVsbClcbiAgICAgICAgICAgIHNjb3JlUmVkLnRleHRDb250ZW50ID0gc2NvcmUucmVkLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHNjb3JlQmx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2NvcmVCbHVlXCIpO1xuICAgICAgICBpZiAoc2NvcmVCbHVlICE9IG51bGwpXG4gICAgICAgICAgICBzY29yZUJsdWUudGV4dENvbnRlbnQgPSBzY29yZS5ibHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRpbWVcIiksIG92ZXJ0aW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdmVydGltZVwiKTtcbiAgICAgICAgaWYgKHRpbWUgIT0gbnVsbCAmJiBvdmVydGltZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByb29tID0gbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb207XG4gICAgICAgICAgICBpZiAocm9vbS5zY29yZS50aW1lTGltaXQgPiAwICYmIE1hdGguZmxvb3Ioc2NvcmUudGltZSkgKyAzMCA+IHJvb20uc2NvcmUudGltZUxpbWl0ICogNjApXG4gICAgICAgICAgICAgICAgdGltZS5jbGFzc0xpc3QuYWRkKFwid2FybmluZ1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aW1lLmNsYXNzTGlzdC5yZW1vdmUoXCJ3YXJuaW5nXCIpO1xuICAgICAgICAgICAgaWYgKHJvb20uc2NvcmUudGltZUxpbWl0ID4gMCAmJiBNYXRoLmZsb29yKHNjb3JlLnRpbWUpID4gcm9vbS5zY29yZS50aW1lTGltaXQgKiA2MClcbiAgICAgICAgICAgICAgICBvdmVydGltZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG92ZXJ0aW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRpbWUudGV4dENvbnRlbnQgPSB0aGlzLmZtdE1TUyhNYXRoLmZsb29yKHNjb3JlLnRpbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcm9wKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBldi5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHRcIik7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICAgICAgY29uc3Qgc2VydmVyID0gbWFpbl8xLmRlZmF1bHQucmVnaW9uU2VydmVyTWFuYWdlci5nZXRTZXJ2ZXJCeUlkKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRTZXJ2ZXIpO1xuICAgICAgICBpZiAoc2VydmVyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN3aXRjaCAoZXYudGFyZ2V0LmdldEF0dHJpYnV0ZShcImlkXCIpKSB7XG4gICAgICAgICAgICBjYXNlIFwicGlja19saXN0X3JlZFwiOiB7XG4gICAgICAgICAgICAgICAgc2VydmVyLnNlbmRNc2coXCJzZXRUZWFtUGxheWVyXCIsIHsgcGxheWVySWQ6IHBhcnNlSW50KGRhdGEpLCB0ZWFtOiBUZWFtXzEuZGVmYXVsdC5SRUQuaWQgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicGlja19saXN0X2JsdWVcIjoge1xuICAgICAgICAgICAgICAgIHNlcnZlci5zZW5kTXNnKFwic2V0VGVhbVBsYXllclwiLCB7IHBsYXllcklkOiBwYXJzZUludChkYXRhKSwgdGVhbTogVGVhbV8xLmRlZmF1bHQuQkxVRS5pZCB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuc2VuZE1zZyhcInNldFRlYW1QbGF5ZXJcIiwgeyBwbGF5ZXJJZDogcGFyc2VJbnQoZGF0YSksIHRlYW06IFRlYW1fMS5kZWZhdWx0LlNQRUNUQVRPUlMuaWQgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnREcmFnKGV2KSB7XG4gICAgICAgIGV2LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCBldi50YXJnZXQuZ2V0QXR0cmlidXRlKFwicGxheWVyX2lkXCIpKTtcbiAgICB9XG4gICAgcmVmcmVzaFBpY2tMaXN0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBwaWNrX2xpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBpY2tfbGlzdFwiKSwgcGlja19saXN0X3JlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGlja19saXN0X3JlZFwiKSwgcGlja19saXN0X2JsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBpY2tfbGlzdF9ibHVlXCIpLCBwaWNrX2xpc3Rfc3BlY3RhdG9ycyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGlja19saXN0X3NwZWN0YXRvcnNcIik7XG4gICAgICAgIGlmIChwaWNrX2xpc3QgPT0gbnVsbCB8fCBwaWNrX2xpc3RfcmVkID09IG51bGwgfHwgcGlja19saXN0X2JsdWUgPT0gbnVsbCB8fCBwaWNrX2xpc3Rfc3BlY3RhdG9ycyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwaWNrX2xpc3RfcmVkLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIHBpY2tfbGlzdF9ibHVlLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIHBpY2tfbGlzdF9zcGVjdGF0b3JzLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIChfYiA9IChfYSA9IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jdXJyZW50UGxheWVycy5mb3JFYWNoKChwbGF5ZXIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcInBsYXllcl9pZFwiLCBwbGF5ZXIuaWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBkaXYuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicm93XCIpO1xuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgIGF2YXRhci5zcmMgPSBtYWluXzEuZGVmYXVsdC5yZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW1wiSU1BR0VfQVZBVEFSX1wiICsgcGxheWVyLmF2YXRhcl0uc3JjO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGF2YXRhcik7XG4gICAgICAgICAgICBjb25zdCB1c2VybmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB1c2VybmFtZS5jbGFzc0xpc3QuYWRkKFwidXNlcm5hbWVcIik7XG4gICAgICAgICAgICBpZiAoKChfYiA9IChfYSA9IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5waWNrTW9kZSkgPT0gcGxheWVyLmlkKVxuICAgICAgICAgICAgICAgIHVzZXJuYW1lLmNsYXNzTGlzdC5hZGQoXCJwaWNrZXJcIik7XG4gICAgICAgICAgICB1c2VybmFtZS50ZXh0Q29udGVudCA9IHBsYXllci51c2VybmFtZTtcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZCh1c2VybmFtZSk7XG4gICAgICAgICAgICBjb25zdCBwaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHBpbmcuY2xhc3NMaXN0LmFkZChcInBpbmdcIik7XG4gICAgICAgICAgICBwaW5nLnRleHRDb250ZW50ID0gcGxheWVyLnBpbmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChwaW5nKTtcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIHRoaXMuc3RhcnREcmFnLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgaWYgKHBsYXllci50ZWFtLmlkID09IFRlYW1fMS5kZWZhdWx0LlJFRC5pZClcbiAgICAgICAgICAgICAgICBwaWNrX2xpc3RfcmVkLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICBlbHNlIGlmIChwbGF5ZXIudGVhbS5pZCA9PSBUZWFtXzEuZGVmYXVsdC5CTFVFLmlkKVxuICAgICAgICAgICAgICAgIHBpY2tfbGlzdF9ibHVlLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGlja19saXN0X3NwZWN0YXRvcnMuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBsYXllckpvaW4ocGxheWVyLCBwbGF5ZXJMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGxheWVyc0NvdW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwbGF5ZXJzQ291bnRcIik7XG4gICAgICAgIGlmIChwbGF5ZXJzQ291bnQgIT0gbnVsbClcbiAgICAgICAgICAgIHBsYXllcnNDb3VudC50ZXh0Q29udGVudCA9IHBsYXllckxlbmd0aC50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBsaXN0X3VzZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaXN0X3VzZXJzXCIpO1xuICAgICAgICBjb25zdCBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgbGkuZGF0YXNldC51c2VySWQgPSBwbGF5ZXIuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgbGkuc2V0QXR0cmlidXRlKFwidXNlcm5hbWVcIiwgcGxheWVyLnVzZXJuYW1lKTtcbiAgICAgICAgbGkuaW5uZXJIVE1MID0gYCR7cGxheWVyLnVzZXJuYW1lfSA8c3Bhbj4ke3BsYXllci5waW5nfTwvc3Bhbj5gO1xuICAgICAgICBsaS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5zaG93VXNlck1lbnUuYmluZCh0aGlzKSk7XG4gICAgICAgIGlmIChwbGF5ZXIudGVhbSA9PSBUZWFtXzEuZGVmYXVsdC5SRUQpXG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKFwicmVkXCIpO1xuICAgICAgICBlbHNlIGlmIChwbGF5ZXIudGVhbSA9PSBUZWFtXzEuZGVmYXVsdC5CTFVFKVxuICAgICAgICAgICAgbGkuY2xhc3NMaXN0LmFkZChcImJsdWVcIik7XG4gICAgICAgIGlmIChsaXN0X3VzZXJzICE9IG51bGwpXG4gICAgICAgICAgICBsaXN0X3VzZXJzLmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoUGlja0xpc3QoKTtcbiAgICB9XG4gICAgcGxheWVyTGVhdmUocGxheWVySWQsIHBsYXllckxlbmd0aCkge1xuICAgICAgICBjb25zdCBwbGF5ZXJzQ291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBsYXllcnNDb3VudFwiKTtcbiAgICAgICAgaWYgKHBsYXllcnNDb3VudCAhPSBudWxsKVxuICAgICAgICAgICAgcGxheWVyc0NvdW50LnRleHRDb250ZW50ID0gcGxheWVyTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxpc3RfdXNlcnMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpc3RfdXNlcnNcIik7XG4gICAgICAgIGlmIChsaXN0X3VzZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxpc3RfdXNlcnMucXVlcnlTZWxlY3RvckFsbChcImxpXCIpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuZGF0YXNldC51c2VySWQgPT0gcGxheWVySWQudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgbGlzdF91c2Vycy5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaFBpY2tMaXN0KCk7XG4gICAgfVxuICAgIG5ld0NoYXQoZGF0YSkge1xuICAgICAgICBjb25zdCBjaGF0Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjaGF0Q29udGVudFwiKTtcbiAgICAgICAgbGV0IHNjcm9sbFRvQm90dG9tID0gZmFsc2U7XG4gICAgICAgIGlmIChjaGF0Q29udGFpbmVyICE9IG51bGwgJiYgTWF0aC5hYnMoY2hhdENvbnRhaW5lci5zY3JvbGxIZWlnaHQgLSBjaGF0Q29udGFpbmVyLnNjcm9sbFRvcCAtIGNoYXRDb250YWluZXIuY2xpZW50SGVpZ2h0KSA8IDEpXG4gICAgICAgICAgICBzY3JvbGxUb0JvdHRvbSA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYW5ub3VuY2VtZW50XCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3VuY2VtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gZGF0YS5vZmZpY2lhbFRyYWQgPyBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoZGF0YS5tZXNzYWdlLCBkYXRhLnBhcmFtcyA/IGRhdGEucGFyYW1zIDogW10pIDogZGF0YS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jb2xvciAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5jb2xvciA9IGRhdGEuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmJvbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgICAgICAgICAgICAgY2hhdENvbnRhaW5lciA9PT0gbnVsbCB8fCBjaGF0Q29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGF0Q29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGEuc291bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuYXVkaW8uZ2VuZXJhbCAmJiBtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuYXVkaW8uY2hhdCA/IG1haW5fMS5kZWZhdWx0LnJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbXCJBVURJT19ISUdITElHSFRcIl0ucGxheSgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmF1ZGlvLmdlbmVyYWwgJiYgbWFpbl8xLmRlZmF1bHQuc2V0dGluZ3NNYW5hZ2VyLmF1ZGlvLmNoYXQgPyBtYWluXzEuZGVmYXVsdC5yZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW1wiQVVESU9fQ0hBVFwiXS5wbGF5KCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJwbV90b1wiOlxuICAgICAgICAgICAgY2FzZSBcInBtX2Zyb21cIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gZGF0YS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwidXNlcm5hbWVcIiwgZGF0YS51c2VybmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZChkYXRhLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS50eXBlID09IFwicG1fdG9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBgWzwgJHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0NIQVRfUE1fVE9cIiwgW2RhdGEudXNlcm5hbWVdKX1dIGA7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBgWz4gJHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0NIQVRfUE1fRlJPTVwiLCBbZGF0YS51c2VybmFtZV0pfV0gYDtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5zaG93VXNlck1lbnUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucHJlcGVuZChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhdENvbnRhaW5lciA9PT0gbnVsbCB8fCBjaGF0Q29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGF0Q29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuYXVkaW8uZ2VuZXJhbCAmJiBtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuYXVkaW8uY2hhdCA/IG1haW5fMS5kZWZhdWx0LnJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbXCJBVURJT19ISUdITElHSFRcIl0ucGxheSgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBkYXRhLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnRlYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGEudGVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUZWFtXzEuZGVmYXVsdC5SRUQuaWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS5jb2xvciA9IFRlYW1fMS5kZWZhdWx0LlJFRC5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGVhbV8xLmRlZmF1bHQuQkxVRS5pZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLmNvbG9yID0gVGVhbV8xLmRlZmF1bHQuQkxVRS5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGVhbV8xLmRlZmF1bHQuU1BFQ1RBVE9SUy5pZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLmNvbG9yID0gVGVhbV8xLmRlZmF1bHQuU1BFQ1RBVE9SUy5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gYFske21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9URUFNXCIpfV0gJHtkYXRhLnVzZXJuYW1lfTogYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZChkYXRhLnJhbmspO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gZGF0YS51c2VybmFtZSArIFwiOiBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJ1c2VybmFtZVwiLCBkYXRhLnVzZXJuYW1lKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnNob3dVc2VyTWVudS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnByZXBlbmQoc3Bhbik7XG4gICAgICAgICAgICAgICAgY2hhdENvbnRhaW5lciA9PT0gbnVsbCB8fCBjaGF0Q29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGF0Q29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5hdWRpby5nZW5lcmFsICYmIG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5hdWRpby5jaGF0ID8gbWFpbl8xLmRlZmF1bHQucmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tcIkFVRElPX0NIQVRcIl0ucGxheSgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhdENvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsVG9Cb3R0b20pXG4gICAgICAgICAgICAgICAgY2hhdENvbnRhaW5lci5zY3JvbGxUb3AgPSBjaGF0Q29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIGlmIChjaGF0Q29udGFpbmVyLmNoaWxkRWxlbWVudENvdW50ID4gMjApXG4gICAgICAgICAgICAgICAgY2hhdENvbnRhaW5lci5yZW1vdmVDaGlsZChjaGF0Q29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKVswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpc3Blcih1c2VybmFtZSkge1xuICAgICAgICBjb25zdCBjaGF0Q2F0ZWdvcnkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1zZ1R5cGVcIiksIGNoYXRNc2cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXRNc2dcIik7XG4gICAgICAgIGlmIChjaGF0Q2F0ZWdvcnkgPT0gbnVsbCB8fCBjaGF0TXNnID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBvcHRpb25WYWwgPSBudWxsO1xuICAgICAgICBBcnJheS5mcm9tKGNoYXRDYXRlZ29yeS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm9wdGlvblwiKSkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQudmFsdWUgPT0gdXNlcm5hbWUpXG4gICAgICAgICAgICAgICAgb3B0aW9uVmFsID0gZWxlbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRpb25WYWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHVzZXJuYW1lO1xuICAgICAgICAgICAgb3B0aW9uLmlubmVySFRNTCA9IHVzZXJuYW1lO1xuICAgICAgICAgICAgY2hhdENhdGVnb3J5LmFwcGVuZChvcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNoYXRDYXRlZ29yeS52YWx1ZSA9IHVzZXJuYW1lO1xuICAgICAgICBjaGF0TXNnLmZvY3VzKCk7XG4gICAgfVxuICAgIHVzZXJNZW51SXRlbShlKSB7XG4gICAgICAgIHN3aXRjaCAoZS5zcmNFbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ3aGlzcGVyXCI6IHtcbiAgICAgICAgICAgICAgICB0aGlzLndoaXNwZXIodGhpcy5zdGF0ZS5mb2N1c1VzZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInByb2ZpbGVcIjoge1xuICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LndlYlNvY2tldHNNYW5hZ2VyLnNlbmRNc2coXCJyZXF1ZXN0UHJvZmlsZVwiLCB0aGlzLnN0YXRlLmZvY3VzVXNlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZnJpZW5kXCI6IHtcbiAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC53ZWJTb2NrZXRzTWFuYWdlci5zZW5kTXNnKFwiYWRkRnJpZW5kXCIsIHRoaXMuc3RhdGUuZm9jdXNVc2VyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZXBvcnRcIjoge1xuICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LndlYlNvY2tldHNNYW5hZ2VyLnNlbmRNc2coXCJyZXBvcnRcIiwgdGhpcy5zdGF0ZS5mb2N1c1VzZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm11dGVcIjoge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoQWRtaW4oXCJuZXdfc2FuY3Rpb25cIiwgeyB0eXBlOiBcIm11dGVcIiwgdXNlcm5hbWU6IHRoaXMuc3RhdGUuZm9jdXNVc2VyIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImJhblwiOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hBZG1pbihcIm5ld19zYW5jdGlvblwiLCB7IHR5cGU6IFwiYmFuXCIsIHVzZXJuYW1lOiB0aGlzLnN0YXRlLmZvY3VzVXNlciB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoaWRlVXNlck1lbnUoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zdGF0ZS51c2VyTWVudUZ1bmN0aW9uKTtcbiAgICAgICAgY29uc3QgdXNlcl9tZW51ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1c2VyX21lbnVcIik7XG4gICAgICAgIGlmICh1c2VyX21lbnUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdXNlcl9tZW51LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgc2hvd1VzZXJNZW51KGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZS5zcmNFbGVtZW50LmdldEF0dHJpYnV0ZShcInVzZXJuYW1lXCIpID09ICgoX2EgPSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVzZXJuYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZS5mb2N1c1VzZXIgPSBlLnNyY0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwidXNlcm5hbWVcIik7XG4gICAgICAgIGNvbnN0IHVzZXJfbWVudSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidXNlcl9tZW51XCIpO1xuICAgICAgICBpZiAodXNlcl9tZW51ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIEFycmF5LmZyb20odXNlcl9tZW51LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlcIikpLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT0gXCJmcmllbmRcIiAmJiAoKF9hID0gbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRGcmllbmRieVVzZXJuYW1lKHRoaXMuc3RhdGUuZm9jdXNVc2VyKSkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICBpZiAoW1wibXV0ZVwiLCBcImJhblwiXS5pbmNsdWRlcyhlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFtcInVzZXJcIiwgXCJ2aXBcIl0uaW5jbHVkZXMobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIucmFuaykpXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXNlcl9tZW51LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHVzZXJfbWVudS5zdHlsZS5sZWZ0ID0gKGUucGFnZVggLSA3NSkgKyBcInB4XCI7XG4gICAgICAgIHVzZXJfbWVudS5zdHlsZS50b3AgPSAoZS5wYWdlWSAtIHVzZXJfbWVudS5jbGllbnRIZWlnaHQgLSAyMCkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuc3RhdGUudXNlck1lbnVGdW5jdGlvbiA9IHRoaXMuaGlkZVVzZXJNZW51LmJpbmQodGhpcyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnN0YXRlLnVzZXJNZW51RnVuY3Rpb24sIGZhbHNlKSwgMTApO1xuICAgIH1cbiAgICBnZXRSZWdpb25GbGFnKHJlZ2lvbikge1xuICAgICAgICBzd2l0Y2ggKHJlZ2lvbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiZXVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJFVVwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJVTkRFRklORURcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuYXBwID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYXBwLmlubmVySFRNTCA9XG4gICAgICAgICAgICBgPGRpdiBjbGFzcz1cImdhbWVTY3JlZW5cIj5cclxuICAgICAgICAgICAgICAgIDxjYW52YXMgaWQ9XCJnYW1lXCIgdGFiaW5kZXg9XCIxXCI+PC9jYW52YXM+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb29tU2NvcmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNpcmNsZSByZWRcIj48L2Rpdj4gPHNwYW4gaWQ9XCJzY29yZVJlZFwiPjwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJzcGFjZVwiPi08L3NwYW4+IDxzcGFuIGlkPVwic2NvcmVCbHVlXCI+PC9zcGFuPiA8ZGl2IGNsYXNzPVwiY2lyY2xlIGJsdWVcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpbWVcIj48aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvaWNvbnMvY2xvY2sucG5nXCI+IDxzcGFuIGlkPVwidGltZVwiPjwvc3Bhbj4gPHNwYW4gaWQ9XCJvdmVydGltZVwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9HRU5FUkFMX09WRVJUSU1FXCIpfTwvc3Bhbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGxheWVyc1wiPjxpbWcgc3JjPVwiYXNzZXRzL2ltYWdlcy9pY29ucy9wbGF5ZXJzLnBuZ1wiPiA8c3BhbiBpZD1cInBsYXllcnNDb3VudFwiPjwvc3Bhbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm9vbU5hbWVcIj48aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvZmxhZ3MvcmVnaW9uLyR7dGhpcy5nZXRSZWdpb25GbGFnKHRoaXMuc3RhdGUuY3VycmVudFVzZXIuY3VycmVudFNlcnZlcil9LnN2Z1wiLz48c3BhbiBpZD1cInJvb21OYW1lXCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN0YXRzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPjxzcGFuIGlkPVwiZnBzXCI+MDwvc3Bhbj4gZnBzPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicmVsYXRpdmVfY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIm5vdGlmXCI+PC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbFwiIGlkPVwicGlja19saXN0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwaWNrX2xpc3RfZmxleFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciByZWRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlX2NvbnRlbnRcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfVEVBTV9SRURcIil9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50IHBpY2tfbGlzdF90ZWFtXCIgaWQ9XCJwaWNrX2xpc3RfcmVkXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHNwZWN0YXRvcnNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlX2NvbnRlbnRcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfVEVBTV9TUEVDVEFUT1JTXCIpfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudCBwaWNrX2xpc3RfdGVhbVwiIGlkPVwicGlja19saXN0X3NwZWN0YXRvcnNcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIgYmx1ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVfY29udGVudFwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9URUFNX0JMVUVcIil9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50IHBpY2tfbGlzdF90ZWFtXCIgaWQ9XCJwaWNrX2xpc3RfYmx1ZVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWxcIiBpZD1cImFkbWluXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZV9jb250ZW50XCI+PGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL2ljb25zL3NldHRpbmdzLnN2Z1wiPiAke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfQURNSU5cIil9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgaWQ9XCJhZG1pbl9tZW51XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHR5cGU9XCJ0ZWFtXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0FETUlOX1RFQU1cIil9PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgdHlwZT1cInJlcG9ydHNcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfQURNSU5fUkVQT1JUU1wiKX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSB0eXBlPVwic2FuY3Rpb25zXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0FETUlOX1NBTkNUSU9OU1wiKX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSB0eXBlPVwibmV3X3NhbmN0aW9uXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0FETUlOX05FV19TQU5DVElPTlwiKX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSB0eXBlPVwicmFua1wiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9BRE1JTl9SQU5LXCIpfTwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5X3RpdGxlXCI+PHNwYW4gaWQ9XCJhZG1pbl90aXRsZVwiPjwvc3Bhbj48L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImFkbWluX2NvbnRlbnRcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJib3R0b21cIj48YnV0dG9uIGNsYXNzPVwiY2xvc2VcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9DTE9TRVwiKX08L2J1dHRvbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbFwiIGlkPVwibGVhZGVyYm9hcmRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlX2NvbnRlbnRcIj48aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvaWNvbnMvc2V0dGluZ3Muc3ZnXCI+ICR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9MRUFERVJCT0FSRFwiKX08L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpbHRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTEVBREVSQk9BUkRfRklMVEVSXCIpfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD1cImxlYWRlcmJvYXJkRmlsdGVyXCI+PC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJsZWFkZXJib2FyZENvbnRlbnRcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJib3R0b21cIj48YnV0dG9uIGNsYXNzPVwiY2xvc2VcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfR0VORVJBTF9DTE9TRVwiKX08L2J1dHRvbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbFwiIGlkPVwicHJvZmlsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYXZhdGFyXCI+PGltZyBwcm9maWxlX2RhdGE9XCJhdmF0YXJcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVfY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YXRlXCIgcHJvZmlsZV9kYXRhPVwib25saW5lXCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBwcm9maWxlX2RhdGE9XCJ1c2VybmFtZVwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NUQVRTX1JFR0lTVEVSRURcIil9OiA8c3BhbiBwcm9maWxlX2RhdGE9XCJyZWdpc3RlcmVkXCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19MRVZFTF9YUFwiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cImxldmVsX3hwXCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19FTE9cIil9OiA8c3BhbiBwcm9maWxlX2RhdGE9XCJlbG9cIj48L3NwYW4+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXRlZ29yeVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2F0ZWdvcnlfdGl0bGVcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU1RBVFNfR0FNRVNcIil9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NUQVRTX0dBTUVTX1BMQVlFRFwiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cImdhbWVzX3BsYXllZFwiPjwvc3Bhbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU1RBVFNfR0FNRVNfV09OXCIpfTogPHNwYW4gcHJvZmlsZV9kYXRhPVwiZ2FtZXNfd29uXCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19HQU1FU19MT1NUXCIpfTogPHNwYW4gcHJvZmlsZV9kYXRhPVwiZ2FtZXNfbG9zdFwiPjwvc3Bhbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU1RBVFNfV0lOX1JBVEVcIil9OiA8c3BhbiBwcm9maWxlX2RhdGE9XCJ3aW5fcmF0ZVwiPjwvc3Bhbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU1RBVFNfQkVTVF9TVFJFQUtcIil9OiA8c3BhbiBwcm9maWxlX2RhdGE9XCJiZXN0X3N0cmVha1wiPjwvc3Bhbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXRlZ29yeV90aXRsZVwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19HRU5FUkFMXCIpfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19TSE9UU1wiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cInNob3RzXCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19TSE9UU19QRVJfTUFUQ0hcIil9OiA8c3BhbiBwcm9maWxlX2RhdGE9XCJzaG90c19wZXJfbWF0Y2hcIj48L3NwYW4+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NUQVRTX0dPQUxTXCIpfTogPHNwYW4gcHJvZmlsZV9kYXRhPVwiZ29hbHNcIj48L3NwYW4+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NUQVRTX0dPQUxTX1BFUl9NQVRDSFwiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cImdvYWxzX3Blcl9tYXRjaFwiPjwvc3Bhbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU1RBVFNfSEFUX1RSSUNLU1wiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cImhhdF90cmlja3NcIj48L3NwYW4+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NUQVRTX0FTU0lTVFNcIil9OiA8c3BhbiBwcm9maWxlX2RhdGE9XCJhc3Npc3RzXCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19BU1NJU1RTX1BFUl9NQVRDSFwiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cImFzc2lzdHNfcGVyX21hdGNoXCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19TQVZFU1wiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cInNhdmVzXCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19TQVZFU19QRVJfTUFUQ0hcIil9OiA8c3BhbiBwcm9maWxlX2RhdGE9XCJzYXZlc19wZXJfbWF0Y2hcIj48L3NwYW4+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NUQVRTX1BBU1NfQUNDVVJBQ1lcIil9OiA8c3BhbiBwcm9maWxlX2RhdGE9XCJwYXNzX2FjY3VyYWN5XCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9TVEFUU19QQVNTX1BFUl9NQVRDSFwiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cInBhc3NfcGVyX21hdGNoXCI+PC9zcGFuPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2F0ZWdvcnlcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5X3RpdGxlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NUQVRTX0dPQUxLRUVQRVJcIil9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NUQVRTX1BMQVlFRF9HS1wiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cInBsYXllZF9na1wiPjwvc3Bhbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU1RBVFNfQ1NcIil9OiA8c3BhbiBwcm9maWxlX2RhdGE9XCJjc1wiPjwvc3Bhbj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU1RBVFNfQ1NfUEVSQ0VOVEFHRVwiKX06IDxzcGFuIHByb2ZpbGVfZGF0YT1cImNzX3BlcmNlbnRhZ2VcIj48L3NwYW4+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXRlZ29yeVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2F0ZWdvcnlfdGl0bGVcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU1RBVFNfQkFER0VTXCIpfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9HRU5FUkFMX05PVF9BVkFJTEFCTEVcIil9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYm90dG9tXCI+PGJ1dHRvbiBjbGFzcz1cImNsb3NlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0dFTkVSQUxfQ0xPU0VcIil9PC9idXR0b24+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWxcIiBpZD1cInNldHRpbmdzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZV9jb250ZW50XCI+PGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL2ljb25zL3NldHRpbmdzLnN2Z1wiPiAke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfU0VUVElOR1NcIil9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cIm1lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNhdGVnb3J5PVwiZ3JhcGhpY3NcIiBjbGFzcz1cInNlbGVjdGVkXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX01FTlVfR1JBUEhJQ1NcIil9PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNhdGVnb3J5PVwiYXVkaW9cIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9BVURJT1wiKX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2F0ZWdvcnk9XCJpbnB1dHNcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9JTlBVVFNcIil9PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2F0ZWdvcnlcIiBjYXRlZ29yeV9uYW1lPVwiZ3JhcGhpY3NcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX01FTlVfR1JBUEhJQ1NfWk9PTVwiKX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHR5cGU9XCJzZXR0aW5nc1wiIHNldHRpbmdzX2NhdGVnb3J5PVwiZ3JhcGhpY3NcIiBzZXR0aW5nc192YWw9XCJ6b29tXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9HUkFQSElDU19aT09NXCIpfSAxeDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxLjI1XCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX01FTlVfR1JBUEhJQ1NfWk9PTVwiKX0gMS4yNXg8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMS41XCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX01FTlVfR1JBUEhJQ1NfWk9PTVwiKX0gMS41eDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxLjc1XCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX01FTlVfR1JBUEhJQ1NfWk9PTVwiKX0gMS43NXg8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMlwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9NRU5VX0dSQVBISUNTX1pPT01cIil9IDJ4PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjIuMjVcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9HUkFQSElDU19aT09NXCIpfSAyLjI1eDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyLjVcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9HUkFQSElDU19aT09NXCIpfSAyLjV4PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9HUkFQSElDU19GUFNcIil9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCB0eXBlPVwic2V0dGluZ3NcIiBzZXR0aW5nc19jYXRlZ29yeT1cImdyYXBoaWNzXCIgc2V0dGluZ3NfdmFsPVwiZnBzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjBcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9HUkFQSElDU19GUFNfTk9fTElNSVRcIil9PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjYwXCI+NjA8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMzBcIj4zMDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyMFwiPjIwPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEwXCI+MTA8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5XCIgY2F0ZWdvcnlfbmFtZT1cImF1ZGlvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9NRU5VX0FVRElPX0dFTkVSQUxcIil9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9nZ2xlLXJlY3RcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJzZXR0aW5nc19hdWRpb19nZW5lcmFsXCIgc2V0dGluZ3NfY2F0ZWdvcnk9XCJhdWRpb1wiIHNldHRpbmdzX3ZhbD1cImdlbmVyYWxcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwic2V0dGluZ3NfYXVkaW9fZ2VuZXJhbFwiPjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9BVURJT19DSEFUXCIpfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRvZ2dsZS1yZWN0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwic2V0dGluZ3NfYXVkaW9fY2hhdFwiIHNldHRpbmdzX2NhdGVnb3J5PVwiYXVkaW9cIiBzZXR0aW5nc192YWw9XCJjaGF0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInNldHRpbmdzX2F1ZGlvX2NoYXRcIj48L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX01FTlVfQVVESU9fR0FNRVwiKX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0b2dnbGUtcmVjdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInNldHRpbmdzX2F1ZGlvX2dhbWVcIiBzZXR0aW5nc19jYXRlZ29yeT1cImF1ZGlvXCIgc2V0dGluZ3NfdmFsPVwiZ2FtZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJzZXR0aW5nc19hdWRpb19nYW1lXCI+PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9NRU5VX0FVRElPX05PVElGSUNBVElPTlwiKX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0b2dnbGUtcmVjdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInNldHRpbmdzX2F1ZGlvX25vdGlmXCIgc2V0dGluZ3NfY2F0ZWdvcnk9XCJhdWRpb1wiIHNldHRpbmdzX3ZhbD1cIm5vdGlmXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInNldHRpbmdzX2F1ZGlvX25vdGlmXCI+PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5XCIgY2F0ZWdvcnlfbmFtZT1cImlucHV0c1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwicmVjb3JkS2V5XCI+PGRpdj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9JTlBVVFNfUFJFU1NcIil9PC9kaXY+PC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IGlucHV0c1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX01FTlVfSU5QVVRTX1VQXCIpfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0c192YWx1ZVwiIHNldHRpbmdzX2NhdGVnb3J5PVwiaW5wdXRzXCIgc2V0dGluZ3NfdmFsPVwidXBcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IGlucHV0c1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX01FTlVfSU5QVVRTX0RPV05cIil9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXRzX3ZhbHVlXCIgc2V0dGluZ3NfY2F0ZWdvcnk9XCJpbnB1dHNcIiBzZXR0aW5nc192YWw9XCJkb3duXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBpbnB1dHNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9NRU5VX0lOUFVUU19MRUZUXCIpfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0c192YWx1ZVwiIHNldHRpbmdzX2NhdGVnb3J5PVwiaW5wdXRzXCIgc2V0dGluZ3NfdmFsPVwibGVmdFwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgaW5wdXRzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9JTlBVVFNfUklHSFRcIil9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXRzX3ZhbHVlXCIgc2V0dGluZ3NfY2F0ZWdvcnk9XCJpbnB1dHNcIiBzZXR0aW5nc192YWw9XCJyaWdodFwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgaW5wdXRzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfTUVOVV9JTlBVVFNfS0lDS1wiKX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dHNfdmFsdWVcIiBzZXR0aW5nc19jYXRlZ29yeT1cImlucHV0c1wiIHNldHRpbmdzX3ZhbD1cImtpY2tcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IGlucHV0c1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX01FTlVfSU5QVVRTX1RPR0dMRV9DSEFUXCIpfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0c192YWx1ZVwiIHNldHRpbmdzX2NhdGVnb3J5PVwiaW5wdXRzXCIgc2V0dGluZ3NfdmFsPVwidG9nZ2xlX2NoYXRcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYm90dG9tXCI+PGJ1dHRvbiBjbGFzcz1cImNsb3NlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0dFTkVSQUxfQ0xPU0VcIil9PC9idXR0b24+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWxcIiBpZD1cImZyaWVuZHNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlX2NvbnRlbnRcIj48aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvaWNvbnMvaGVhcnQuc3ZnXCI+ICR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9GUklFTkRTXCIpfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIiBpZD1cImZyaWVuZHNMaXN0XCI+PC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJvdHRvbVwiPjxidXR0b24gY2xhc3M9XCJjbG9zZVwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9HRU5FUkFMX0NMT1NFXCIpfTwvYnV0dG9uPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsXCIgaWQ9XCJzaG9wXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZV9jb250ZW50XCI+PGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL2ljb25zL2Jhc2tldC5zdmdcIj4gJHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1NIT1BcIil9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXRlZ29yeXNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvaW5cIj48aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvaWNvbnMvY29pbi5wbmdcIj4gPHNwYW4gaWQ9XCJzaG9wQ29pblZhbFwiPjwvc3Bhbj48L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJzaG9wQ2F0ZWdvcnlzXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtc1wiIGlkPVwic2hvcEl0ZW1zXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYm90dG9tXCI+PGJ1dHRvbiBjbGFzcz1cImNsb3NlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0dFTkVSQUxfQ0xPU0VcIil9PC9idXR0b24+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPHVsIGlkPVwidXNlcl9tZW51XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIHR5cGU9XCJtdXRlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1VTRVJfTUVOVV9NVVRFXCIpfTwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIHR5cGU9XCJiYW5cIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkdBTUVfVVNFUl9NRU5VX0JBTlwiKX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSB0eXBlPVwicHJvZmlsZVwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9VU0VSX01FTlVfUFJPRklMRVwiKX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSB0eXBlPVwiZnJpZW5kXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1VTRVJfTUVOVV9GUklFTkRcIil9PC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGkgdHlwZT1cInJlcG9ydFwiPiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9VU0VSX01FTlVfUkVQT1JUXCIpfTwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIHR5cGU9XCJ3aGlzcGVyXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX1VTRVJfTUVOVV9XSElTUEVSXCIpfTwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJib3R0b21fY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVzZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhdmF0YXJcIiBpZD1cInJlcXVlc3RfcHJvZmlsZVwiPjxpbWcgc3JjPVwiJHttYWluXzEuZGVmYXVsdC5yZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW1wiSU1BR0VfQVZBVEFSX1wiICsgKChfYSA9IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXZhdGFyKV0uc3JjfVwiIGlkPVwiYXZhdGFyXCI+PC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImdlbmVyYWxfbWVudVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgdHlwZT1cImZyaWVuZHNcIj48aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvaWNvbnMvaGVhcnQuc3ZnXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB0eXBlPVwic2hvcFwiPjxpbWcgc3JjPVwiYXNzZXRzL2ltYWdlcy9pY29ucy9iYXNrZXQuc3ZnXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB0eXBlPVwic2V0dGluZ3NcIj48aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvaWNvbnMvc2V0dGluZ3Muc3ZnXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnZW5lcmFsX21lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHR5cGU9XCJtZW51XCI+PGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL2ljb25zL21lbnUuc3ZnXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB0eXBlPVwibGVhZGVyYm9hcmRcIj48aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvaWNvbnMvbGVhZGVyYm9hcmQuc3ZnXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB0eXBlPVwidGVhbVwiPjxpbWcgc3JjPVwiYXNzZXRzL2ltYWdlcy9pY29ucy90ZWFtLnN2Z1wiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgdHlwZT1cImFkbWluXCI+PGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL2ljb25zL3N0YXIuc3ZnXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGF0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJjaGF0Q29udGVudFwiPjwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0gbWV0aG9kPVwicG9zdFwiIGlkPVwiY2hhdEZvcm1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJtc2dUeXBlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNyb29tXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0NIQVRfT1BUSU9OX1JPT01cIil9PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiN0ZWFtXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJHQU1FX0NIQVRfT1BUSU9OX1RFQU1cIil9PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImNoYXRNc2dcIiBtYXhsZW5ndGg9XCIxNTBcIiBwbGFjZWhvbGRlcj1cIiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiR0FNRV9DSEFUX01FU1NBR0VcIil9XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDx1bCBpZD1cImxpc3RfdXNlcnNcIj48L3VsPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiaGlzdG9yeVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gR2FtZVNjZW5lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb25maWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vQ29uZmlnL0NvbmZpZ1wiKSk7XG5jb25zdCBtYWluXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL21haW5cIikpO1xuY29uc3QgU2NlbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vU2NlbmVcIikpO1xuY2xhc3MgTG9naW5TY2VuZSBleHRlbmRzIFNjZW5lXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoc3RhdGUubmFtZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGFyZ3M6IG51bGwsXG4gICAgICAgICAgICBmYWtlTG9naW5JZDogMCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwibG9naW5cIixcbiAgICAgICAgICAgIHVzZXJuYW1lOiBcIlwiLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IFwiXCIsXG4gICAgICAgICAgICBwYXNzd29yZF9jb25maXJtOiBcIlwiLFxuICAgICAgICAgICAgc2VydmVyOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldFN0YXRlKHBhcmFtcykge1xuICAgICAgICB0aGlzLm9uRGVzdHJveSgpO1xuICAgICAgICBmb3IgKGxldCBpIGluIHBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVtpXSA9IHBhcmFtc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZWQoKTtcbiAgICB9XG4gICAgb25XaWxsSW5pdCgpIHtcbiAgICAgICAgc3VwZXIub25XaWxsSW5pdCgpO1xuICAgIH1cbiAgICBvbkluaXRpYWxpemVkKCkge1xuICAgICAgICBzdXBlci5vbkluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHVzZXJuYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1c2VybmFtZVwiKTtcbiAgICAgICAgdXNlcm5hbWUgPT09IG51bGwgfHwgdXNlcm5hbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJuYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLnNldFVzZXJuYW1lLmJpbmQodGhpcykpO1xuICAgICAgICBjb25zdCBwYXNzd29yZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFzc3dvcmRcIik7XG4gICAgICAgIHBhc3N3b3JkID09PSBudWxsIHx8IHBhc3N3b3JkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXNzd29yZC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5zZXRQYXNzd29yZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uc3QgcGFzc3dvcmRfY29uZmlybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFzc3dvcmRfY29uZmlybVwiKTtcbiAgICAgICAgcGFzc3dvcmRfY29uZmlybSA9PT0gbnVsbCB8fCBwYXNzd29yZF9jb25maXJtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXNzd29yZF9jb25maXJtLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLnNldFBhc3N3b3JkQ29uZmlybS5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uc3Qgc2VydmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZXJ2ZXJcIik7XG4gICAgICAgIHNlcnZlciA9PT0gbnVsbCB8fCBzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZlci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuc2V0U2VydmVyLmJpbmQodGhpcykpO1xuICAgICAgICBjb25zdCByZWdpc3RlckJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVnaXN0ZXJcIik7XG4gICAgICAgIHJlZ2lzdGVyQnV0dG9uID09PSBudWxsIHx8IHJlZ2lzdGVyQnV0dG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RlckJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5zZXRDb250ZW50KFwicmVnaXN0ZXJcIikpO1xuICAgICAgICBjb25zdCBsb2dpbkJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9naW5cIik7XG4gICAgICAgIGxvZ2luQnV0dG9uID09PSBudWxsIHx8IGxvZ2luQnV0dG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2dpbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5zZXRDb250ZW50KFwibG9naW5cIikpO1xuICAgICAgICBjb25zdCBmbGFnQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbGFnXCIpO1xuICAgICAgICBmbGFnQnV0dG9uID09PSBudWxsIHx8IGZsYWdCdXR0b24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZsYWdCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuc2V0Q29udGVudChcImxhbmd1YWdlXCIpKTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZmxhZ19yb3dcIik7XG4gICAgICAgIEFycmF5LmZyb20oZmxhZ3MpLmZvckVhY2goZmxhZ1JvdyA9PiB7XG4gICAgICAgICAgICBmbGFnUm93ID09PSBudWxsIHx8IGZsYWdSb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZsYWdSb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuc2V0QWN0aXZlTGFuZ3VhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBsb2dpbkZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvZ2luRm9ybVwiKTtcbiAgICAgICAgbG9naW5Gb3JtID09PSBudWxsIHx8IGxvZ2luRm9ybSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9naW5Gb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgdGhpcy5sb2dpbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJGb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZWdpc3RlckZvcm1cIik7XG4gICAgICAgIHJlZ2lzdGVyRm9ybSA9PT0gbnVsbCB8fCByZWdpc3RlckZvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZ2lzdGVyRm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMucmVnaXN0ZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIC8qXG4gICAgICAgIGNvbnN0IHNlcnZlcnNlID0gQXBwbGljYXRpb24ucmVnaW9uU2VydmVyTWFuYWdlci5nZXRTZXJ2ZXJCeUlkKHRoaXMuc3RhdGUuc2VydmVyKTtcbiAgICAgICAgaWYoc2VydmVyc2UgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHtlcnJvcjogXCJBQ0NPVU5UX0VSUk9SX09DQ1VSRURcIn0pO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5zdGF0ZS5mYWtlTG9naW5JZCA9PSAwKVxuICAgICAgICAgICAgQXBwbGljYXRpb24ud2ViU29ja2V0c01hbmFnZXIuc2VuZE1zZyhcInRyeUxvZ2luXCIsIHt1c2VybmFtZTogdGhpcy5zdGF0ZS51c2VybmFtZSwgcGFzc3dvcmQ6IHRoaXMuc3RhdGUucGFzc3dvcmQsIHNlcnZlcjogdGhpcy5zdGF0ZS5zZXJ2ZXIsIHNlcnZlckNsaWVudElkOiBzZXJ2ZXJzZS5jbGllbnRJZH0pXG4gICAgKi9cbiAgICB9XG4gICAgc2V0VXNlcm5hbWUoZSkge1xuICAgICAgICB0aGlzLnN0YXRlLnVzZXJuYW1lID0gZS50YXJnZXQudmFsdWU7XG4gICAgfVxuICAgIHNldFBhc3N3b3JkKGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wYXNzd29yZCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgIH1cbiAgICBzZXRQYXNzd29yZENvbmZpcm0oZSkge1xuICAgICAgICB0aGlzLnN0YXRlLnBhc3N3b3JkX2NvbmZpcm0gPSBlLnRhcmdldC52YWx1ZTtcbiAgICB9XG4gICAgc2V0U2VydmVyKGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXJ2ZXIgPSBlLnRhcmdldC52YWx1ZTtcbiAgICB9XG4gICAgb25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5vbkRlc3Ryb3koKTtcbiAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInVzZXJuYW1lXCIpO1xuICAgICAgICB1c2VybmFtZSA9PT0gbnVsbCB8fCB1c2VybmFtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlcm5hbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLnNldFVzZXJuYW1lLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBhc3N3b3JkXCIpO1xuICAgICAgICBwYXNzd29yZCA9PT0gbnVsbCB8fCBwYXNzd29yZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFzc3dvcmQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLnNldFBhc3N3b3JkLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcGFzc3dvcmRfY29uZmlybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFzc3dvcmRfY29uZmlybVwiKTtcbiAgICAgICAgcGFzc3dvcmRfY29uZmlybSA9PT0gbnVsbCB8fCBwYXNzd29yZF9jb25maXJtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXNzd29yZF9jb25maXJtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5zZXRQYXNzd29yZENvbmZpcm0uYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBzZXJ2ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlcnZlclwiKTtcbiAgICAgICAgc2VydmVyID09PSBudWxsIHx8IHNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5zZXRTZXJ2ZXIuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICBjb25zdCByZWdpc3RlckJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVnaXN0ZXJcIik7XG4gICAgICAgIHJlZ2lzdGVyQnV0dG9uID09PSBudWxsIHx8IHJlZ2lzdGVyQnV0dG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RlckJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5zZXRDb250ZW50KFwicmVnaXN0ZXJcIiksIGZhbHNlKTtcbiAgICAgICAgY29uc3QgbG9naW5CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlZ2lzdGVyXCIpO1xuICAgICAgICBsb2dpbkJ1dHRvbiA9PT0gbnVsbCB8fCBsb2dpbkJ1dHRvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9naW5CdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuc2V0Q29udGVudChcImxvZ2luXCIpLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGZsYWdCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlZ2lzdGVyXCIpO1xuICAgICAgICBmbGFnQnV0dG9uID09PSBudWxsIHx8IGZsYWdCdXR0b24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZsYWdCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuc2V0Q29udGVudChcImxhbmd1YWdlXCIpLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImZsYWdfcm93XCIpO1xuICAgICAgICBBcnJheS5mcm9tKGZsYWdzKS5mb3JFYWNoKGZsYWdSb3cgPT4ge1xuICAgICAgICAgICAgZmxhZ1JvdyA9PT0gbnVsbCB8fCBmbGFnUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmbGFnUm93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnNldEFjdGl2ZUxhbmd1YWdlLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxvZ2luRm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9naW5Gb3JtXCIpO1xuICAgICAgICBsb2dpbkZvcm0gPT09IG51bGwgfHwgbG9naW5Gb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2dpbkZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCB0aGlzLmxvZ2luLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJGb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZWdpc3RlckZvcm1cIik7XG4gICAgICAgIHJlZ2lzdGVyRm9ybSA9PT0gbnVsbCB8fCByZWdpc3RlckZvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZ2lzdGVyRm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMucmVnaXN0ZXIuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIH1cbiAgICBzZXRBY3RpdmVMYW5ndWFnZShlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PSBudWxsIHx8IGUudGFyZ2V0LmlkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5zZXRMYW5ndWFnZShlLnRhcmdldC5pZCk7XG4gICAgICAgIHRoaXMuc2V0Q29udGVudChcImxvZ2luXCIpO1xuICAgIH1cbiAgICBzZXRDb250ZW50KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcImxvZ2luXCIgfHwgdmFsdWUgPT0gXCJyZWdpc3RlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVzZXJuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucGFzc3dvcmQgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5wYXNzd29yZF9jb25maXJtID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZXJyb3IgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjb250ZW50OiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgbG9naW4oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHNlcnZlciA9IG1haW5fMS5kZWZhdWx0LnJlZ2lvblNlcnZlck1hbmFnZXIuZ2V0U2VydmVyQnlJZCh0aGlzLnN0YXRlLnNlcnZlcik7XG4gICAgICAgIGlmIChzZXJ2ZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IFwiQUNDT1VOVF9FUlJPUl9PQ0NVUkVEXCIgfSk7XG4gICAgICAgIG1haW5fMS5kZWZhdWx0LndlYlNvY2tldHNNYW5hZ2VyLnNlbmRNc2coXCJ0cnlMb2dpblwiLCB7IHVzZXJuYW1lOiB0aGlzLnN0YXRlLnVzZXJuYW1lLCBwYXNzd29yZDogdGhpcy5zdGF0ZS5wYXNzd29yZCwgc2VydmVyOiB0aGlzLnN0YXRlLnNlcnZlciwgc2VydmVyQ2xpZW50SWQ6IHNlcnZlci5jbGllbnRJZCB9KTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHNlcnZlciA9IG1haW5fMS5kZWZhdWx0LnJlZ2lvblNlcnZlck1hbmFnZXIuZ2V0U2VydmVyQnlJZCh0aGlzLnN0YXRlLnNlcnZlcik7XG4gICAgICAgIGlmIChzZXJ2ZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IFwiQUNDT1VOVF9FUlJPUl9PQ0NVUkVEXCIgfSk7XG4gICAgICAgIG1haW5fMS5kZWZhdWx0LndlYlNvY2tldHNNYW5hZ2VyLnNlbmRNc2coXCJ0cnlSZWdpc3RlclwiLCB7IHVzZXJuYW1lOiB0aGlzLnN0YXRlLnVzZXJuYW1lLCBwYXNzd29yZDogdGhpcy5zdGF0ZS5wYXNzd29yZCwgcGFzc3dvcmRfY29uZmlybTogdGhpcy5zdGF0ZS5wYXNzd29yZF9jb25maXJtLCBzZXJ2ZXI6IHRoaXMuc3RhdGUuc2VydmVyLCBzZXJ2ZXJDbGllbnRJZDogc2VydmVyLmNsaWVudElkIH0pO1xuICAgIH1cbiAgICByZW5kZXJBdmFpYWJsZUxhbmd1YWdlKCkge1xuICAgICAgICBsZXQgY29udGVudCA9IGBgO1xuICAgICAgICBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0QXZhaWxhYmxlTGFuZ3VhZ2VzKCkuZm9yRWFjaCgobGFuZ3VhZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYDxpbWcgc3JjPVwiYXNzZXRzL2ltYWdlcy9mbGFncy8ke2xhbmd1YWdlfS5zdmdcIiBjbGFzcz1cImZsYWdfcm93XCIgaWQ9XCIke2xhbmd1YWdlfVwiPmA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgcmVuZGVyU2VydmVycygpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBgYDtcbiAgICAgICAgbWFpbl8xLmRlZmF1bHQucmVnaW9uU2VydmVyTWFuYWdlci5nZXRBbGxTZXJ2ZXJzKCkuZm9yRWFjaCgoc2VydmVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZXJ2ZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlcnZlciA9IHNlcnZlci5pZDtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYDxvcHRpb24gdmFsdWU9XCIke3NlcnZlci5pZH1cIiAke3RoaXMuc3RhdGUuc2VydmVyID09IHNlcnZlci5pZCA/IFwic2VsZWN0ZWRcIiA6IG51bGx9PiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiQUNDT1VOVF9TRVJWRVJcIiwgW3NlcnZlci5pZCwgc2VydmVyLnBpbmddKX08L29wdGlvbj5gO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIHJlbmRlckVycm9yKCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBgYDtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmZha2VMb2dpbklkKys7XG5cbiAgICAgICAgICAgIGNvbnN0IHNlcnZlcnNlID0gQXBwbGljYXRpb24ucmVnaW9uU2VydmVyTWFuYWdlci5nZXRTZXJ2ZXJCeUlkKHRoaXMuc3RhdGUuc2VydmVyKTtcbiAgICAgICAgICAgIGlmKHNlcnZlcnNlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgQXBwbGljYXRpb24ud2ViU29ja2V0c01hbmFnZXIuc2VuZE1zZyhcInRyeUxvZ2luXCIsIHt1c2VybmFtZTogYCR7dGhpcy5zdGF0ZS51c2VybmFtZX0ke3RoaXMuc3RhdGUuZmFrZUxvZ2luSWR9YCwgcGFzc3dvcmQ6IHRoaXMuc3RhdGUucGFzc3dvcmQsIHNlcnZlcjogdGhpcy5zdGF0ZS5zZXJ2ZXIsIHNlcnZlckNsaWVudElkOiBzZXJ2ZXJzZS5jbGllbnRJZH0pXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXJyb3IgPSBgPGRpdiBjbGFzcz1cImVycm9yXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkodGhpcy5zdGF0ZS5lcnJvciwgdGhpcy5zdGF0ZS5hcmdzKX08L2Rpdj5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyQ29udGVudCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsb2dpblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cImxvZ2luXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL2xvZ28ucG5nXCIgY2xhc3M9XCJsb2dvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJBQ0NPVU5UX0xPR0lOXCIpfTwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR7dGhpcy5yZW5kZXJFcnJvcigpfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0gbWV0aG9kPVwicG9zdFwiIGlkPVwibG9naW5Gb3JtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cInVzZXJuYW1lXCIgcGxhY2Vob2xkZXI9XCIke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkFDQ09VTlRfVVNFUk5BTUVcIil9XCIgdmFsdWU9XCIke3RoaXMuc3RhdGUudXNlcm5hbWV9XCIgbWF4bGVuZ3RoPVwiMTVcIj48L2lucHV0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGlkPVwicGFzc3dvcmRcIiBwbGFjZWhvbGRlcj1cIiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiQUNDT1VOVF9QQVNTV09SRFwiKX1cIiB2YWx1ZT1cIiR7dGhpcy5zdGF0ZS5wYXNzd29yZH1cIj48L2lucHV0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD1cInNlcnZlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7dGhpcy5yZW5kZXJTZXJ2ZXJzKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgdmFsdWU9XCIke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkFDQ09VTlRfTE9HSU5cIil9XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsaW5lXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPVwicmVnaXN0ZXJcIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkFDQ09VTlRfUkVHSVNURVJcIil9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvZmxhZ3MvJHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJDT0RFXCIpfS5zdmdcIiBjbGFzcz1cImZsYWdcIiBpZD1cImZsYWdcIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+YDtcbiAgICAgICAgICAgIGNhc2UgXCJyZWdpc3RlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cInJlZ2lzdGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL2xvZ28ucG5nXCIgY2xhc3M9XCJsb2dvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJBQ0NPVU5UX1JFR0lTVEVSXCIpfTwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR7dGhpcy5yZW5kZXJFcnJvcigpfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0gbWV0aG9kPVwicG9zdFwiIGlkPVwicmVnaXN0ZXJGb3JtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cInVzZXJuYW1lXCIgcGxhY2Vob2xkZXI9XCIke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkFDQ09VTlRfVVNFUk5BTUVcIil9XCIgdmFsdWU9XCIke3RoaXMuc3RhdGUudXNlcm5hbWV9XCIgbWF4bGVuZ3RoPVwiMTVcIj48L2lucHV0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGlkPVwicGFzc3dvcmRcIiBwbGFjZWhvbGRlcj1cIiR7bWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KFwiQUNDT1VOVF9QQVNTV09SRFwiKX1cIiB2YWx1ZT1cIiR7dGhpcy5zdGF0ZS5wYXNzd29yZH1cIj48L2lucHV0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGlkPVwicGFzc3dvcmRfY29uZmlybVwiIHBsYWNlaG9sZGVyPVwiJHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJBQ0NPVU5UX0NPTkZJUk1fUEFTU1dPUkRcIil9XCIgdmFsdWU9XCIke3RoaXMuc3RhdGUucGFzc3dvcmRfY29uZmlybX1cIj48L2lucHV0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD1cInNlcnZlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7dGhpcy5yZW5kZXJTZXJ2ZXJzKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgdmFsdWU9XCIke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkFDQ09VTlRfUkVHSVNURVJcIil9XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsaW5lXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPVwibG9naW5cIj4ke21haW5fMS5kZWZhdWx0Lmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleShcIkFDQ09VTlRfTE9HSU5cIil9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvZmxhZ3MvJHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJDT0RFXCIpfS5zdmdcIiBjbGFzcz1cImZsYWdcIiBpZD1cImZsYWdcIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+YDtcbiAgICAgICAgICAgIGNhc2UgXCJsYW5ndWFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cImxhbmd1YWdlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL2xvZ28ucG5nXCIgY2xhc3M9XCJsb2dvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJBQ0NPVU5UX0xBTkdVQUdFXCIpfTwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGFnc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHt0aGlzLnJlbmRlckF2YWlhYmxlTGFuZ3VhZ2UoKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5gO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmFwcCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFwcC5pbm5lckhUTUwgPVxuICAgICAgICAgICAgYDxkaXYgY2xhc3M9XCJhY2NvdW50XCI+XHJcblxyXG4gICAgICAgICAgICAgICAgJHt0aGlzLnJlbmRlckNvbnRlbnQoKX1cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9vdGVyXCI+JHttYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoXCJDT1BZUklHSFRcIiwgW0NvbmZpZ18xLmRlZmF1bHQuTkFNRV0pfTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5gO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IExvZ2luU2NlbmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbmZpZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9Db25maWcvQ29uZmlnXCIpKTtcbmNvbnN0IFNjZW5lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1NjZW5lXCIpKTtcbmNsYXNzIE1lc3NhZ2VTY2VuZSBleHRlbmRzIFNjZW5lXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoc3RhdGUubmFtZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBzdGF0ZS5wYXJhbXMubWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRTdGF0ZShwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIuc2V0U3RhdGUocGFyYW1zKTtcbiAgICAgICAgZm9yIChsZXQgaSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVbaV0gPSBwYXJhbXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgb25XaWxsSW5pdCgpIHtcbiAgICAgICAgc3VwZXIub25XaWxsSW5pdCgpO1xuICAgICAgICBkb2N1bWVudC50aXRsZSA9IENvbmZpZ18xLmRlZmF1bHQuTkFNRTtcbiAgICB9XG4gICAgb25Jbml0aWFsaXplZCgpIHtcbiAgICAgICAgc3VwZXIub25Jbml0aWFsaXplZCgpO1xuICAgIH1cbiAgICBvbkRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLm9uRGVzdHJveSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmFwcCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFwcC5pbm5lckhUTUwgPVxuICAgICAgICAgICAgYDxkaXYgY2xhc3M9XCJsb2FkaW5nU2NyZWVuXCI+XHJcbiAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvbG9nby5wbmdcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlXCI+JHt0aGlzLnN0YXRlW1wibWVzc2FnZVwiXX08L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+YDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNZXNzYWdlU2NlbmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG1haW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWFpblwiKSk7XG5jbGFzcyBTY2VuZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFwcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYXBwXCIpO1xuICAgICAgICBtYWluXzEuZGVmYXVsdC5sb2dnZXIuc2VuZExvZyhcIlZFUkJPU0VcIiwgYEluaXRpbGlhemluZyBzY2VuZSAke3RoaXMubmFtZX0uYCk7XG4gICAgfVxuICAgIHNldFN0YXRlKHBhcmFtcykge1xuICAgIH1cbiAgICBvbldpbGxJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5hcHAgPT0gbnVsbClcbiAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LmxvZ2dlci5zZW5kTG9nKFwiRVJST1JcIiwgXCJJbXBvc3NpYmxlIHRvIGZpbmQgI2FwcCBIVE1MIGVsZW1lbnQuXCIpO1xuICAgIH1cbiAgICBvbkluaXRpYWxpemVkKCkgeyB9XG4gICAgb25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5hcHAgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuYXBwLmlubmVySFRNTCA9IFwiXCI7XG4gICAgfVxuICAgIHJlbmRlcigpIHsgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2NlbmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2NlbmVUeXBlID0gdm9pZCAwO1xuY29uc3QgR2FtZVNjZW5lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTGlzdC9HYW1lU2NlbmVcIikpO1xuY29uc3QgTG9naW5TY2VuZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0xpc3QvTG9naW5TY2VuZVwiKSk7XG5jb25zdCBNZXNzYWdlU2NlbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9MaXN0L01lc3NhZ2VTY2VuZVwiKSk7XG5leHBvcnRzLlNjZW5lVHlwZSA9IHtcbiAgICAwOiBNZXNzYWdlU2NlbmVfMS5kZWZhdWx0LFxuICAgIDE6IExvZ2luU2NlbmVfMS5kZWZhdWx0LFxuICAgIDI6IEdhbWVTY2VuZV8xLmRlZmF1bHRcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG1haW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWFpblwiKSk7XG5jb25zdCBHYW1lU2NlbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9MaXN0L0dhbWVTY2VuZVwiKSk7XG5jb25zdCBMb2dpblNjZW5lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTGlzdC9Mb2dpblNjZW5lXCIpKTtcbmNvbnN0IE1lc3NhZ2VTY2VuZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0xpc3QvTWVzc2FnZVNjZW5lXCIpKTtcbmNvbnN0IFNjZW5lTGlzdF8xID0gcmVxdWlyZShcIi4vU2NlbmVMaXN0XCIpO1xuY2xhc3MgU2NlbmVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XG4gICAgfVxuICAgIGluaXRTY2VuZShzY2VuZSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUgaW5zdGFuY2VvZiBTY2VuZUxpc3RfMS5TY2VuZVR5cGVbc2NlbmVdKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmUuc2V0U3RhdGUocGFyYW1zKTtcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5vbkRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc2NlbmUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBTY2VuZUxpc3QuTWVzc2FnZVNjZW5lICovOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBNZXNzYWdlU2NlbmVfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTWVzc2FnZVNjZW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxIC8qIFNjZW5lTGlzdC5Mb2dpblNjZW5lICovOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBMb2dpblNjZW5lXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkxvZ2luU2NlbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDIgLyogU2NlbmVMaXN0LkdhbWVTY2VuZSAqLzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBuZXcgR2FtZVNjZW5lXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkdhbWVTY2VuZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQubG9nZ2VyLnNlbmRMb2coXCJFUlJPUlwiLCBgSW1wb3NzaWJsZSB0byBsb2FkIHNjZW5lICR7c2NlbmV9LmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjZW5lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUub25XaWxsSW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5yZW5kZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUub25Jbml0aWFsaXplZCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2NlbmVNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBTZXR0aW5nc01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdyYXBoaWNzID0ge1xuICAgICAgICAgICAgem9vbTogMS4yNSxcbiAgICAgICAgICAgIGZwczogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF1ZGlvID0ge1xuICAgICAgICAgICAgZ2VuZXJhbDogdHJ1ZSxcbiAgICAgICAgICAgIGNoYXQ6IHRydWUsXG4gICAgICAgICAgICBnYW1lOiB0cnVlLFxuICAgICAgICAgICAgbm90aWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSB7XG4gICAgICAgICAgICB1cDogW1wiQXJyb3dVcFwiXSxcbiAgICAgICAgICAgIGRvd246IFtcIkFycm93RG93blwiXSxcbiAgICAgICAgICAgIGxlZnQ6IFtcIkFycm93TGVmdFwiXSxcbiAgICAgICAgICAgIHJpZ2h0OiBbXCJBcnJvd1JpZ2h0XCJdLFxuICAgICAgICAgICAga2ljazogW1wiS2V5WFwiLCBcIlNwYWNlXCJdLFxuICAgICAgICAgICAgdG9nZ2xlX2NoYXQ6IFtcIkVudGVyXCIsIFwiTnVtcGFkRW50ZXJcIiwgXCJUYWJcIl0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoaWNzU3RvcmFnZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic2V0dGluZ3NfZ3JhcGhpY3NcIik7XG4gICAgICAgIGlmIChncmFwaGljc1N0b3JhZ2UgIT0gbnVsbCAmJiBKU09OLnBhcnNlKGdyYXBoaWNzU3RvcmFnZSkpXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzID0gSlNPTi5wYXJzZShncmFwaGljc1N0b3JhZ2UpO1xuICAgICAgICBjb25zdCBhdWRpb1N0b3JhZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNldHRpbmdzX2F1ZGlvXCIpO1xuICAgICAgICBpZiAoYXVkaW9TdG9yYWdlICE9IG51bGwgJiYgSlNPTi5wYXJzZShhdWRpb1N0b3JhZ2UpKVxuICAgICAgICAgICAgdGhpcy5hdWRpbyA9IEpTT04ucGFyc2UoYXVkaW9TdG9yYWdlKTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzZXR0aW5nc19pbnB1dHNcIik7XG4gICAgICAgIGlmIChpbnB1dHMgIT0gbnVsbCAmJiBKU09OLnBhcnNlKGlucHV0cykpXG4gICAgICAgICAgICB0aGlzLmlucHV0cyA9IEpTT04ucGFyc2UoaW5wdXRzKTtcbiAgICB9XG4gICAgc2F2ZVNldHRpbmdzKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZ3JhcGhpY3NcIjoge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic2V0dGluZ3NfZ3JhcGhpY3NcIiwgSlNPTi5zdHJpbmdpZnkodGhpcy5ncmFwaGljcykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImF1ZGlvXCI6IHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInNldHRpbmdzX2F1ZGlvXCIsIEpTT04uc3RyaW5naWZ5KHRoaXMuYXVkaW8pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbnB1dHNcIjoge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic2V0dGluZ3NfaW5wdXRzXCIsIEpTT04uc3RyaW5naWZ5KHRoaXMuaW5wdXRzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlS2V5KHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0c1t0eXBlXSA9PSBudWxsIHx8ICF0aGlzLmlucHV0c1t0eXBlXS5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaW5wdXRzW3R5cGVdID0gdGhpcy5pbnB1dHNbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkgIT0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNhdmVTZXR0aW5ncyhcImlucHV0c1wiKTtcbiAgICB9XG4gICAgc2V0U2V0dGluZ3ModHlwZSwgdmFsdWUsIHZhbCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJncmFwaGljc1wiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NbdmFsdWVdID09IG51bGwgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljc1t2YWx1ZV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlU2V0dGluZ3ModHlwZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiYXVkaW9cIjoge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvW3ZhbHVlXSA9PSBudWxsIHx8IHZhbCBpbnN0YW5jZW9mIEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvW3ZhbHVlXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVTZXR0aW5ncyh0eXBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbnB1dHNcIjoge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0c1t2YWx1ZV0gPT0gbnVsbCB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbnMgPSAodGhpcy5pbnB1dHMudXAuaW5jbHVkZXModmFsKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0cy5kb3duLmluY2x1ZGVzKHZhbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dHMubGVmdC5pbmNsdWRlcyh2YWwpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzLnJpZ2h0LmluY2x1ZGVzKHZhbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dHMua2ljay5pbmNsdWRlcyh2YWwpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzLnRvZ2dsZV9jaGF0LmluY2x1ZGVzKHZhbCkpO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyB8fCB2YWwuc3RhcnRzV2l0aChcIkRpZ2l0XCIpIHx8IHZhbCA9PSBcIktleVBcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzW3ZhbHVlXS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlU2V0dGluZ3ModHlwZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTZXR0aW5nc01hbmFnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFVzZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSBkYXRhLnVzZXJuYW1lO1xuICAgICAgICB0aGlzLnJhbmsgPSBkYXRhLnJhbms7XG4gICAgICAgIHRoaXMuYXZhdGFyID0gZGF0YS5hdmF0YXI7XG4gICAgICAgIHRoaXMuY29pbnMgPSBkYXRhLmNvaW5zO1xuICAgICAgICB0aGlzLml0ZW1zID0gZGF0YS5pdGVtcztcbiAgICAgICAgdGhpcy5mcmllbmRzID0gZGF0YS5mcmllbmRzO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXJ2ZXIgPSBkYXRhLmN1cnJlbnRTZXJ2ZXI7XG4gICAgICAgIHRoaXMuY3VycmVudFJvb20gPSBudWxsO1xuICAgIH1cbiAgICBnZXRGcmllbmRieVVzZXJuYW1lKHVzZXJuYW1lKSB7XG4gICAgICAgIGxldCBmcmllbmRSZXR1cm5lZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJpZW5kcy5mb3JFYWNoKChmcmllbmQpID0+IHtcbiAgICAgICAgICAgIGlmIChmcmllbmQudXNlcm5hbWUgPT0gdXNlcm5hbWUpXG4gICAgICAgICAgICAgICAgZnJpZW5kUmV0dXJuZWQgPSBmcmllbmQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJpZW5kUmV0dXJuZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVXNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuU3RyaW5nLnByb3RvdHlwZS5zdXBwbGFudCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZSgveyhbXnt9XSopfS9nLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgciA9IG9bYl07XG4gICAgICAgIHJldHVybiB0eXBlb2YgciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHIgPT09ICdudW1iZXInID8gciA6IGE7XG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYWtvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBha29cIikpO1xuY29uc3QgUm9vbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9Sb29tL1Jvb21cIikpO1xuY29uc3QgR2FtZVNjZW5lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL1NjZW5lL0xpc3QvR2FtZVNjZW5lXCIpKTtcbmNvbnN0IG1haW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbWFpblwiKSk7XG5jbGFzcyBSZWdpb25TZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgdGhpcy53cyA9IG51bGw7XG4gICAgICAgIHRoaXMuaWQgPSBkYXRhLmlkO1xuICAgICAgICB0aGlzLmlwID0gZGF0YS5pcDtcbiAgICAgICAgdGhpcy5wb3J0ID0gZGF0YS5wb3J0O1xuICAgICAgICB0aGlzLmNsaWVudElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5waW5nID0gMDtcbiAgICAgICAgdGhpcy5waW5nRGF0ZSA9IDA7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxQaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5nZXRQb25nID0gdHJ1ZTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KGB3czovLyR7dGhpcy5pcH06JHt0aGlzLnBvcnR9YCk7XG4gICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmludGVydmFsUGluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGluc3RhbmNlLmludGVydmFsUGluZyk7XG4gICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQucmVnaW9uU2VydmVyTWFuYWdlci5kZXN0cm95U2VydmVyKGluc3RhbmNlLmlkKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGBJbXBvc3NpYmxlIHRvIGNvbm5lY3QgdG8gc2VydmVyIHJlZ2lvbiBbJHtpbnN0YW5jZS5pZH1dLmApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmludGVydmFsUGluZyA9IHNldEludGVydmFsKGluc3RhbmNlLnNlbmRQaW5nLmJpbmQoaW5zdGFuY2UpLCAxMDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobXNnID09IG51bGwgfHwgbXNnLmRhdGEgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChtc2cuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSAoX2EgPSBldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQudGFyZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb21wcmVzcyB0aGUgQXJyYXlCdWZmZXIgdXNpbmcgUGFrb1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2UocGFrb18xLmRlZmF1bHQuaW5mbGF0ZShuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciksIHsgdG86ICdzdHJpbmcnIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NNZXNzYWdlKHBha29fMS5kZWZhdWx0LmluZmxhdGUobXNnLmRhdGEsIHsgdG86IFwic3RyaW5nXCIgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzTWVzc2FnZSA9IChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShtc2cudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicG9uZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jbGllbnRJZCA9IG1lc3NhZ2UudmFsdWUuY2xpZW50SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucGluZyA9IERhdGUubm93KCkgLSBpbnN0YW5jZS5waW5nRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmdldFBvbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShgUmVnaW9uIHNlcnZlciBbJHtpbnN0YW5jZS5pZH1dIGxvYWRlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyb29tSW5pdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbSA9IG5ldyBSb29tXzEuZGVmYXVsdChtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUgaW5zdGFuY2VvZiBHYW1lU2NlbmVfMS5kZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5pbml0Um9vbShtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGxheWVySm9pblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbCB8fCBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tLnBsYXllckpvaW4obWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lIGluc3RhbmNlb2YgR2FtZVNjZW5lXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUucGxheWVySm9pbihtZXNzYWdlLnZhbHVlLCBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbS5jdXJyZW50UGxheWVycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5hdWRpby5nZW5lcmFsICYmIG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5hdWRpby5nYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXVkaW8gPSBtYWluXzEuZGVmYXVsdC5yZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW1wiQVVESU9fSk9JTlwiXS5jbG9uZU5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpby5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGxheWVyTGVhdmVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwgfHwgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbS5wbGF5ZXJMZWF2ZShtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUgaW5zdGFuY2VvZiBHYW1lU2NlbmVfMS5kZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5wbGF5ZXJMZWF2ZShtZXNzYWdlLnZhbHVlLCBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbS5jdXJyZW50UGxheWVycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5hdWRpby5nZW5lcmFsICYmIG1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5hdWRpby5nYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXVkaW8gPSBtYWluXzEuZGVmYXVsdC5yZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW1wiQVVESU9fTEVBVkVcIl0uY2xvbmVOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW8ucGxheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcERhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwgfHwgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbS5zdGFkaXVtID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ3b3JsZFN0YXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlciA9PSBudWxsIHx8IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20udXBkYXRlKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZSBpbnN0YW5jZW9mIEdhbWVTY2VuZV8xLmRlZmF1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lLnVwZGF0ZShtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYWRkSGlzdG9yeVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbCB8fCBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tLmhpc3RvcnkucHVzaChtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUgaW5zdGFuY2VvZiBHYW1lU2NlbmVfMS5kZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5hZGRIaXN0b3J5KG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdhbWVQYXVzZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbCB8fCBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZSBpbnN0YW5jZW9mIEdhbWVTY2VuZV8xLmRlZmF1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5zdGF0ZS51bnBhdXNlSW50ZXJ2YWwgPSAoMzAwMCAtIHRoaXMucGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic291bmRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwgfHwgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1haW5fMS5kZWZhdWx0LnNldHRpbmdzTWFuYWdlci5hdWRpby5nZW5lcmFsIHx8ICFtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuYXVkaW8uZ2FtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwia2lja1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1ZGlvID0gbWFpbl8xLmRlZmF1bHQucmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tcIkFVRElPX0tJQ0tcIl0uY2xvbmVOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvLnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnb2FsXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQucmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tcIkFVRElPX0dPQUxcIl0ucGxheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5yZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW1wiQVVESU9fQ1JPV0RcIl0udm9sdW1lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQucmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tcIkFVRElPX0NST1dEXCJdLnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDIwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQucmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tcIkFVRElPX0NST1dEXCJdLnZvbHVtZSA9ICgoNDAgLSBpKSAvIDQwKSAqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBpICogMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbXCJBVURJT19DUk9XRFwiXS5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQucmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tcIkFVRElPX0NST1dEXCJdLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgNDAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZW9yZGVyUGxheWVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlciA9PSBudWxsIHx8IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY3VycmVudFJvb20ucmVvcmRlclBsYXllcihtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUgaW5zdGFuY2VvZiBHYW1lU2NlbmVfMS5kZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5yZWZyZXNoUGlja0xpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwaWNrTW9kZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbCB8fCBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmN1cnJlbnRSb29tLnBpY2tNb2RlID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5jdXJyZW50Um9vbS5waWNrTW9kZSA9PSBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5pZCAmJiBtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuYXVkaW8uZ2VuZXJhbCAmJiBtYWluXzEuZGVmYXVsdC5zZXR0aW5nc01hbmFnZXIuYXVkaW8ubm90aWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdWRpbyA9IG1haW5fMS5kZWZhdWx0LnJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbXCJBVURJT19OT1RJRlwiXS5jbG9uZU5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpby5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lIGluc3RhbmNlb2YgR2FtZVNjZW5lXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5yZWZyZXNoUGlja0xpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUuc2hvd01lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoaWRlTWVudVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lIGluc3RhbmNlb2YgR2FtZVNjZW5lXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUuaGlkZU1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGF0TWVzc2FnZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lIGluc3RhbmNlb2YgR2FtZVNjZW5lXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUubmV3Q2hhdChtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRQaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRQb25nID09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmdldFBvbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waW5nRGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc2VuZE1zZyhcInBpbmdcIiwgdGhpcy5waW5nKTtcbiAgICB9XG4gICAgc2VuZE1zZyhrZXksIHZhbHVlID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy53cyA9PSBudWxsIHx8IHRoaXMud3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pXG4gICAgICAgICAgICByZXR1cm4gbWFpbl8xLmRlZmF1bHQubG9nZ2VyLnNlbmRMb2coXCJFUlJPUlwiLCBcIkltcG9zc2libGUgdG8gc2VuZCBtZXNzYWdlIHRvIHJlZ2lvbiBzZXJ2ZXIsIHdlYnNvY2tldHMgYXJlIGRpc2Nvbm5lY3QuXCIpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoeyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICBjb25zdCBjb21wcmVzc2VkTWVzc2FnZSA9IHBha29fMS5kZWZhdWx0LmRlZmxhdGUobWVzc2FnZSk7XG4gICAgICAgIHRoaXMud3Muc2VuZChjb21wcmVzc2VkTWVzc2FnZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlZ2lvblNlcnZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbWFpbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9tYWluXCIpKTtcbmNvbnN0IFJlZ2lvblNlcnZlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1JlZ2lvblNlcnZlclwiKSk7XG5jbGFzcyBSZWdpb25TZXJ2ZXJNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWdpb25TZXJ2ZXJzID0ge307XG4gICAgfVxuICAgIGdldFNlcnZlckJ5SWQoaWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLnJlZ2lvblNlcnZlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvblNlcnZlciA9IHRoaXMucmVnaW9uU2VydmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChyZWdpb25TZXJ2ZXIuaWQgPT0gaWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lvblNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaW5pdFNlcnZlcihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmlwID09IG51bGwgfHwgdGhpcy5nZXRTZXJ2ZXJCeUlkKGRhdGEuaWQpICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHJlZ2lvblNlcnZlciA9IG5ldyBSZWdpb25TZXJ2ZXJfMS5kZWZhdWx0KGRhdGEpO1xuICAgICAgICB0aGlzLnJlZ2lvblNlcnZlcnNbcmVnaW9uU2VydmVyLmlkXSA9IHJlZ2lvblNlcnZlcjtcbiAgICAgICAgbWFpbl8xLmRlZmF1bHQubG9nZ2VyLnNlbmRMb2coXCJJTkZPXCIsIGBSZWdpb24gc2VydmVyIFske2RhdGEuaWR9XSBsb2FkZWQuYCk7XG4gICAgfVxuICAgIGluaXRBbGxTZXJ2ZXJzKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdE9mUHJvbWlzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLnJlZ2lvblNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0T2ZQcm9taXNlLnB1c2godGhpcy5yZWdpb25TZXJ2ZXJzW2ldLmNvbm5lY3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQcm9taXNlLmFsbChsaXN0T2ZQcm9taXNlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFwiQWxsIHJlZ2lvbiBzZXJ2ZXJzIGxvYWRlZC5cIik7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4gcmVqZWN0KGUudG9TdHJpbmcoKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveVNlcnZlcihpZCkge1xuICAgICAgICBjb25zdCByZWdpb25TZXJ2ZXIgPSB0aGlzLmdldFNlcnZlckJ5SWQoaWQpO1xuICAgICAgICBpZiAocmVnaW9uU2VydmVyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlZ2lvblNlcnZlci5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lvblNlcnZlcnNbaWRdO1xuICAgICAgICBtYWluXzEuZGVmYXVsdC5sb2dnZXIuc2VuZExvZyhcIklORk9cIiwgYFJlZ2lvbiBzZXJ2ZXIgWyR7aWR9XSB1bmxvYWRlZC5gKTtcbiAgICB9XG4gICAgZ2V0QWxsU2VydmVycygpIHtcbiAgICAgICAgY29uc3Qgc2VydmVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMucmVnaW9uU2VydmVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5yZWdpb25TZXJ2ZXJzW2ldO1xuICAgICAgICAgICAgc2VydmVycy5wdXNoKHsgaWQ6IHNlcnZlci5pZCwgaXA6IHNlcnZlci5pcCwgcG9ydDogc2VydmVyLnBvcnQsIHBpbmc6IHNlcnZlci5waW5nIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJ2ZXJzLnNvcnQoKGEsIGIpID0+IE51bWJlcihhLnBpbmcpIC0gTnVtYmVyKGIucGluZykpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlZ2lvblNlcnZlck1hbmFnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBha29fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGFrb1wiKSk7XG5jb25zdCBDb25maWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vQ29uZmlnL0NvbmZpZ1wiKSk7XG5jb25zdCBHYW1lU2NlbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vU2NlbmUvTGlzdC9HYW1lU2NlbmVcIikpO1xuY29uc3QgVXNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9Vc2VyL1VzZXJcIikpO1xuY29uc3QgbWFpbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYWluXCIpKTtcbmNsYXNzIFdlYnNvY2tldE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLndzID0gbnVsbDtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcztcbiAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5pbml0U2NlbmUoMCAvKiBTY2VuZUxpc3QuTWVzc2FnZVNjZW5lICovLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KCdMT0FESU5HX0NPTk5FQ1RJT05fVE9fTUFJTl9TRVJWRVInKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldChgd3M6Ly8ke0NvbmZpZ18xLmRlZmF1bHQuU0VSVkVSX0hPU1R9OiR7Q29uZmlnXzEuZGVmYXVsdC5TRVJWRVJfUE9SVH1gKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5sb2dnZXIuc2VuZExvZyhcIkVSUk9SXCIsIFwiQ29ubmVjdGlvbiB0byBzZXJ2ZXIgbG9zdC5cIik7XG4gICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLmluaXRTY2VuZSgwIC8qIFNjZW5lTGlzdC5NZXNzYWdlU2NlbmUgKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KCdHRU5FUklDX0VSUk9SX0NPTk5FQ1RJT05fTE9TVCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQubG9nZ2VyLnNlbmRMb2coXCJTVUNDRVNTXCIsIFwiQ29ubmVjdGVkIHRvIHNlcnZlci5cIik7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VuZE1zZyhcImZldGNoaW5nU2VydmVyc1wiKTtcbiAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuaW5pdFNjZW5lKDAgLyogU2NlbmVMaXN0Lk1lc3NhZ2VTY2VuZSAqLywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtYWluXzEuZGVmYXVsdC5sYW5ndWFnZU1hbmFnZXIuZ2V0VmFsdWVGb3JLZXkoJ0xPQURJTkdfRkVUQ0hJTkdfUkVHSU9OX1NFUlZFUlMnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtc2cgPT0gbnVsbCB8fCBtc2cuZGF0YSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG1zZy5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IChfYSA9IGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWNvbXByZXNzIHRoZSBBcnJheUJ1ZmZlciB1c2luZyBQYWtvXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTWVzc2FnZShwYWtvXzEuZGVmYXVsdC5pbmZsYXRlKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSwgeyB0bzogJ3N0cmluZycgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIobXNnLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2UocGFrb18xLmRlZmF1bHQuaW5mbGF0ZShtc2cuZGF0YSwgeyB0bzogXCJzdHJpbmdcIiB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NNZXNzYWdlID0gKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKG1zZy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2Uua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRBbGxTZXJ2ZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUuZm9yRWFjaCgoc2VydmVyKSA9PiBtYWluXzEuZGVmYXVsdC5yZWdpb25TZXJ2ZXJNYW5hZ2VyLmluaXRTZXJ2ZXIoc2VydmVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5yZWdpb25TZXJ2ZXJNYW5hZ2VyLmluaXRBbGxTZXJ2ZXJzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LmxvZ2dlci5zZW5kTG9nKFwiU1VDQ0VTU1wiLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQucmVnaW9uU2VydmVyTWFuYWdlci5nZXRBbGxTZXJ2ZXJzKCkubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuaW5pdFNjZW5lKDAgLyogU2NlbmVMaXN0Lk1lc3NhZ2VTY2VuZSAqLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KCdHRU5FUklDX0VSUk9SX05PX1NFUlZFUl9BVkFJTEFCTEUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuaW5pdFNjZW5lKDEgLyogU2NlbmVMaXN0LkxvZ2luU2NlbmUgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5sb2dnZXIuc2VuZExvZyhcIkVSUk9SXCIsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLmluaXRTY2VuZSgwIC8qIFNjZW5lTGlzdC5NZXNzYWdlU2NlbmUgKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KCdHRU5FUklDX0VSUk9SX1NFUlZFUlMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JMb2dpblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuaW5pdFNjZW5lKDEgLyogU2NlbmVMaXN0LkxvZ2luU2NlbmUgKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbWVzc2FnZS52YWx1ZS5rZXkgIT0gbnVsbCA/IG1lc3NhZ2UudmFsdWUua2V5IDogbWVzc2FnZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBtZXNzYWdlLnZhbHVlLmFyZ3MgIT0gbnVsbCA/IG1lc3NhZ2UudmFsdWUuYXJncyA6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXNjb25uZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5pbml0U2NlbmUoMCAvKiBTY2VuZUxpc3QuTWVzc2FnZVNjZW5lICovLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWFpbl8xLmRlZmF1bHQubGFuZ3VhZ2VNYW5hZ2VyLmdldFZhbHVlRm9yS2V5KG1lc3NhZ2UudmFsdWUua2V5LCBtZXNzYWdlLnZhbHVlLnBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxvZ2dlZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlciA9IG5ldyBVc2VyXzEuZGVmYXVsdChtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5pbml0U2NlbmUoMiAvKiBTY2VuZUxpc3QuR2FtZVNjZW5lICovLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFVzZXI6IG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGF0TWVzc2FnZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lIGluc3RhbmNlb2YgR2FtZVNjZW5lXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUubmV3Q2hhdChtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwcm9maWxlRGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lIGluc3RhbmNlb2YgR2FtZVNjZW5lXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUucHJvZmlsZURhdGEobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnJpZW5kc0RhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuZnJpZW5kcyA9IG1lc3NhZ2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lIGluc3RhbmNlb2YgR2FtZVNjZW5lXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUucmVsb2FkRnJpZW5kcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNob3BEYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlciA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUgaW5zdGFuY2VvZiBHYW1lU2NlbmVfMS5kZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5zaG9wRGF0YShtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzaG9wSXRlbXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZSBpbnN0YW5jZW9mIEdhbWVTY2VuZV8xLmRlZmF1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lLnNob3BEYXRhSXRlbXMobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXZhdGFyVXBkYXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlciA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyLmF2YXRhciA9IG1lc3NhZ2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lIGluc3RhbmNlb2YgR2FtZVNjZW5lXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUudXBkYXRlQXZhdGFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmFua1VwZGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlci5yYW5rID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUgaW5zdGFuY2VvZiBHYW1lU2NlbmVfMS5kZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5yZW5kZXJNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29pbnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuY29pbnMgPSBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZEl0ZW1cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIuaXRlbXMucHVzaChtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUgaW5zdGFuY2VvZiBHYW1lU2NlbmVfMS5kZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5yZWZyZXNoU2hvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlYWRlcmJvYXJkRGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuY3VycmVudFVzZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lIGluc3RhbmNlb2YgR2FtZVNjZW5lXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUuc2V0TGVhZGVyYm9hcmREYXRhKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkbWluQWxlcnRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LmN1cnJlbnRVc2VyID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZSBpbnN0YW5jZW9mIEdhbWVTY2VuZV8xLmRlZmF1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLmRlZmF1bHQuc2NlbmVNYW5hZ2VyLnNjZW5lLnJlbmRlckFkbWluQWxlcnQobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYWRtaW5EYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5jdXJyZW50VXNlciA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEuZGVmYXVsdC5zY2VuZU1hbmFnZXIuc2NlbmUgaW5zdGFuY2VvZiBHYW1lU2NlbmVfMS5kZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5kZWZhdWx0LnNjZW5lTWFuYWdlci5zY2VuZS5yZW5kZXJBZG1pbihtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRNc2coa2V5LCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgPT0gbnVsbCB8fCB0aGlzLndzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKVxuICAgICAgICAgICAgcmV0dXJuIG1haW5fMS5kZWZhdWx0LmxvZ2dlci5zZW5kTG9nKFwiRVJST1JcIiwgXCJJbXBvc3NpYmxlIHRvIHNlbmQgbWVzc2FnZSB0byBzZXJ2ZXIsIHdlYnNvY2tldHMgYXJlIGRpc2Nvbm5lY3QuXCIpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoeyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICBjb25zdCBjb21wcmVzc2VkTWVzc2FnZSA9IHBha29fMS5kZWZhdWx0LmRlZmxhdGUobWVzc2FnZSk7XG4gICAgICAgIHRoaXMud3Muc2VuZChjb21wcmVzc2VkTWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gV2Vic29ja2V0TWFuYWdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5yZXF1aXJlKFwiLi9VdGlscy9VdGlsc1wiKTtcbmNvbnN0IExvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvTG9nZ2VyL0xvZ2dlclwiKSk7XG5jb25zdCBMYW5ndWFnZU1hbmFnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9MYW5ndWFnZS9MYW5ndWFnZU1hbmFnZXJcIikpO1xuY29uc3QgU2NlbmVNYW5hZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vU2NlbmUvU2NlbmVNYW5hZ2VyXCIpKTtcbmNvbnN0IENvbmZpZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0NvbmZpZy9Db25maWdcIikpO1xuY29uc3QgUmVzb3VyY2VNYW5hZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUmVzc291cmNlL1Jlc291cmNlTWFuYWdlclwiKSk7XG5jb25zdCBTZXR0aW5nc01hbmFnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9TZXR0aW5ncy9TZXR0aW5nc01hbmFnZXJcIikpO1xuY29uc3QgV2ViU29ja2V0c01hbmFnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9XZWJTb2NrZXRzL1dlYlNvY2tldHNNYW5hZ2VyXCIpKTtcbmNvbnN0IFJlZ2lvblNlcnZlck1hbmFnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9XZWJTb2NrZXRzL1JlZ2lvblNlcnZlci9SZWdpb25TZXJ2ZXJNYW5hZ2VyXCIpKTtcbmNvbnN0IEdhbWVTY2VuZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1NjZW5lL0xpc3QvR2FtZVNjZW5lXCIpKTtcbmxldCBBcHBsaWNhdGlvbjtcbmNsYXNzIEFwcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IExvZ2dlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5sYW5ndWFnZU1hbmFnZXIgPSBuZXcgTGFuZ3VhZ2VNYW5hZ2VyXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlciA9IG5ldyBTY2VuZU1hbmFnZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gbmV3IFJlc291cmNlTWFuYWdlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRzTWFuYWdlciA9IG5ldyBXZWJTb2NrZXRzTWFuYWdlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5yZWdpb25TZXJ2ZXJNYW5hZ2VyID0gbmV3IFJlZ2lvblNlcnZlck1hbmFnZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNYW5hZ2VyID0gbmV3IFNldHRpbmdzTWFuYWdlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENhbGwgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5lbGFwc2VkID0gMDsgLy8gSW5pdGlhbGl6ZSBlbGFwc2VkIHRvIDBcbiAgICAgICAgdGhpcy5lbGFwc2VkVGhlbiA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBDb3JyZWN0ZWQgdmFyaWFibGUgbmFtZVxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5sYW5ndWFnZU1hbmFnZXIuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01hbmFnZXIuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuaW5pdFNjZW5lKDAgLyogU2NlbmVMaXN0Lk1lc3NhZ2VTY2VuZSAqLywge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IEFwcGxpY2F0aW9uLmxhbmd1YWdlTWFuYWdlci5nZXRWYWx1ZUZvcktleSgnTE9BRElOR19NRVNTQUdFJywgW0NvbmZpZ18xLmRlZmF1bHQuTkFNRV0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlTG9hZGluZyA9IHlpZWxkIHRoaXMucmVzb3VyY2VNYW5hZ2VyLmluaXQoKTtcbiAgICAgICAgICAgIEFwcGxpY2F0aW9uLmxvZ2dlci5zZW5kTG9nKFwiU1VDQ0VTU1wiLCBtZXNzYWdlTG9hZGluZyk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLndlYlNvY2tldHNNYW5hZ2VyLmluaXQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuZWxhcHNlZCA9IG5vdyAtIHRoaXMuZWxhcHNlZFRoZW47XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzTWFuYWdlci5ncmFwaGljcy5mcHMgIT0gMCAmJiB0aGlzLmVsYXBzZWQgPCAoMTAwMCAvIHRoaXMuc2V0dGluZ3NNYW5hZ2VyLmdyYXBoaWNzLmZwcykpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3NNYW5hZ2VyLmdyYXBoaWNzLmZwcyAhPSAwKVxuICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGhlbiA9IG5vdyAtICh0aGlzLmVsYXBzZWQgJSAoMTAwMCAvIHRoaXMuc2V0dGluZ3NNYW5hZ2VyLmdyYXBoaWNzLmZwcykpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IChub3cgLSB0aGlzLmxhc3RDYWxsKSAvIDEwMDA7XG4gICAgICAgIHRoaXMubGFzdENhbGwgPSBub3c7XG4gICAgICAgIGlmICh0aGlzLnNjZW5lTWFuYWdlci5zY2VuZSBpbnN0YW5jZW9mIEdhbWVTY2VuZV8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnNjZW5lLnJlbmRlckdhbWUoZGVsdGEpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuc2NlbmUuc2V0RnBzKE1hdGgucm91bmQoMSAvIGRlbHRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG59XG5BcHBsaWNhdGlvbiA9IG5ldyBBcHAoKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFwcGxpY2F0aW9uO1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIChldmVudCkgPT4ge1xuICAgIEFwcGxpY2F0aW9uLmluaXQoKS5jYXRjaCgoZSkgPT4gQXBwbGljYXRpb24ubG9nZ2VyLnNlbmRDcml0aWNhbEVycm9yKGUudG9TdHJpbmcoKSkpO1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZSA9IHZvaWQgMDtcbmV4cG9ydHMuQmFzZSA9IHtcbiAgICBob2NrZXk6IHtcbiAgICAgICAgYmdfY29sb3I6ICdyZ2IoODUsIDg1LCA4NSknLFxuICAgICAgICBib3JkZXJfY29sb3I6ICdyZ2IoMjMzLDIwNCwxMTApJyxcbiAgICB9LFxuICAgIGdyYXNzOiB7XG4gICAgICAgIGJnX2NvbG9yOiAncmdiKDExMywxNDAsOTApJyxcbiAgICAgICAgYm9yZGVyX2NvbG9yOiAncmdiKDE5OSwyMzAsMTg5KScsXG4gICAgfSxcbiAgICBzZWdtZW50X2NvbG9yOiAncmdiKDAsMCwwKScsXG4gICAgcGxheWVyUGh5c2ljczoge1xuICAgICAgICByYWRpdXM6IDE1LFxuICAgICAgICBiQ29lZjogMC41LFxuICAgICAgICBpbnZNYXNzOiAwLjUsXG4gICAgICAgIGRhbXBpbmc6IDAuOTYsXG4gICAgICAgIGFjY2VsZXJhdGlvbjogMC4xLFxuICAgICAgICBraWNraW5nQWNjZWxlcmF0aW9uOiAwLjA3LFxuICAgICAgICBraWNraW5nRGFtcGluZzogMC45NixcbiAgICAgICAga2lja1N0cmVuZ3RoOiA1LFxuICAgICAgICBwb3M6IFswLCAwXSxcbiAgICAgICAgY01hc2s6IFsnYWxsJ10sXG4gICAgICAgIGNHcm91cDogWycnXSxcbiAgICB9LFxuICAgIGJhbGxQaHlzaWNzOiB7XG4gICAgICAgIHJhZGl1czogMTAsXG4gICAgICAgIGJDb2VmOiAwLjUsXG4gICAgICAgIGludk1hc3M6IDEsXG4gICAgICAgIGRhbXBpbmc6IDAuOTksXG4gICAgICAgIGNvbG9yOiAnRkZGRkZGJyxcbiAgICAgICAgcG9zOiBbMCwgMF0sXG4gICAgICAgIGNNYXNrOiBbJ2FsbCddLFxuICAgICAgICBjR3JvdXA6IFsnYmFsbCddLFxuICAgIH0sXG4gICAgZGlzY1BoeXNpY3M6IHtcbiAgICAgICAgcmFkaXVzOiAxMCxcbiAgICAgICAgYkNvZWY6IDAuNSxcbiAgICAgICAgaW52TWFzczogMCxcbiAgICAgICAgZGFtcGluZzogMC45OSxcbiAgICAgICAgY29sb3I6ICdyZ2IoMjU1LDI1NSwyNTUpJyxcbiAgICAgICAgY01hc2s6IFsnYWxsJ10sXG4gICAgICAgIGNHcm91cDogWydhbGwnXSxcbiAgICB9LFxuICAgIHNlZ21lbnRQaHlzaWNzOiB7XG4gICAgICAgIGN1cnZlOiAwLFxuICAgICAgICBiQ29lZjogMSxcbiAgICAgICAgY0dyb3VwOiBbJ3dhbGwnXSxcbiAgICAgICAgY01hc2s6IFsnYWxsJ10sXG4gICAgfSxcbiAgICBwbGFuZVBoeXNpY3M6IHtcbiAgICAgICAgYkNvZWY6IDEsXG4gICAgICAgIGNHcm91cDogWyd3YWxsJ10sXG4gICAgICAgIGNNYXNrOiBbJ2FsbCddLFxuICAgIH0sXG4gICAgdmVydGV4UGh5c2ljczoge1xuICAgICAgICBiQ29lZjogMSxcbiAgICAgICAgY0dyb3VwOiBbJ3dhbGwnXSxcbiAgICAgICAgY01hc2s6IFsnYWxsJ10sXG4gICAgfSxcbiAgICBjb2xsaXNpb25GbGFnczoge1xuICAgICAgICBhbGw6IDYzLFxuICAgICAgICBiYWxsOiAxLFxuICAgICAgICBibHVlOiA0LFxuICAgICAgICBibHVlS086IDE2LFxuICAgICAgICBjMDogMjY4NDM1NDU2LFxuICAgICAgICBjMTogNTM2ODcwOTEyLFxuICAgICAgICBjMjogMTA3Mzc0MTgyNCxcbiAgICAgICAgYzM6IC0yMTQ3NDgzNjQ4LFxuICAgICAgICBraWNrOiA2NCxcbiAgICAgICAgcmVkOiAyLFxuICAgICAgICByZWRLTzogOCxcbiAgICAgICAgc2NvcmU6IDEyOCxcbiAgICAgICAgd2FsbDogMzIsXG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIFJPT01fQU5OT1VOQ0VNRU5UOiBcIiNkYjg4MjJcIixcbiAgICBGUklFTkQ6IFwiIzI4YjM0ZFwiLFxuICAgIEVSUk9SOiBcIiNiOTI2MjZcIlxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFbG8gPSB2b2lkIDA7XG5jb25zdCBnZXRFbG8gPSBmdW5jdGlvbiAoZWxvKSB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgKGVsbyA+IDIwMDApOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19DSEFMTEVOR0VSXCIsIHZhbHVlOiAwIH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDE5MDApOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19DSEFNUElPTlwiLCB2YWx1ZTogNSB9O1xuICAgICAgICBjYXNlIChlbG8gPiAxODAwKTpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwiR0FNRV9FTE9fQ0hBTVBJT05cIiwgdmFsdWU6IDQgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gMTcwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0NIQU1QSU9OXCIsIHZhbHVlOiAzIH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDE2MDApOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19DSEFNUElPTlwiLCB2YWx1ZTogMiB9O1xuICAgICAgICBjYXNlIChlbG8gPiAxNTAwKTpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwiR0FNRV9FTE9fQ0hBTVBJT05cIiwgdmFsdWU6IDEgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gMTQwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0RJQU1PTkRcIiwgdmFsdWU6IDUgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gMTMwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0RJQU1PTkRcIiwgdmFsdWU6IDQgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gMTIwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0RJQU1PTkRcIiwgdmFsdWU6IDMgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gMTEwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0RJQU1PTkRcIiwgdmFsdWU6IDIgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gMTAwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0RJQU1PTkRcIiwgdmFsdWU6IDEgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gOTAwKTpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwiR0FNRV9FTE9fUExBVElOSVVNXCIsIHZhbHVlOiA1IH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDg1MCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX1BMQVRJTklVTVwiLCB2YWx1ZTogNCB9O1xuICAgICAgICBjYXNlIChlbG8gPiA4MDApOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19QTEFUSU5JVU1cIiwgdmFsdWU6IDMgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gNzUwKTpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwiR0FNRV9FTE9fUExBVElOSVVNXCIsIHZhbHVlOiAyIH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDcwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX1BMQVRJTklVTVwiLCB2YWx1ZTogMSB9O1xuICAgICAgICBjYXNlIChlbG8gPiA2NTApOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19HT0xEXCIsIHZhbHVlOiA1IH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDYwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0dPTERcIiwgdmFsdWU6IDQgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gNTUwKTpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwiR0FNRV9FTE9fR09MRFwiLCB2YWx1ZTogMyB9O1xuICAgICAgICBjYXNlIChlbG8gPiA1MDApOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19HT0xEXCIsIHZhbHVlOiAyIH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDQ1MCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0dPTERcIiwgdmFsdWU6IDEgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gNDAwKTpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwiR0FNRV9FTE9fQlJPTlpFXCIsIHZhbHVlOiA1IH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDM1MCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0JST05aRVwiLCB2YWx1ZTogNCB9O1xuICAgICAgICBjYXNlIChlbG8gPiAzMDApOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19CUk9OWkVcIiwgdmFsdWU6IDMgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gMjUwKTpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwiR0FNRV9FTE9fQlJPTlpFXCIsIHZhbHVlOiAyIH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDIwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0JST05aRVwiLCB2YWx1ZTogMSB9O1xuICAgICAgICBjYXNlIChlbG8gPiAxNTApOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19JUk9OXCIsIHZhbHVlOiA1IH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDEwMCk6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcIkdBTUVfRUxPX0lST05cIiwgdmFsdWU6IDQgfTtcbiAgICAgICAgY2FzZSAoZWxvID4gNTApOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19JUk9OXCIsIHZhbHVlOiAzIH07XG4gICAgICAgIGNhc2UgKGVsbyA+IDI1KTpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwiR0FNRV9FTE9fSVJPTlwiLCB2YWx1ZTogMiB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJHQU1FX0VMT19JUk9OXCIsIHZhbHVlOiAxIH07XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0RWxvID0gZ2V0RWxvO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldExldmVsID0gdm9pZCAwO1xuY29uc3QgZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoeHApIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoTWF0aC5zcXJ0KDEwMCAqICgyICogeHAgKyAyNSkpICsgNTApIC8gMTAwKTtcbn07XG5leHBvcnRzLmdldExldmVsID0gZ2V0TGV2ZWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0xldmVsID0ge1xuICAgIElORk86IHtcbiAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgIG5hbWU6IFwiSU5GT1wiLFxuICAgICAgICBiZ0NvbG9yOiBcIlxceDFiWzQ0bVwiLFxuICAgICAgICBiZ1dlYkNvbG9yOiBcIiMxOTY4OUJcIlxuICAgIH0sXG4gICAgV0FSTklORzoge1xuICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgbmFtZTogXCJXQVJOSU5HXCIsXG4gICAgICAgIGJnQ29sb3I6IFwiXFx4MWJbNDNtXCIsXG4gICAgICAgIGJnV2ViQ29sb3I6IFwiI0NGN0UwRlwiXG4gICAgfSxcbiAgICBFUlJPUjoge1xuICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgbmFtZTogXCJFUlJPUlwiLFxuICAgICAgICBiZ0NvbG9yOiBcIlxceDFiWzQxbVwiLFxuICAgICAgICBiZ1dlYkNvbG9yOiBcIiNBRjFCMUJcIlxuICAgIH0sXG4gICAgQ1JJVElDQUxfRVJST1I6IHtcbiAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgIG5hbWU6IFwiQ1JJVElDQUwgRVJST1JcIixcbiAgICAgICAgYmdDb2xvcjogXCJcXHgxYls0MW1cIixcbiAgICAgICAgYmdXZWJDb2xvcjogXCIjQUYxQjFCXCJcbiAgICB9LFxuICAgIFNVQ0NFU1M6IHtcbiAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgIG5hbWU6IFwiU1VDQ0VTU1wiLFxuICAgICAgICBiZ0NvbG9yOiBcIlxceDFiWzQybVwiLFxuICAgICAgICBiZ1dlYkNvbG9yOiBcIiMxNjdDNDNcIlxuICAgIH0sXG4gICAgREVCVUc6IHtcbiAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgIG5hbWU6IFwiREVCVUdcIixcbiAgICAgICAgYmdDb2xvcjogXCJcXHgxYls0Nm1cIixcbiAgICAgICAgYmdXZWJDb2xvcjogXCIjOTUxRDhBXCJcbiAgICB9LFxuICAgIFZFUkJPU0U6IHtcbiAgICAgICAgbGV2ZWw6IDIsXG4gICAgICAgIG5hbWU6IFwiVkVSQk9TRVwiLFxuICAgICAgICBiZ0NvbG9yOiBcIlxceDFiWzQ1bVwiLFxuICAgICAgICBiZ1dlYkNvbG9yOiBcIiM5MThEMTJcIlxuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBMb2dMZXZlbDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nTGV2ZWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Mb2dMZXZlbFwiKSk7XG5jbGFzcyBMb2dnZXIge1xuICAgIHNlbmRMb2cobG9nS2V5LCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKExvZ0xldmVsXzEuZGVmYXVsdFtsb2dLZXldLmJnQ29sb3IsIExvZ0xldmVsXzEuZGVmYXVsdFtsb2dLZXldLm5hbWUsIFwiXFx4MWJbMG1cIiwgbWVzc2FnZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAlYyAke0xvZ0xldmVsXzEuZGVmYXVsdFtsb2dLZXldLm5hbWV9ICVjICR7bWVzc2FnZX1gLCBgYmFja2dyb3VuZC1jb2xvcjogJHtMb2dMZXZlbF8xLmRlZmF1bHRbbG9nS2V5XS5iZ1dlYkNvbG9yfTsgY29sb3I6ICNGRkY7IGZvbnQtd2VpZ2h0OiBib2xkYCwgYGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7IGNvbG9yOiBpbmhlcml0YCk7XG4gICAgfVxuICAgIHNlbmRDcml0aWNhbEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5zZW5kTG9nKFwiQ1JJVElDQUxfRVJST1JcIiwgbWVzc2FnZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBMb2dnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUm9vbVN0YXRlID0gdm9pZCAwO1xudmFyIFJvb21TdGF0ZTtcbihmdW5jdGlvbiAoUm9vbVN0YXRlKSB7XG4gICAgUm9vbVN0YXRlW1Jvb21TdGF0ZVtcIktJQ0tfT0ZGX1JFU0VUXCJdID0gMF0gPSBcIktJQ0tfT0ZGX1JFU0VUXCI7XG4gICAgUm9vbVN0YXRlW1Jvb21TdGF0ZVtcIlBBVVNFXCJdID0gMV0gPSBcIlBBVVNFXCI7XG4gICAgUm9vbVN0YXRlW1Jvb21TdGF0ZVtcIlVOUEFVU0VcIl0gPSAyXSA9IFwiVU5QQVVTRVwiO1xuICAgIFJvb21TdGF0ZVtSb29tU3RhdGVbXCJQTEFZXCJdID0gM10gPSBcIlBMQVlcIjtcbiAgICBSb29tU3RhdGVbUm9vbVN0YXRlW1wiR09BTF9TQ09SRVwiXSA9IDRdID0gXCJHT0FMX1NDT1JFXCI7XG4gICAgUm9vbVN0YXRlW1Jvb21TdGF0ZVtcIkdBTUVfRU5ERURcIl0gPSA1XSA9IFwiR0FNRV9FTkRFRFwiO1xufSkoUm9vbVN0YXRlIHx8IChleHBvcnRzLlJvb21TdGF0ZSA9IFJvb21TdGF0ZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFNoYXJlYWJsZURhdGEge1xuICAgIGNvbnN0cnVjdG9yKHRzLCBwKSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdHM7XG4gICAgICAgIHRoaXMuc2hhcmVhYmxlRGF0YSA9IHA7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2hhcmVhYmxlRGF0YTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVGVhbSA9IHtcbiAgICBTUEVDVEFUT1JTOiB7XG4gICAgICAgIGlkOiAwLFxuICAgICAgICBuYW1lOiBcInNwZWN0YXRvcnNcIixcbiAgICAgICAgY29sb3I6ICcjRkZGJyxcbiAgICAgICAgY0dyb3VwOiAwLFxuICAgIH0sXG4gICAgUkVEOiB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBuYW1lOiBcInJlZFwiLFxuICAgICAgICBjb2xvcjogJyNiZDM4MzgnLFxuICAgICAgICBjR3JvdXA6IDIsXG4gICAgfSxcbiAgICBCTFVFOiB7XG4gICAgICAgIGlkOiAyLFxuICAgICAgICBuYW1lOiBcImJsdWVcIixcbiAgICAgICAgY29sb3I6ICcjMTM2ZWFjJyxcbiAgICAgICAgY0dyb3VwOiA0LFxuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBUZWFtO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vY2xpZW50L21haW4udHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=